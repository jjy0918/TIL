# JPA

## ORM이란?

- Object-Relational Mapping
- 객체는 객체대로 설계하고, 관계형 데이터베이스는 관계형 데이터베이스 대로 설계하는 것.
- ORM 프레임 워크가 RDB와 객체를 매핑시켜준다.
- 각 언어에는 대부분 ORM이 존재한다.
- 장점
  - 개발자는 DB조작에 대한 부분을 신경쓰지 않고, 비즈니스 로직에만 집중할 수 있다.
  - 객체지향적인 코드 작성이 가능하다.
  - 매핑 정보가 Class로 명시되어 있기 때문에 ERD를 보는 의존도를 낮출 수 있고, 유지보수 및 리펙토링에 유리하다.
  - RDB에 종속적이지 않게 된다.
- 단점
  - 설계가 잘못된 경우 속도 저하 등의 문제점이 발생할 수 있다.
  - 복잡하고 무거운 Query는 속도를 위해 별도의 튜닝이 필요하다.

<br>

<hr>

<br>

## JPA란?

- 자바 진영에서 사용하는 ORM 기술 표준
- 인터페이스 모음
- JPA를 구현한 것이 Hibernate, EclipseLinkm, DataNucleus 이다.
- JPA는 애플리케이션과 JDBC 사이에서 동작한다.
  - 개발자가 JPA를 사용하면 JPA 내부에서 JDBC API를 사용하여 SQL을 호출한다.

<br>

<hr>

<br>

## JPA를 사용해야 하는 이유

- SQL 중심적인 개발이 아니라, 객체 중심적인 개발 가능
- CRUD가 간단하다.
- SQL을 직접 수정하지 않기 때문에 유지보수가 쉽다.
- JPA 성능 최적화 기능
  - 중간 계층이 있는 경우 성능을 개선할 수 있다.
  - 캐싱 기능
    - 같은 트랜잭션 안에서는 같은 엔티티를 반환한다.
  - 버퍼링 기능
    - INSERT 시 트랜잭션을 커밋하기 전까지 SQL을 메모리에 쌓는다.
    - UPDATE, DELETE 시 로우락 시간 최소화와 SQL 트랜잭션 커밋 시 SQL 실행하고 바로 커밋한다.
  - 지연 로딩(Lazy Loading)
    - 객체가 실제로 사용될 때 로딩되는 전략
    - 값이 실제 필요한 시점에 JPA가 해당 부분에 대한 SELECT 쿼리를 날린다.
    - 각각 조회를 하기 때문에 네트워크를 2번 타게 된다.
    - 대부분 같이 사용한다면, 즉시 로딩을 사용하는게 좋다.
    - 즉시 로딩 : JOIN SQL로 한 번에 연관된 객체끼리 미리 조회하는 전략
    - 애플리케이션 개발 시 모두 지연 로딩으로 설정한 후, 성능 최적화가 필요할 때 옵션을 변경하는 것이 좋다.

<br>

<hr>

<br>

## Spring Data JPA

- JPA를 사용하기 편하게 만들어 놓은 모듈
- Repoistory가 Spring Data JPA의 핵심이다.
- Spring Data JPA는 Spring에서 제공하는 모듈 중 하나이다.
- Repository는 JPA를 한 단계 추상화 시켜서 인터페이스로 제공함으로써 개발자가 더 쉽게 JPA를 사용할 수 있도록 도와준다.
- 사용자가 Repository 인터페이스를 정해진 규칙대로 메소드를 입력하면, Spring이 알아서 해당 메소드 이름에 적합한 쿼리를 날리는 구현체를 만들어 Bean으로 등록해준다.
- Spring Data JPA의 Repository는 내부적으로 JPA를 사용하고 있다.
  - Repository의 인터페이스 기본 구현체의 내부에서 EntityManager를 사용하고 있다.

[ 출처 ]

https://gmlwjd9405.github.io/2019/08/04/what-is-jpa.html

https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/

# N+1 문제

## N+1 문제란?

- 연관 관계가 설정된 엔티티를 조회할 때 조회된 개수(N) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 것.
- 단순히 JPA에서 FetchType.EAGER라서 발생하는 문제가 아니다.
- 결국, FetchType.LAZY라고 하더라도 해당 엔티티를 실행하게 되면 N+1문제가 발생하게 된다.
- => FetchType의 변화는 단순히 N+1 발생 시점을 미루게 되는 것이다.

<br>

<hr>

<br>

## N+1 발생이유?

- Repository에 정의한 인터페이스 실행 시 JPA는 메소드 이름을 분석하여 JPQL을 생성하여 실행한다.
- JPQL은 연관관계 데이터를 무시하고, 해당 엔티티 기준으로 쿼리를 조회한다.
- JPQL 호출 시 영속성이 아니라, 데이터베이스를 우선 적으로 조회한다.
- 그렇기 때문에 연관된 엔티티 데이터가 필요한 경우 FetchType으로 지정한 시점에 조회를 별도로 호출하게 된다.

<br>

<hr>

<br>

## 해결방안

- Batch Size

  - @BatchSize 어노테이션을 통해서 설정한 Size 만큼 데이터를 미리 로딩하는 것.
  - 연관관계 데이터 사이즈를 정확하게 알 수 있다면 최적화할 Size를 정할 수 있지만, 사실상 연관관계 데이터를 정확하게 알 수 없다.

- 패치 조인

  - fectch join 키워드를 사용하여 한 번에 조회한다.
  - 연관된 엔티티가 프록시가 아닌 실제 엔티티를 조회하게 되므로 연관관계 객체까지 한 번의 쿼리로 가져올 수 있다.
  - 하지만, FetchType을 사용할 수 없기 때문에 Lazy 전략이 통하지 않는다.
  - 또한, 페이징 쿼리를 사용할 수 없다.
  - 중복 데이터 관리가 따로 필요하다.

- QueryBuilder 사용
  - MyBatis, QueryDsl, JOOQ, JDBC Template 등을 이용하여 최적화 쿼리를 구현한다.

[ 출처 ]

https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1

https://www.popit.kr/jpa-n1-%EB%B0%9C%EC%83%9D%EC%9B%90%EC%9D%B8%EA%B3%BC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95/

# Index

## Index란?

- RDBS에서 검색 속도를 높이기 위한 기술
- Table의 Column을 색인화 하여 따로 파일로 저장한다.
  - 해당 Table의 Record를 Full Scan 하지 않는다.
  - 색인화 된(B+Tree구조) Index 파일 검색으로 검색 속도를 향상 시킨다.
- SELECT 쿼리의 WHERE 절이나, JOIN 사용 시 인덱스가 사용되며, SELECT 쿼리의 검색 속도를 빠르게 하는데 목적을 두고 있다.
- DELETE, INSERT, UPDATE 쿼리에서는 오히려 INDEX 사용 시 느려진다.

<br>

<hr>

<br>

## Index 생성 시 발생되는 특징

- 검색 속도 향상
  - 시스템 부하를 줄여, 시스템 전체 성능 향상에 기여 가능하다.
- 인덱스를 위한 추가 공간이 필요하다.
- 생성에 시간이 소요 될 수 있다.
- INSERT, UPDATE, DELETE가 자주 발생하면 성능이 많이 하락할 수 있다.

<br>

<hr>

<br>

## 인덱스 종류

- 클러스터형 인덱스(Clustered Index)
- 테이블당 한 개만 생성이 가능하다.
- 행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬한다.
- 비 클러스터형 인덱스(NonClustered Index)
- 테이블당 여러 개를 생성할 수 있다.
- 비클러스터형 인덱스는 정렬되어 있지 않고, 찾아보기와 비슷하다.

<br>

<hr>

<br>

## 인덱스 생성

- 인덱스는 열 단위로 생성된다.
- 하나의 열에 인덱스를 생성할 수 있고, 여러 열에 하나의 인덱스를 생성할 수 있다.
- 테이블 생성 시 PK는 자동으로 클러스터형 인덱스로 생성된다.
- PK를 지정하는 열에 강제적으로 비클러스터형 인덱스를 지정할 수 있다.
- 제약 조건 없이 테이블 생성시에 인덱스를 만들 수 없으며, 인덱스가 자동 생성되기 위한 열의 제약 조건은 PK또는 Unique뿐이다.

<br>

<hr>

<br>

## 클러스터형 인덱스

- 인덱스를 생성할 때는 데이터 페이지 전체를 다시 정렬한다.
- 비클러스터형 인덱스 보다 검색 속도는 더 빠르지만, 수정, 삭제 등의 기능은 더 느리다.
- 클러스터 인덱스는 성능이 좋지만, 테이블 한 개만 생성할 수 있다. 그래서 어느 열에 클러스터형 인덱스를 생성하느냐에 따라서 시스템의 성능이 달라질 수 있다.

<br>

<hr>

<br>

## 비클러스터형 인덱스

- 비클러스터형 인덱스를 생성할 때는 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다.
- 비클러스터형 인덱스에서 인덱스 자체의 리프 페이지는 데이터가 아니라, 데이터가 위치하는 포인터(RID)다.
- 클러스터형 보다 검색 속도는 느리지만, 데이터의 입력/수정/삭제는 더 빠르다.
- 비클러스터형 인덱스는 여러 개 생성할 수 있다. 하지만, 함부로 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 가져온다.

<br>

<hr>

<br>

## 과정

- Table을 생성하면, MYD, MYI, FRM 3개의 파일이 생성된다.
- FRM : 테이블 구조가 저장되어 있는 파일
- MYD : 실제 데이터가 있는 파일
- MYI : Index 정보가 들어가 있는 파일
- Index를 사용하지 않는 경우, MYI 파일은 비어져 있다. 그러나 인덱싱을 하는 경우 MYI 파일이 생성된다. 이후로 사용자가 Select 쿼리로 Index를 사용하는 Column을 탐색 시, MYI 파일의 내용을 검색한다.
  단점
- Index 생성 시, .mdb 파일 크기가 증가한다.
- 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
- 인덱스 된 Field에서 Data를 업데이트 하거나, Record를 추가 또는 삭제 시 성능이 떨어진다.
- 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성 해야 하므로, 성능에 영향을 미친다.

<br>

<hr>

<br>

## Index 사용하면 좋은 경우

- Where절에서 자주 사용되는 Column
- 외래키가 자주 사용되는 Column
- Join에 자주 사용되는 Column

## Index 사용하면 좋지 않은 경우

- Data 중복도가 높은 Column
- DML이 자주 일어나는 Column

[ 출처 ]
https://mongyang.tistory.com/75
