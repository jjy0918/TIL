# 4. 아키텍처

## 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL의 전체 구조

- MySQL은 C API, JDBC, ODBC, .NET 등의 표준 드라이버를 제공하여 C/C++, JAVA 등의 모든 언어에서 사용할 수 있도록 해준다.
- MySQL 서버는 `MySQL 엔진`과 `스토리지 엔진`으로 구분할 수 있다.

#### 4.1.1.1 MySQL 엔진

- MySQL 엔진은 클라이언트로부터 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리 옵티마이저가 중심을 이룬다.
- MySQL은 ANSI SQL을 지원하기 때문에 타 DBMS와 호환되어 실행될 수 있다.

#### 4.1.1.2 스토리지 엔진

- 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 담당한다.
- MySQL 엔진은 서버 당 하나지만, 스토리지 엔진은 여러 개 동시에 사용할 수 있다.
- 특정 테이블이 사용할 스토리지 엔진을 지정하여 처리할 수 있다.
  - `CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;`
- 각 스토리지 엔진은 성능 향상을 위해 캐시 키(MyISAM 스토리지 엔진)나 InnoDB 버퍼 풀과 같은 기능을 내장하고 있다.

#### 4.1.1.3 핸들러 API

- MySQL 엔진의 쿼리 실행기에서 데이터 읽거나 쓸 때 스토리지 엔진에 요청하는데, 이러한 요청을 핸들러(Handler) 요청이라고 한다.
- 즉, MySQL 엔진과 스토리지 엔진 사이에 데이터를 주고 받을 때 핸들러 API를 사용한다.
- 핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있었는지 확인할 수 있다.
  - `SHOW GLOBAL STATUS LIKE 'Handler%';`

### 4.1.2 MySQL 스레딩 구조

- MySQL은 스레드 기반으로 동작하며, 프어그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분된다.
- MySQL 서버에서 실행 중인 스레드 목록은 `performance_schema` 데이터베이스의 `thread` 테이블을 통해 확인할 수 있다.
  - `SELECT thread_id, name, type, processlist_user, processlist_host FROM performance_schema.threads`;
- 백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적일 수 있다.
- 동일한 이름의 스레드가 2개 이상 보이는 것은 서버 설정에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우다.
- MySQL 커뮤니티 에디션에서는 전통적인 스레드 모델이다.
- MySQL 엔터프라이즈 에디션과 Percona에서는 스레드 풀 모델도 사용할 수 있다.

#### 4.1.2.1 포어그라운드 스레드(클라이언트 스레드)

- 포어그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재한다.
- 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.
- 클라이언트 커넥션이 종료되면, 해당 커넥션을 담당하는 스레드는 다시 스레드 캐시(Thread Cache)로 되돌아간다.
  - 스레드 캐시에 일정 개수 이상이 대기중이라면, 그냥 종료시킨다.
  - 스레드 캐시에 유지할 수 있는 최대 개수는 `thread_cache_size` 시스템 변수에서 설정한다.
- 포어그라운드 스레드는 `데이터`를 `데이터 버퍼`나 `캐시`로부터 가져온다.
  - 데이터 버퍼나 캐시에 없는 경우 `직접 디스크의 데이터나 인덱스 파일`로부터 읽어온다.
- MyISAM 테이블은 쓰기 작업 까지 포어그라운드 스레드가 처리한다.
- InnoDB 테이블은 데이터 버퍼나 캐시까지만 포어그라운드 스레드가 처리하고, 버퍼에서 디스크까지 기록하는 것은 백그라운드 스레드가 처리한다.

#### 4.1.2.2 백그라운드 스레드

- InnoDB는 여러 작업을 백그라운드에서 처리한다.
  - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
  - 로그를 디스크로 기록하는 스레드
  - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 데이터를 버퍼로 읽어 오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드
- MySQL 5.5 이상에서는 쓰기 스레드와 데이터 읽기 쓰레드의 개수를 2개 이상 지정할 수 있다.
  - `innodb_write_io_threads`, `innodb_read_io_threads` 시스템 변수로 설정한다.
- 읽기 작업의 경우 클라이언트 스레드에서 처리되지만, 쓰기 작업은 백그라운드로 처리하기 때문에 디스크에 따라서 최적으로 설정해주어야 한다.
  - 내장 디스크의 경우 2~4
  - DAS, SAN과 같은 스토리지에서는 디스크를 최적으로 사용할 수 있게 충분히
- InnoDB에서는 일반적으로 읽기는 즉시 실행되지만, 쓰기는 버퍼링해서 일괄 처리한다.

### 4.1.3 메모리 할당 및 사용 구조

- MySQL 메모리는 `글로벌 메모리 영역`과 `로컬 메모리 영역`으로 구분할 수 있다.
- `글로벌 메모리 영역`은 MySQL 서버가 시작되면 운영체제로부터 할당된다.
- 글로벌 메모리 영역과 로컬 메모리 영역은 MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.

#### 4.1.3.1 글로벌 메모리 영역

- 클라이언트 수와 무관하게 하나의 메모리 공간만 할당된다.
  - 필요에 따라 2개 이상의 메모리 공간을 할당받을 수는 있다.
- 대표적인 글로벌 메모리 영역
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼

#### 4.1.3.2 로컬 메모리 영역

- 로컬 메모리 영역은 세션 메모리 영역이라고도 표현한다.
- 로컬 메모리 영역은 MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 영역이다.
- 로컬 메모리 영역은 클라이언트 스레드별로 독립적으로 할당되며, 절대 공유되지 않는다.
- 로컬 메모리 영역은 글로벌 메모리 영역과 달리 크기를 주의해서 설정하지 않기 때문에 최악의 경우 메모리 부족으로 멈출 수 있기 때문에 적절한 메모리 공간을 설정해야 한다.
- 필요할 때가 아니면, 메모리 강간을 할당조차 하지 않을 수 있다.
  - 소트 버퍼, 조인 버퍼 등
- 커넥션 버퍼나 결과 버퍼는 커넥션이 열려 있는 동안 할당된 상태로 남아 있다.
- 로컬 메모리의 대표 영역
  - 정렬 버퍼(Sort buffer)
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

### 4.1.4 플러그인 스토리지 엔진 모델

- MySQL에는 여러 가지 엔진을 플러그인 형태로 개발하여 사용할 수 있다.
- `SHOW ENGINES;` 명령어를 통해 MySQL 서버(mysqld)에서 지원되는 스토리지 엔진을 확인할 수 있다.

+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| ndbcluster         | NO      | Clustered, fault-tolerant tables                               | NULL         | NULL | NULL       |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| ndbinfo            | NO      | MySQL Cluster system information storage engine                | NULL         | NULL | NULL       |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+

- Support 컬럼의 값을 통해 스토리지 엔진 여부를 확인할 수 있다.
  - YES: MySQL 서버에 해당 스토리지 엔진이 포함되어 있고, 사용 가능으로 활성화된 상태
  - DEFAULT: YES와 동일한 상태이지만, 필수 스토리지 엔진임을 의미한다.
  - NO: 현재 MySQL 서버에 포함되지 않았음을 의미한다.
  - DISABLED: 현재 MySQL 서버에는 포함되었지만, 파라미터에 의해 비활성화된 상태
- MySQL 서버에 포함되지 않은 스토리지 엔진을 사용하려면 MySQL 서버를 다시 빌드(컴파일)해야 한다.
- 플러그인 형태로 빌드된 스토리지 엔진 라이브리러를 다운로드 받아 넣으면, 사용할 수 있다.
- `SHOW PLUGINS` 명령을 통해 스토리지 엔진뿐 아니라 인증 및 전문 검색용 파서와 같은 플러그인도 확인할 수 있다.
- 스토리지 엔진 뿐 아니라 다양한 기능을 플러그인 형태로 지원한다.

### 4.1.5 컴포넌트

- MySQL 8.0부터는 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.
- 컴포넌트 아키텍처는 플러그인의 단점을 보완해준다.
  - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없다.
  - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않다.
  - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어렵다.

### 4.1.6 쿼리 실행 구조

- SQL 요청 -> (쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리 실행기) -> (스토리지 엔진)

#### 4.1.6.1 쿼리 파서

- 쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위)으로 분리해 트리 구조 만드는 작업
- 이 과정에서 쿼리 기본 문법 오류가 발견되어 사용자에게 오류 메시지를 전달한다.

#### 4.1.6.2 전처리기

- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.
- 각 토큰을 테이블 이블이나 컬럼 이름, 내장 함수 등 개체를 매핑해 해당 객체의 존재 여부와 접근 권한을 확인한다.
- 실제 존재하지 않거나 권한이 없어서 사용할 수 없는 경우 이 단계에서 걸러진다.

#### 4.1.6.3 옵티마이저

- 옵티마이저는 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 한다.
- 옵티마지어의 역할은 중요하고 영향 범위 또한 아주 넓다

#### 4.1.6.4 실행 엔진

- 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 한다.

#### 4.1.6.5 핸들러(스토리지 엔진)

- 핸들러는 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하거나 읽어온다.
- MyISAM 테이블을 조적하는 경우 MyISAM 스토리지 엔진이 핸들러가 된다.
- InnoDB 테이블을 조작하는 경우 InnoDB 스토리지 엔진이 핸들러가 된다.

### 4.1.7 복제

### 4.1.8 쿼리 캐시(Query Cache)

- 쿼리 캐시는 SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL이 실행되면 메모리에서 즉사 반환하여 빠른 성능을 보일 수 있다.
- 테이블 데이터 변경 시 쿼리 캐시가 모두 삭제되는 과정에서 성능 저하와 버그가 많이 발생하여 MySQL 8.0 부터는 제거되었다.

### 4.1.9 스레드 풀

- 스레드 풀은 MySQL 서버 엔터프라이드 에디션과 Peronana Sever에서 제공된다.
- 스레드 풀은 사용자 요청을 처리하는 스레드 수를 제한하여 서버 자원 소모를 줄이는 것을 목적으로 한다.
  - 하지만, 실제 눈에 띄는 성능 향상을 보여준 경우는 드물다.
- 스레드 풀 내 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다.

### 4.1.10 트랜잭션 지원 메타데이터

- 데이터베이스 서버에서 테이블의 구조 정보, 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 한다.
- MySQL 5.7까지는 테이블 구조를 `FRM`파일에 저장하고, 일부 스토어드 프로그램 파일(TRN, TRG, PAR 등) 기반으로 관리했다.
  - 파일 기반 메타데이터는 생성 및 변경 작업 트랜잭션을 지원하지 않은 상태로 남는 문제가 발생한다.
- MySQL 8.0 부터는 테이블의 구조 정보나 스토어드 프로그램 코드 관련 정보를 모두 InnoDB 테이블에 저장한다.
- 시스템 테이블과 데이터 딕셔너리 정보를 모아서 `mysql DB`에 저장하고 `mysql.ibd`라는 이름의 테이블스페이스에 저장된다.
- InnoDB 외 스토리지 엔진들을 위해 SDI(Serialized Dictionary Information) 파일을 사용한다.
  - `*.sdi` 파일 형태로 저장되며, 기존의 `*.FRM` 파일과 동일한 역할을 한다.