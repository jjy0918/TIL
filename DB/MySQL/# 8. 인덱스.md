# 8. 인덱스

## 8.1 디스크 읽기 방식

### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- HDD와 SSD는 순차 I/O에서 속도상으로 큰 차이를 보이지는 않는다.
- 하지만, 랜덤 I/O에서는 큰 차이를 보여준다.
- DMBS에서는 순차 I/O 보다는 랜덤 I/O의 비중이 더 크기 때문에 SSD를 사용하는 것이 성능상 더 좋다.

## 8.2 인덱스란?

- 인덱스를 책의 찾아보기(색인)이라고 한다면, 책의 내용은 데이터, 책의 페이지 번호는 데이터의 주소라고 할 수 있다.
- DBMS는 컬럼의 값과 해당 주소를 키와 값의 쌍(key-value) 형태로 인덱스를 만든다.
- 인덱스는 책의 색인 처럼 정렬되어 있기 때문에 빠르게 데이터를 찾을 수 있다.
- DMBS는 기본적으로 인덱스를 항상 정렬된 상태로 저장한다.(SortedList)
  - 항상 정렬되어 있기 때문에 저장 과정이 복잡하고 느리다.(INSERT, DELETE, UPDATE 처리가 느리다.)
  - 항상 정렬되어 있기 때문에 매우 빠르게 원하는 값을 찾을 수 있다.(SELECT 처리는 빠르다.)
  - 인덱스를 어떻게 설정할지에 따라 속도가 달라진다.
- 데이터는 저장된 순서대로 별도의 정렬 없이 저장된다.
- 인덱스에 사용되는 알고리즘은 `B-Tree`, `Hash` 가 대표적이고 그 외에도 `Fractal-Tree`, `Merge-Tree`가 있다.

## 8.3 B-Tree 인덱스

- B-Tree 인덱스는 인덱싱 알고리즘 중 가장 일반적이면서, 가장 먼저 도입된 알고리즘이다.
- B-Tree뿐만 아니라 변형된 형태의 `B+-Tree`, `B*-Tree`도 많이 사용된다.
- B-Tree는 원래의 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다.

### 8.3.1 구조 및 특성

- B-Tree는 최상위에 하나의 `루트 노드(Root node)`가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태다.
- 트리의 가장 하위 노드를 `리프 노트(leaf node)`라고 한다.
- 루트 노드와 리프 노트가 아닌 나머지 노드를 `브랜치 노드(Branch node)`라고 한다.
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
  - 리프 노드와 브랜치 노드들은 다음 노드의 주소를 가지고 있다.
- 인덱스는 주소 값(키)만 가지고 있기 떄문에 실제 데이터를 읽기 위해서는 데이터 파일에서 해당 레코드를 찾아야 한다.
- MyISAM과 InnoDB는 인덱스의 결과에 따라 데이터를 찾는 방법이 다르다.
  - MyISAM은 인덱스의 결과에 데이터의 물리적 주소가 저장되어 있다.
  - InnoDB는 리프노드에 PK가 들어 있고, 그 값을 바탕으로 세컨더리 인덱스를 통해 레코드를 찾는다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

#### 8.3.2.1 인덱스 키 추가

- B-Tree는 삽입 시 리프 노드가 꽉찰 경우 분리하는 과정 때문에 비용이 많이 들 수 있다.
- 일반적으로 레코드 추가 작업 비용을 1이라 가정하면, 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5로 예측한다.
  - 인덱스 추가 시 인덱스가 하나도 없다면 1, 3개가 있다면 5.5(3 \* 1.5 + 1)
- MyISAM과 MEMORY 스토리지 엔진에서는 INSERT 실행 시 즉시 새로운 키 값을 이용하여 B-Tree를 변경한다.
- InnoDB의 경우 인덱스 키가 PK나 유니크 인덱스가 아닌 경우 작업을 지연시켜 나중에 처리할 수 있다.

#### 8.3.2.2 인덱스 키 삭제

- B-Tree에서 키 값이 삭제되는 경우, 해당 키 값에 삭제 마크만 하면 작업이 완료된다.
- 삭제 마킹된 인덱스 킈 공간은 재활용된다.

#### 8.3.2.3 인덱스 키 변경

- B-Tree의 키 값이 변경돠면, 리프 노드의 위치도 변경될 수 있기 때문에 단순히 인덱스상 키 값만 변경하는 것은 불가능하다.
- 일반적으로는 해당 키 값을 삭제한 후 다시 키 값을 추가하는 형태로 처리된다.

#### 8.3.2.4 인덱스 키 검색

- B-Tree는 검색 시 루트 노드부터 리프 노드까지 이동하면서 비교 작업을 수행한다.
- B-Tree 인데스를 이용하는 것은 SELECT 뿐 아니라 UPDATE, DELETE를 처리하기 위해서도 사용된다.
- B-Tree 인덱스 검색은 100% 일치뿐만 아니라 값의 앞부분(left-most part)만 일치하는 경우나 부등호(<, >) 비교 연산에서도 사용할 수 있다.
  - 하지만, 키 뒷 부분만 검색하는 용도로는 사용할 수 없다.
- 키 값에 변형이 가해지면 인덱스 검색이 불가능해진다.
- InnoDB는 레코드 잠금이나 갭락에서 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그기 때문에 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

#### 8.3.3.1 인덱스 키 값의 크기

- InnoDB는 데이터 저장 시 기본 단위를 페이지(Page) 또는 블록(Block)이라고 부른다.
- 인덱스 역시 페이지 단위로 관리된다.
- B-Tree 인덱스의 자식 노드 개수는 페이지 크기와 키 값의 크기로 결정된다.
  - 페이지 크기가 커질수록 자식 노드의 개수가 많아지기 때문에 디스크에서 한 번에 가져오는 레코드의 수가 늘어난다.
- 인덱스를 구성하는 키 값이 커지면 디스크로부터 읽어와야 하는 횟수가 늘어난다.

#### 8.3.3.2 B-Tree 깊이

- B-Tree의 키 값은 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결된다.
- 인덱스의 크기가 커질수록 레코드 수가 작아지기 때문에 깊이는 늘어난다.
- 일반적으로 아무리 대용량의 데이터베이스라도 깊이가 5단계 이상 깊어지지는 않는다.

#### 8.3.3.3 선택도(기수성)

- 인덱스에서 선택도(Selectivity)또는 기수성(Cardinality)은 거의 같은 의미로 사용되며, 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
- 중복 인덱스가 많아지면 기수성은 낮아지고 동시에 선택도 역시 똘어진다.
- 인덱스의 선택도가 높을수록 검색 대상이 줄어들기 때문에 처리가 빠르게 된다.

#### 8.3.3.4 읽어야 하는 레코드의 건수

- 인덱스를 통해 데이터를 읽는 것은 일반적으로 그냥 레코드를 읽는 것 보다 높은 비용의 작업이다.
- 그렇기 떄문에 인덱스를 사용하는 것이 효율적인지 아닌지를 판단해야 한다.
- 일반적인 DBMS의 옵티마이저는 인덱스를 통해 읽는 것이 직접 레코드를 읽는 것 보다 4~5배 비용이 많이 드는 것으로 예측한다.
  - 즉, 인덱스를 통해 읽는 레코드는 전체 테이블의 레코드의 20~25%를 넘지 않는 것이 좋다.
  - 옵티마이저는 20~25% 이상이 되는 경우 자체적으로 전체를 읽는 방법을 사용한다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

#### 8.3.4.1 인덱스 레인지 스캔

- `인덱스 레인지 스캔`은 인덱스의 접근 방식 중 가장 대표적인 방법이며 빠르다.
- `인덱스 레인지 스캔`은 검색해야 하는 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
- `인덱스 레인지 스캔`은 찾아야 하는 범위의 리프노드 부터 순차적으로 탐색하는 것이다.
  - 그렇기 때문에 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 데이터를 가져온다.
- 탐색 순서 정리
  1.  인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.(인덱스 탐색)
  2.  1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례로 읽는다.(인덱스 스캔)
  3.  2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져와 읽는다.

#### 8.3.4.2 인덱스 풀 스캔

- `인덱스 풀 스캔`은 인덱스 레인지 스캔과 달리 처음부터 끝까지 모두 읽는 방식이다.
- `인덱스 풀 스캔`은 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 사용된다.
  - 인덱스는 (A, B, C) 컬럼 순서로 만들어져 있지만, 쿼리 조건절이 B 또는 C를 사용하는 경우
- 일반적으로 인덱스를 읽는 것이 직접 테이블을 읽는 것보다는 효율적이다.
  - 인덱스 레인지 스캔보다는 비효율적이지만, 테이블 풀 스캔보다는 효율적이다.
- 일반적으로 인덱스를 사용한다 했을 때 포함되는 것은 아니다.

#### 8.3.4.3 루스 인덱스 스캔

- 인덱스 레인지 스캔이나 인덱스 풀 스켄은 타이트(Tight) 인덱스 스캔이라 불린다.
- `루스(loose) 인덱스 스캔`은 말 그대로 느슨하게, 듬성듬성 인덱스를 읽는 것이다.
- `루스 인덱스 스캔`은 인덱스 레인지 스캔과 비슷하게 작동하지만, 중간에 필요하지 않는 인덱스 키 값은 무시하고 넘어간다.
- 일반적으로 GROUP BY 또는 MAX, MIN 등의 집합 함수를 최적화 하는 경웨 사용된다.

#### 8.3.4.4. 인덱스 스킵 스캔

- MySQL 8.0부터는 옵타마이저가 특정 컬럼을 스킵하고 검색해주는 인덱스 스킵 스캔 최적화 기능이 도입되었다.
  - 인덱스를 (gender, birth_date)로 설정하는 경우 birth_date로 조건을 설정해도 최적화가 된다.
- 루스 인덱스 스캔과 비슷하지만 인덱스 스킵 스캔은 WHERE 절에서 사용이 가능하다.
- MySQL 옵티마이저는 스킵된 값에 대하여 유니크 값을 모두 조회하여 컬럼의 조건에 추가하여 쿼리를 다시 실행한다.
  - `birth_date < '2000-01-01'`으로만 하는 경우 `gender = 'M' AND birth_date < '2000-01-01'`, `gender = 'F' AND birth_date < '2000-01-01'` 로 다시 실행된다.
- 단점으로는 선행되는 컬럼의 유니크 값 개수가 적어야 하며, 쿼리가 인덱스에 존재하는 컬럼만으로 처리가 가능해야 한다.

### 8.3.5 다중 컬럼(Multi-column) 인덱스

- 일반적인 인덱스는 1개의 컬럼만 포함하고 있다.
- 다중 컬럼 인덱스는 2개이상의 컬럼을 포함하는 인덱스로 `Concatenated Index`라고 불린다.
- 다중 컬럼 인덱스는 인덱스 설정 순서에 따라 달라진다.
  - 앞 순위 컬럼이 같은 경우에만 뒤 순서가 실행된다.
  - 앞 순서 컬럼의 우선순위가 낮다면, 뒤 순서간 우선순위가 높더라도 뒤에 존재하게 된다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스는 설정에 따라 오름차순, 내림차순으로 정렬된다.
- 인덱스를 읽는 것은 저장된 형태와 관련이 없다.
  - 인덱스가 오름차순으로 정렬되어 있더라도 뒤에서부터 읽으면 내림차순으로 탐색할 수 있다.
- 즉, 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 시릿간으로 만들어내는 실행 계획에 따라 결정된다.
- MySQL 5.7까지는 컬럼 단위로 정렬 순서를 혼합하여 인덱스를 구성할 수 없었다.
  - 컬럼 값에 -1을 곱하는 등 우회 방법을 사용해야만 했다.
- MySQL 8.0부터는 컬럼 단위 정렬 순서를 혼합하여 사용할 수 있다.
- MySQL 옵티마이저는 인덱스의 정렬 상태에 따라 정순, 역순으로 읽어서 오름차순, 내림차순을 사용하도록 실행 계획을 만들어낸다.
  - 오름차순으로 정렬되어 있을 때, 오름차순은 정순으로 읽고 내림차순은 역순으로 읽는다.
- InnoDB의 경우 정순으로 읽는 것이 역순으로 읽는 것 보다 빠르다.
  - InnoDB는 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조를 가지기 때문에 역순이 느리다.
- 인덱스의 정렬은 자주 사용되는 정렬 순서로 생성하는 것이 좋다.

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

- WHERE문을 통해 다중 인덱스를 적용한 컬럼들을 탐색하는 경우 인덱스 설정이 큰 영향을 미친다.
  - 다중 컬럼 인덱스의 경우 인덱스 설정 순서에 따라 탐색을 하기 때문에 조건에 따라 탐색 속도가 달라진다.
- 작업 범위를 결정하는 조건이 많은 경우, 최종 데이터는 작을 수 있지만, 쿼리 실행이 더 느려질 수 있다.
- 인덱스는 왼쪽 값이 중요하다.
  - 다중 인덱스의 경우 왼쪽 값(인덱스 설정이 앞순서)에 따라 인덱스가 영향이 없을 수 있다.
  - 문자열 같은 경우 `%TEST`와 같이 왼쪽 값을 알 수 없을 경우 인덱스가 영향이 없어진다.

#### 가용성과 효율성 판단

- B-Tree의 경우 아래 조건의 경우 범위 결정 조건으로 사용할 수 없다. 즉, 아래 조건의 경우 인덱스를 사용하지 못한다는 것이다.
- NOT-EQUAL
  - WHERE column <> 'N'
  - WHERE column NOT IN (10, 11, 12)
  - WHERE column IS NOT NULL
- LIKE '%??'(뒷 부분 일치 문자열 패턴)
- 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교
  - WHERE SUBSTRING(column, 1, 1) = 'X'
- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
  - WHERE column = deterministic_function()
- 데이터 타입이 서로 다른 비교
- 문자열 데이터 타입의 콜레이션이 다른 경우

- 효율적으로 인덱스를 사용할 수 있는 경우
  - 동등 비교(=, IN)
  - 크다 작다 형태(>, <)
  - LIKE로 좌측 일치 패턴

## 8.4 R-Tree 인덱스

- MySQL은 공간 인덱스(Spatail Index)라는 것을 제공한다.
  - 공간 인덱스는 R-Tree 인덱스 알고리즘을 이용하여 2차원 데이터를 인덱싱한다.
- MySQL 공간 확장을 이용하여 세 가지 기능을 사용할 수 있다.
  - 공간 데이터를 저장할 수 있는 데이터 타입
  - 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
  - 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)
- MySQL은 공간 정보의 저장 및 검색을 위해 여러 가지 기하하적 도형(Geometry) 정보를 관리할 수 있는 데이터 타입을 제공한다.
  - POINT, LINE, POLYGON, GEOMETRY 등
- R-Tree는 인덱스 정렬 시 MBR(Minimum Bounding Rectangle)이라는 크기로 전체적인 포함관계를 나누고 이를 바탕으로 인덱스를 형성하여 빠르게 탐색한다.
- R-Tree를 사용하고 싶다면 `ST_Contains()`, `ST_Within()` 함수를 사용하면 된다.

## 8.5 전문 검색 인덱스

- `전문(Full Text)` 검색에는 B-Tree과 같은 인덱스를 사용할 수 없다.
- 전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해 낸 후 사용할 수 있게 인덱스로 구축한다.
- 전문 검색 인덱스는 문서 키워드 인덱싱 기법에 따라 `단어 어근 분석`과 `n-gram 분석 알고리즘`으로 구분할 수 있다.

### 어근 분석 알고리즘

- 어근 분석 알고리즘은 `불용어(Stop Word) 처리`와 `어근 분석(Stemming)` 과정을 거쳐 색인 작업이 수행된다.
- 불용어 처리를 통해 쓸모 없는 단어를 제거한다.
- 어근 분석은 단어의 뿌리인 원형을 찾는다.

### n-gram 알고리즘

- n-gram은 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘이다.
- n-gram은 단순히 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 기법이다.

## 8.6 함수 기반 인덱스

- 일반적으로 인덱스는 컬럼의 값 일부 또는 전체에 대해서만 인덱싱한다.
- 때로는 컬럼의 값을 변형해서 인덱스를 구착해야 할 떄도 있다.
  - 이때 사용하는 것이 함수 기반 인덱스다.
  - MySQL 8.0 부터는 함수 기반 인덱스를 지원한다.

## 8.7 멀티 밸류 인덱스

## 8.8 클러스터링 인덱스

- 클러스터링 인덱스란 PK에서만 적용이 되며, PK 값이 비슷한 레코드끼리 묶어서 저장하는 것이다.
- PK가 변경되면 레코드의 물리적 위치도 변경된다.
- 클러스터링 인덱스는 클러스터링 테이블과 같은 의미를 가진다.
- 클러스터링 인덱스는 PK 기반 검색이 매우 빠르지만, 키 변경이 상대적으로 느리다.
- PK가 없는 경우 유니크 인덱스 중 첫 번째 인덱스를 클러스터링 키로 선택하거나 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가 후 선택한다.

## 8.9 유니크 인덱스

- MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.
- 유니크 인덱스에서 NULL도 저장될 수 있다.(NULL은 값이 아니기 때문에 2개 이상 저장될 수 있다.)
- 유니크 인덱스의 경우 INSERT할 때 유니크한지 체크해야하기 때문에 세컨더리 인덱스보다 느리다.
- 성능을 위해 불필요하게 유니크 인덱스를 생성하는 것은 좋은 방법이 아니다.
- 불필요하게 유니크 인덱스와 일반 세컨더리 인덱스나 PK를 중복해서 설정하는 것은 좋지 않다.

## 8.10 외래키

- 외래키 설정 시 연관된 테이블의 컬럼에 인덱스가 설정된다.
