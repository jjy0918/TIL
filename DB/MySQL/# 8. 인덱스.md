# 8. 인덱스

## 8.1 디스크 읽기 방식

### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- HDD와 SSD는 순차 I/O에서 속도상으로 큰 차이를 보이지는 않는다.
- 하지만, 랜덤 I/O에서는 큰 차이를 보여준다.
- DMBS에서는 순차 I/O 보다는 랜덤 I/O의 비중이 더 크기 때문에 SSD를 사용하는 것이 성능상 더 좋다.

## 8.2 인덱스란?

- 인덱스를 책의 찾아보기(색인)이라고 한다면, 책의 내용은 데이터, 책의 페이지 번호는 데이터의 주소라고 할 수 있다.
- DBMS는 컬럼의 값과 해당 주소를 키와 값의 쌍(key-value) 형태로 인덱스를 만든다.
- 인덱스는 책의 색인 처럼 정렬되어 있기 때문에 빠르게 데이터를 찾을 수 있다.
- DMBS는 기본적으로 인덱스를 항상 정렬된 상태로 저장한다.(SortedList)
  - 항상 정렬되어 있기 때문에 저장 과정이 복잡하고 느리다.(INSERT, DELETE, UPDATE 처리가 느리다.)
  - 항상 정렬되어 있기 때문에 매우 빠르게 원하는 값을 찾을 수 있다.(SELECT 처리는 빠르다.)
  - 인덱스를 어떻게 설정할지에 따라 속도가 달라진다.
- 데이터는 저장된 순서대로 별도의 정렬 없이 저장된다.
- 인덱스에 사용되는 알고리즘은 `B-Tree`, `Hash` 가 대표적이고 그 외에도 `Fractal-Tree`, `Merge-Tree`가 있다.

## 8.3 B-Tree 인덱스

- B-Tree 인덱스는 인덱싱 알고리즘 중 가장 일반적이면서, 가장 먼저 도입된 알고리즘이다.
- B-Tree뿐만 아니라 변형된 형태의 `B+-Tree`, `B*-Tree`도 많이 사용된다.
- B-Tree는 원래의 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다.

### 8.3.1 구조 및 특성

- B-Tree는 최상위에 하나의 `루트 노드(Root node)`가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태다.
- 트리의 가장 하위 노드를 `리프 노트(leaf node)`라고 한다.
- 루트 노드와 리프 노트가 아닌 나머지 노드를 `브랜치 노드(Branch node)`라고 한다.
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
  - 리프 노드와 브랜치 노드들은 다음 노드의 주소를 가지고 있다.
- 인덱스는 주소 값(키)만 가지고 있기 떄문에 실제 데이터를 읽기 위해서는 데이터 파일에서 해당 레코드를 찾아야 한다.
- MyISAM과 InnoDB는 인덱스의 결과에 따라 데이터를 찾는 방법이 다르다.
  - MyISAM은 인덱스의 결과에 데이터의 물리적 주소가 저장되어 있다.
  - InnoDB는 리프노드에 PK가 들어 있고, 그 값을 바탕으로 세컨더리 인덱스를 통해 레코드를 찾는다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

#### 8.3.2.1 인덱스 키 추가

- B-Tree는 삽입 시 리프 노드가 꽉찰 경우 분리하는 과정 때문에 비용이 많이 들 수 있다.
- 일반적으로 레코드 추가 작업 비용을 1이라 가정하면, 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5로 예측한다.
  - 인덱스 추가 시 인덱스가 하나도 없다면 1, 3개가 있다면 5.5(3 * 1.5 + 1)
- MyISAM과 MEMORY 스토리지 엔진에서는 INSERT 실행 시 즉시 새로운 키 값을 이용하여 B-Tree를 변경한다.
- InnoDB의 경우 인덱스 키가 PK나 유니크 인덱스가 아닌 경우 작업을 지연시켜 나중에 처리할 수 있다.

#### 8.3.2.2 인덱스 키 삭제

- B-Tree에서 키 값이 삭제되는 경우, 해당 키 값에 삭제 마크만 하면 작업이 완료된다.
- 삭제 마킹된 인덱스 킈 공간은 재활용된다.

#### 8.3.2.3 인덱스 키 변경

- B-Tree의 키 값이 변경돠면, 리프 노드의 위치도 변경될 수 있기 때문에 단순히 인덱스상 키 값만 변경하는 것은 불가능하다.
- 일반적으로는 해당 키 값을 삭제한 후 다시 키 값을 추가하는 형태로 처리된다.

#### 8.3.2.4 인덱스 키 검색

- B-Tree는 검색 시 루트 노드부터 리프 노드까지 이동하면서 비교 작업을 수행한다.
- B-Tree 인데스를 이용하는 것은 SELECT 뿐 아니라 UPDATE, DELETE를 처리하기 위해서도 사용된다.
- B-Tree 인덱스 검색은 100% 일치뿐만 아니라 값의 앞부분(left-most part)만 일치하는 경우나 부등호(<, >) 비교 연산에서도 사용할 수 있다.
  - 하지만, 키 뒷 부분만 검색하는 용도로는 사용할 수 없다.
- 키 값에 변형이 가해지면 인덱스 검색이 불가능해진다.
- InnoDB는 레코드 잠금이나 갭락에서 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그기 때문에 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

#### 8.3.3.1 인덱스 키 값의 크기

- InnoDB는 데이터 저장 시 기본 단위를 페이지(Page) 또는 블록(Block)이라고 부른다.
- 인덱스 역시 페이지 단위로 관리된다.
- B-Tree 인덱스의 자식 노드 개수는 페이지 크기와 키 값의 크기로 결정된다.
  - 페이지 크기가 커질수록 자식 노드의 개수가 많아지기 때문에 디스크에서 한 번에 가져오는 레코드의 수가 늘어난다.
- 인덱스를 구성하는 키 값이 커지면 디스크로부터 읽어와야 하는 횟수가 늘어난다.

#### 8.3.3.2 B-Tree 깊이

- B-Tree의 키 값은 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결된다.
- 인덱스의 크기가 커질수록 레코드 수가 작아지기 때문에 깊이는 늘어난다.
- 일반적으로 아무리 대용량의 데이터베이스라도 깊이가 5단계 이상 깊어지지는 않는다.

#### 8.3.3.3 선택도(기수성)

- 인덱스에서 선택도(Selectivity)또는 기수성(Cardinality)은 거의 같은 의미로 사용되며, 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
- 중복 인덱스가 많아지면 기수성은 낮아지고 동시에 선택도 역시 똘어진다.
- 인덱스의 선택도가 높을수록 검색 대상이 줄어들기 때문에 처리가 빠르게 된다.

#### 8.3.3.4 읽어야 하는 레코드의 건수

- 인덱스를 통해 데이터를 읽는 것은 일반적으로 그냥 레코드를 읽는 것 보다 높은 비용의 작업이다.
- 그렇기 떄문에 인덱스를 사용하는 것이 효율적인지 아닌지를 판단해야 한다.
- 일반적인 DBMS의 옵티마이저는 인덱스를 통해 읽는 것이 직접 레코드를 읽는 것 보다 4~5배 비용이 많이 드는 것으로 예측한다.
  - 즉, 인덱스를 통해 읽는 레코드는 전체 테이블의 레코드의 20~25%를 넘지 않는 것이 좋다.
  - 옵티마이저는 20~25% 이상이 되는 경우 자체적으로 전체를 읽는 방법을 사용한다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

#### 8.3.4.1 인덱스 레인지 스캔

- `인덱스 레인지 스캔`은 인덱스의 접근 방식 중 가장 대표적인 방법이며 빠르다.
- `인덱스 레인지 스캔`은 검색해야 하는 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
- `인덱스 레인지 스캔`은 찾아야 하는 범위의 리프노드 부터 순차적으로 탐색하는 것이다.
  - 그렇기 때문에 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 데이터를 가져온다.
- 탐색 순서 정리
   1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.(인덱스 탐색)
   2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례로 읽는다.(인덱스 스캔)
   3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져와 읽는다.

#### 8.3.4.2 인덱스 풀 스캔

- `인덱스 풀 스캔`은 인덱스 레인지 스캔과 달리 처음부터 끝까지 모두 읽는 방식이다.
- `인덱스 풀 스캔`은 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 사용된다.
  - 인덱스는 (A, B, C) 컬럼 순서로 만들어져 있지만, 쿼리 조건절이 B 또는 C를 사용하는 경우
- 일반적으로 인덱스를 읽는 것이 직접 테이블을 읽는 것보다는 효율적이다.
  - 인덱스 레인지 스캔보다는 비효율적이지만, 테이블 풀 스캔보다는 효율적이다.
- 일반적으로 인덱스를 사용한다 했을 때 포함되는 것은 아니다.

#### 8.3.4.3 루스 인덱스 스캔

- 인덱스 레인지 스캔이나 인덱스 풀 스켄은 타이트(Tight) 인덱스 스캔이라 불린다.
- `루스(loose) 인덱스 스캔`은 말 그대로 느슨하게, 듬성듬성 인덱스를 읽는 것이다.
- `루스 인덱스 스캔`은 인덱스 레인지 스캔과 비슷하게 작동하지만, 중간에 필요하지 않는 인덱스 키 값은 무시하고 넘어간다.
- 일반적으로 GROUP BY 또는 MAX, MIN 등의 집합 함수를 최적화 하는 경웨 사용된다.

#### 8.3.4.4. 인덱스 스킵 스캔

- MySQL 8.0부터는 옵타마이저가 특정 컬럼을 스킵하고 검색해주는 인덱스 스킵 스캔 최적화 기능이 도입되었다.
  - 인덱스를 (gender, birth_date)로 설정하는 경우 birth_date로 조건을 설정해도 최적화가 된다.
- 루스 인덱스 스캔과 비슷하지만 인덱스 스킵 스캔은 WHERE 절에서 사용이 가능하다.
- MySQL 옵티마이저는 스킵된 값에 대하여 유니크 값을 모두 조회하여 컬럼의 조건에 추가하여 쿼리를 다시 실행한다.
  - `birth_date < '2000-01-01'`으로만 하는 경우 `gender = 'M' AND birth_date < '2000-01-01'`, `gender = 'F' AND birth_date < '2000-01-01'` 로 다시 실행된다.
- 단점으로는 선행되는 컬럼의 유니크 값 개수가 적어야 하며, 쿼리가 인덱스에 존재하는 컬럼만으로 처리가 가능해야 한다.