# 9. 옵티마이저와 힌트

## 9.1 개요

- MySQL의 옵티마이저는 쿼리 최적화를 위해 테이블의 데이터 분포 등의 통계 데이터를 참조하여 계획을 세운다.
- `EXPLAIN` 명령으로 쿼리 실행 계획을 확인할 수 있다.
- 옵티마이저가 만들어 내는 실행 계획을 이해할 수 있어야 실행 계획의 불합리한 부분을 찾아내고, 더 최적화된 방법으로 수립할 수 있다.

### 9.1.1 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
   - MySQL이 이해할 수 있는 수준으로 분리하는 것을 SQL 파싱이라고 한다.
   - SQL 파싱은 MySQL 서버의 SQL 파서 모듈로 처리된다.
   - SQL 문장이 잘못된 경우 이 단계에서 걸러진다.
   - 이 단계에서 분리된 것을 SQL 파스 트리라고 한다.
2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
   - SQL 파스 트리를 참조하여 여러 작업을 진행한다.
   - 불필요한 조건 제거 및 복잡한 연산의 단순화
   - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
   - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
   - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
   - 두 번째 단계를 거쳐서 `실행 계획`이 수립된다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
   - 실행 계획을 바탕으로 스토리지 엔진에 레코드를 읽어오도록 요청한다.
   - MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.

- 1, 2번 단계에서는 MySQL 엔진에서 처리한다.
- 3번 단계에서는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리한다.

### 9.1.2 옵티마이저의 종류

- 옵타마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 한다.
- 옵티마이저는 DBMS가 선택하고 있는 비용 기반 최적화(Cost-based optimizer, CBO) 방법과 예전에 사용하던 규칙 기반 최적화화 방법(Rule-based optimizer, RBO)으로 나뉜다.
- `비용 기반 최적화`는 여러 가능한 방법을 만들고 통계 정보를 이용해 방법들 중 비용이 최소인 실행 계획을 선택하는 것이다.
- `규칙 기반 최적화`는 옵티마이저의 내장된 우선순위에 따라 실행 계획을 수립하는 방법이다.(요즘에는 거의 사용되지 않는다.)

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽는 방식이다.
- MySQL은 특정 조건이 일치할 때 풀 테이블 스캔을 선택한다.
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 읽는 것 보다 빠른 경우(테이블 페이지가 1개로 구성된 경우)
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- 풀 테이블 스캔 시 MyISAM 스토리지 엔진은 한 번에 1개의 테이블만 가져오지만, InnoDB는 연속된 데이터 페이지가 읽히면 백그라운드에서 계속 가져온다(리드 어헤드).
  - 어느 순간부터는 백그라운드 스레드가 가져오기 때문에 한 번에 4개, 8개씩 읽으면서 계속 그 수를 증가시킨다.
  - 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둔다.
  - 리드 어헤드를 시작할지 임계값은 innodb_read_ahead_threshold 시스템 변수를 통해 설정할 수 있다.
- 리드 어헤드는 풀 테이블 스캔뿐 아니라 풀 인덱스 스캔에서도 사용된다.

### 9.2.2 병렬 처리

- MySQL 8.0 부터는 병렬 쿼리가 가능해졌다.
- innodb_parallel_read_threads 시스템 변수를 통해 하나의 쿼리를 최대 몇 개의 스레드를 이용해 처리할지 변경할 수 있다.
- 병렬 처리는 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 가능하다.
- 병렬 처리용 스레드 개수를 아무리 늘리더라도 CPU의 코어 개수를 넘어서는 경우 오히려 성능이 떨어질 수 있으니 주의해야 한다.

### 9.2.3 ORDER BY 처리(Using filesort)

- 정렬을 하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법이 있다.
- 인덱스를 이용할 경우 이미 정렬되어 있기 때문에 매우 빠르지만, INSERT, UPDATE, DELETE 작업 시 인덱스 추가/삭제 때문에 느리다.
- Filesort 이용 시 인덱스 생성이 필요 없기 떄문에 INSERT, UPDATE, DELETE 작업 시 빠르지만 정렬이 쿼리 실행 시 이루어지기 때문에 대상 건수가 많아지면 쿼리 응답 속도가 느리다.
- MySQL에서는 실행 계획의 Extra 컬럼의 `Using filesort` 메시지를 통해 별도의 정렬 처리를 했는지 판단할 수 있다.

#### 9.2.3.1 소트 버퍼

- MySQL은 정렬을 위해 소트 버퍼(sort buffer) 라는 별도의 메모리 공간을 할당 받아서 사용한다.
  - 소트 버퍼는 정렬이 필요한 경우에만 할당된다.
  - 소트 버퍼 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 크기는 sort_buffer_size 라는 시스템 변수로 설정할 수 있다.
  - 소트 버퍼을 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.
- 정렬해야 할 레코드가 소트 버퍼에 모두 담을 수 없다면 디스크를 사용하여 임시 저장을 한다.
  - 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록한다.
  - 이러한 작업들은 디스크 쓰기와 읽기를 유발한다.
- 소트 버퍼 크기를 늘린다고 해서 엄청난 개선이 있지는 않는다.
  - 소트 버퍼는 커넥션 당 할당되기 떄문에 정렬 작업이 많으면 많을수록 소트 버퍼로 소비되는 메모리 고ㅓㅇ간이 커진다.

#### 9.2.3.2 정렬 알고리즘

- 레코드 정렬 시 레코드 전체를 소트 버퍼에 담는 `싱글 패스` 방식과 기준 컬러만 소트 버퍼에 담는 `투 패스` 방식이 있다.
  - 옵티마이저 트레이스 기능으로 어떤 정렬 모드를 사용하는지 확인할 수 있다.
- 투 패스 방식은 싱글 패스 방식이 도입되기 전 사용되던 방식으로 현재는 대부분 싱글 패스 방식을 사용한다.
  - MySQL 8.0에서는 특정 조건에서만 투 패스 방식을 사용한다.
    - 레코드이 크기가 max_lengtrh_for_sort_data 시스템 변수에 설정된 값보다 클 때
    - BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함할 때
- 투 패스 방식은 정렬 기준 컬럼을 조회한 후 전체 레코드를 가져오기 때문에 두 번 조회하기 떄문에 불합리하다.
- 싱글 패스는 모든 데이터를 소트 버퍼에 담아야 하기 때문에 더 많은 소트 버퍼 공간이 필요하다.
- SELECT 쿼리에서 모든 컬럼(\*)을 가져오는 것 보다 필요한 컬럼만 가져오는 것이 효율적인 이유도 소트 버퍼와 관련 있다.

#### 9.2.3.3 정렬 처리 방법

- 쿼리에서 `ORDER BY` 가 사용되면 다음 3가지 처리 방법 중 하나로 정렬이 처리된다.
  - 인덱스를 사용하는 방법: Extra 컬럼에 별도 표기가 되지 않는다.
  - 조인에서 드라이빙 테이블만 정렬: Extra 컬럼에 Using filesort가 표시된다.
  - 조인에서 조인 결과를 임시 테이블로 저장 후 정렬: Extra 컬럼에 Using temporary; Using filesort 가 표시된다.
- MySQL 옵타이마이저는 정렬 대상 레코드를 최소화하기 위해 두 가지 방법을 사용한다.
  - 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
  - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬
- 인덱스를 이용한 정렬
  - 반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
  - WHERE 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
- 조인의 드라이빙 테이블만 정렬
  - 조인이 실행되기 전 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것.
  - 첫 번째 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 ORDER BY 절이 작성되어야 한다.
- 임시 테이블을 이용한 정렬
  - 인덱스 사용이 불가능하고 드라이빙 테이블로 정렬이 불가능한 경우.
  - 전체 조회 후 정렬되기 때문에 가장 느리다.

##### 9.2.3.4 정렬 처리 방법의 성능 비교

- 일반적으로 LIMIT은 테이블 처리 일부만 가져오기 때문에 작업량을 줄이는 역할을 한다.
- ORDER BY나 GROUP BY 같은 경우 WHERE 조건에 맞ㄴ족하는 LIMIT 건수를 가져와야 하기 때문에 쿼리가 느려질 수 있다.
- 스트리밍 방식
  - 쿼리기 실행되면서 검색될 때마다 바로바로 전달해주는 방식.
  - 레코드를 찾는 즉시 전달받기 떄문에 동시에 데이터의 가공 작업을 시작할 수 있다.
- 버퍼링 방식
  - ORDER BY나 GROUP BY 같은 처리는 스트리밍되는 것이 불가능하다.
  - 클라이언트는 MySQL이 처리하는 동안 기다려야 하기 때문에 응답 속도가 느려진다.
- JDBC는 기본적으로 스트리밍 방식이라고 하더라도 내부 버퍼에 담아둔 후 마지막 레코드가 들어왔을 때 전달한다.
  - 즉, JDBC는 기본적으로 버퍼링 방식을 자체적으로 제공한다.
  - 대량의 데이터를 가져와야 할 때는 스트리밍 방식으로 변경하여 사용하면 된다.

### 9.2.4 GROUP BY 처리

- GROUP BY 절이 있는 쿼리에서는 HAVING 절을 사용할 수 있는데, GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없기 때문에 HAVING 절을 튜닝하기 위해 인덱스를 생성할 필요는 없다.

#### 9.2.4.1 인덱스 스캔을 이용한 GROUP BY(타이트 인덱스 스캔)

- ORDER BY 처럼 조인의 드라이빙 테이블에 속한 컬럼만 이용해 그루핑할 때 GROUP BY 컬럼으로 인덱스가 있다면 인덱스를 읽으면서 그루핑 작업을 수행한다.
- 그룹 함수 등의 그룹값을 처리하기 위해 임시 테이블이 필요할 때도 있다.,
- GROUP BY 가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것이기 때문에 쿼리 실행 시점에 추가적인 정렬 작업이나 임시 테이블이 필요하지는 않다.
  - 이러한 방식은 Extra 컬럼에 Using index for group-by 나 Using tempoaray, Using folesort 가 표시되지 않는다.

#### 9.2.4.2 루스 인덱스 스캔을 이용한 GROUP BY

- 루스(Loose) 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미한다.
- 루스 인덱스 스캔을 사용할 때는 Extra 컬럼에 Using index for group-by 코멘트가 표시된다.
- MySQL 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에 서만 사용할 수 있다.
- 프리픽스 인덱스(Prefix index, 컬럼 앞 일부만으로 생성된 인덱스)는 루스 인덱스 스캔을 사용할 수 없다.
- 루스 인덱스 스캔에서는 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다.
  - 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만들어낸다.
- 루스 인덱스 스캔으로 처리되는 쿼리에서는 별도의 임시 테이블이 필요하지 않다.

#### 9.2.4.3 임시 테이블을 사용하는 GROUP BY

- GROUP BY의 기준 컬럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때 이 방식으로 처리된다.
- MySQL 5.7 까지는 GROUP BY 사용 시 자동으로 그루핑 컬럼 기준으로 정렬을 수행했다.
- MySQL 8.0 부터는 GROUP BY 기준으로 자동 정렬이 되지 않는다.

### 9.2.5 DISTINCT 처리

- DISTINCT가 사용되는 쿼리 실행 계획에서는 인덱스를 사용하지 못해 항상 임시 테이블이 필요하다.
  - 실행 계획에서는 Extra 컬럼에 `Using temporary` 메시지가 출력되지는 않는다.

#### 9.2.5.1 SELECT DISTINCT

- SELECT 할 때 DISTINCT 를 사용하면 GROUP BY와 동일한 방식으로 처리된다.
- DISTINCT는 특정 컬럼만 유니크하게 조회하는 것이 아니라, 레코드를 유니크하게 SELECT 한다.
  - `SEELCT DISTINCT first_name, last_name FROM employees;` 의 경우 first_name, last_name 조합의 유니크한 레코드를 SELECT 한다.
  - 괄호로 묶어도 MySQL이 풀고 처리한다.

#### 9.2.5.2 집합 함수와 함께 사용된 DISTINCT

- COUNT(), MAX(), MIN() 과 같은 집합 함수 내에서 DISTINCT 키워드가 사용될 수 있고, 이 경우 SELECT DISTINCT화 다르게 해석된다.
- 집합 함수와 함께 사용할 경우 해당 컬럼의 조합이 유니크한 것들만 가져온다.
  - SELECT COUNT(DISTINCT s.salary) FROM employees e, salaries s
- 이 경우 임시 테이블을 사용하지만, 실행 계획에서는 표현되지 않는다.
- `인덱스된 컬럼`에 대해서는 인덱스 풀 스캔이나 레인지 스캔하기 때문에 `임시 테이블 없이` 최적화가 된다.

### 9.2.6 내부 임시 테이블 사용

- MySQL이 사용하는 내부 임시 테이블은 처음 메모리에 생성한 후 크기가 커지면 디스크로 옮겨진다.
- 임시 테이블은 다른 세션이나 다른 쿼리에서 볼 수 없으며, 사용도 불가능하다.
- 내부 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제된다.
- 사용자가 직접 선언하는 임시 테이블(CREATE TEMPORARY TABLE) 과는 다르다.

#### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블

- MySQL 8.0 전에는 임시 테이블이 메모리 사용 시 MEMORY 스토리지 엔진을 사용하고, 디스크에 저장될 시에는 MyISAM 스토리지 엔진을 사용했다.
  - MEMORY 스토리지 엔진은 가변 길이 타입을 지원하지 않는다.
  - MyISAM 스토리지 엔진은 트랜잭션 지원이 안된다.
- MySQL 8.0 부터는 메모리 사용 시 TempTable 스토리지 엔진을, 디스크 사용 시 InnoDB 스토리지 엔진을 사용한다.
- TempTable의 최대 크기는 `temptable_max_ram` 시스템 변수를 통해 설정할 수 있다.
  - 이 값 보다 크기가 커지면 디스크를 사용하게 된다.

#### 9.2.6.2 임시 테이블이 필요한 쿼리

- ORDER BY와 GROUP BY에 명시된 컬럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 컬럼이 UNION RESULT인 경우)
- 쿼리의 실행 계획에서 select_type이 DERIVERD인 쿼리

#### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우

- UNION이나 UNION ALL에서 SELECT 되는 컬럼 중 길이가 512 바이트 이상인 크기의 컬럼이 있는 경우
- GROUP BY나 DISTINCT 커럼에서 512 바이트 이상인 크기의 컬럼이 있는 경우
- 메모리 임시 테이블의 크기가 tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나 temptable_max_ram 시스템 변수보다 값이 큰 경우

## 9.3 고급 최적화

- 옵티마이저는 실행 계획 수립 시 통계 정보와 옵티마이저 옵션을 결합한다.
- 옵티마이저 옵션은 조인 관련된 옵티마이저 옵션과 옵티마이저 스위치로 구분할 수 있다.

### 9.3.1 옵티마이저 스위치 옵션

- 옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 이용해서 제어한다.
- `optimizer_switch` 시스템 변수에는 여러 개의 옵션을 세트로 묶어서 설정하는 방식을 사용한다.

- SQL에서 AND 로 연결된 경우 둘 중 하나라도 인덱스 사용 가능 시 인덱스 레인지 스캔으로 쿼리가 실행된다.
- SQL에서 OR 로 연결된 경우 둘 중 하나라도 인덱스를 사용하지 못하면 항상 풀 테이블 스캔으로 처리된다.

### 세미 조인 최적화

- 다른 테이블과 실제 조인은 하지 않지만, 다른 테이블에서 조건에 일치하는 레코드가 있는지 체크하는 형태의 쿼리를 세미조인이라 한다.
- MySQL 5.7 까지는 세미 조인 최적화 기능이 없어서 비효율적이다.
  - 서브쿼리를 먼저 조회하는 것이 아니라, 드라이빙 테이블을 조회 한 후 서브쿼리의 조건에 일치하는지 판단한다.
- 세미 조인 형태(` = (subquery)`, `IN (subquery)`)의 최적화 방법
  - 세미 조인 최적화
  - IN-to-EXISTS 최적화
  - MATERIALIZATION 최적화
  - Table Pull-out(MySQL 8.0 도입)
  - Duplication Weed-out
  - First Match
  - Loose Scan
- 안티 세미 조인 형태(`<> (subquery)`, `NOT IN (subquery)`) 최적화
  - IN-to-EXISTS 최적화
  - MATERIALIZATION 최적화

#### 테이블 풀-아웃(Table Pull-out)

- Table Pull-out 최적화는 세미 조인의 서브 쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후 조인 쿼리 형태로 변경한다.
  - 서브 쿼리 최적화가 도입되기 전 수동으로 튜닝하던 대표적인 방법이다.
- Table pull-out 최적화가 사용되었는지는 실행 계획에서는 확인이 불가능하고, EXPLAIN 명령어 실행 후 SHOW WARNIGS 명령어를 통해 살펴보아야한다.
- Table pull-out 최적화는 세미 조인 서브쿼리에서만 사용 가능하다.
- Table pull-out 최적화는 서브쿼리 부분이 UNIQUE 인덱스나 PK 룩업으로 결과가 1건인 경우에만 사용 가능하다.
- Table pull-out이 적용된다고 하더라도 기존 쿼리에서 가능했던 최적화 방법을 적용할 수 있기 때문에 MySQL은 최대한 많이 사용한다.
- 서브 쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면 서브 쿼리 자체는 없어진다.
- Table pull-out 최적화에 의해서 굳이 서브 쿼리를 조인으로 풀어낼 필요가 없어진다.

#### 퍼스트 매치(FirstMatch)

- FirstMatch 전략은 `IN (subquey)` 형태의 세미 조인을 `EXISTS(subquery)` 형태로 튜닝한 것과 비슷하다.
- 실제로 EXISTS 형태로 쿼리를 재작성하는 것은 아니고, 서브쿼리를 조인으로 풀어서 실행하면서 일치하는 첫 번째 레코드만 검색하는 최적화를 한다.
- 기존의 IN-to-EXISTS 변환과 비슷하지만 장점이 더 있다.
  - 옵티마이저가 원래 쿼리에 없던 동등 조건을 추가하는 최적화 실행 시 아우터 쿼리까지 전파시켜 더 나은 실행 계획을 수립할 수 있게 한다.
  - 서브쿼리의 모든 테이블에 대해 최적화 수행을 취사선택할 수 있다.
- FirstMatch는 서브쿼리에서 하나의 레코드만 검색되면 멈추기 때문에 참조하는 모든 아우터 테이블이 먼저 조회된 이후 실행된다.
- FirstMatch는 상관 서브쿼리(Correlated subquery)에서도 사용될 수 있다.
- FirstMatch는 GROUP BY나 집합 함수가 사용된 서브쿼리의 최적화에는 사용될 수 없다.

#### 루스 스캔(loose scan)
