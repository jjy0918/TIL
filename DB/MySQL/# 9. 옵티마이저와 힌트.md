# 9. 옵티마이저와 힌트

## 9.1 개요

- MySQL의 옵티마이저는 쿼리 최적화를 위해 테이블의 데이터 분포 등의 통계 데이터를 참조하여 계획을 세운다.
- `EXPLAIN` 명령으로 쿼리 실행 계획을 확인할 수 있다.
- 옵티마이저가 만들어 내는 실행 계획을 이해할 수 있어야 실행 계획의 불합리한 부분을 찾아내고, 더 최적화된 방법으로 수립할 수 있다.

### 9.1.1 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
   - MySQL이 이해할 수 있는 수준으로 분리하는 것을 SQL 파싱이라고 한다.
   - SQL 파싱은 MySQL 서버의 SQL 파서 모듈로 처리된다.
   - SQL 문장이 잘못된 경우 이 단계에서 걸러진다.
   - 이 단계에서 분리된 것을 SQL 파스 트리라고 한다.
2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
   - SQL 파스 트리를 참조하여 여러 작업을 진행한다.
   - 불필요한 조건 제거 및 복잡한 연산의 단순화
   - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
   - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
   - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
   - 두 번째 단계를 거쳐서 `실행 계획`이 수립된다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
   - 실행 계획을 바탕으로 스토리지 엔진에 레코드를 읽어오도록 요청한다.
   - MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.

- 1, 2번 단계에서는 MySQL 엔진에서 처리한다.
- 3번 단계에서는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리한다.

### 9.1.2 옵티마이저의 종류

- 옵타마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 한다.
- 옵티마이저는 DBMS가 선택하고 있는 비용 기반 최적화(Cost-based optimizer, CBO) 방법과 예전에 사용하던 규칙 기반 최적화화 방법(Rule-based optimizer, RBO)으로 나뉜다.
- `비용 기반 최적화`는 여러 가능한 방법을 만들고 통계 정보를 이용해 방법들 중 비용이 최소인 실행 계획을 선택하는 것이다.
- `규칙 기반 최적화`는 옵티마이저의 내장된 우선순위에 따라 실행 계획을 수립하는 방법이다.(요즘에는 거의 사용되지 않는다.)

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽는 방식이다.
- MySQL은 특정 조건이 일치할 때 풀 테이블 스캔을 선택한다.
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 읽는 것 보다 빠른 경우(테이블 페이지가 1개로 구성된 경우)
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- 풀 테이블 스캔 시 MyISAM 스토리지 엔진은 한 번에 1개의 테이블만 가져오지만, InnoDB는 연속된 데이터 페이지가 읽히면 백그라운드에서 계속 가져온다(리드 어헤드).
  - 어느 순간부터는 백그라운드 스레드가 가져오기 때문에 한 번에 4개, 8개씩 읽으면서 계속 그 수를 증가시킨다.
  - 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둔다.
  - 리드 어헤드를 시작할지 임계값은 innodb_read_ahead_threshold 시스템 변수를 통해 설정할 수 있다.
- 리드 어헤드는 풀 테이블 스캔뿐 아니라 풀 인덱스 스캔에서도 사용된다.

### 9.2.2 병렬 처리

- MySQL 8.0 부터는 병렬 쿼리가 가능해졌다.
- innodb_parallel_read_threads 시스템 변수를 통해 하나의 쿼리를 최대 몇 개의 스레드를 이용해 처리할지 변경할 수 있다.
- 병렬 처리는 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 가능하다.
- 병렬 처리용 스레드 개수를 아무리 늘리더라도 CPU의 코어 개수를 넘어서는 경우 오히려 성능이 떨어질 수 있으니 주의해야 한다.

### 9.2.3 ORDER BY 처리(Using filesort)

- 정렬을 하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법이 있다.
- 인덱스를 이용할 경우 이미 정렬되어 있기 때문에 매우 빠르지만, INSERT, UPDATE, DELETE 작업 시 인덱스 추가/삭제 때문에 느리다.
- Filesort 이용 시 인덱스 생성이 필요 없기 떄문에 INSERT, UPDATE, DELETE 작업 시 빠르지만 정렬이 쿼리 실행 시 이루어지기 때문에 대상 건수가 많아지면 쿼리 응답 속도가 느리다.
- MySQL에서는 실행 계획의 Extra 컬럼의 `Using filesort` 메시지를 통해 별도의 정렬 처리를 했는지 판단할 수 있다.

#### 9.2.3.1 소트 버퍼

- MySQL은 정렬을 위해 소트 버퍼(sort buffer) 라는 별도의 메모리 공간을 할당 받아서 사용한다.
  - 소트 버퍼는 정렬이 필요한 경우에만 할당된다.
  - 소트 버퍼 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 크기는 sort_buffer_size 라는 시스템 변수로 설정할 수 있다.
  - 소트 버퍼을 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.
- 정렬해야 할 레코드가 소트 버퍼에 모두 담을 수 없다면 디스크를 사용하여 임시 저장을 한다.
  - 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록한다.
  - 이러한 작업들은 디스크 쓰기와 읽기를 유발한다.
- 소트 버퍼 크기를 늘린다고 해서 엄청난 개선이 있지는 않는다.
  - 소트 버퍼는 커넥션 당 할당되기 떄문에 정렬 작업이 많으면 많을수록 소트 버퍼로 소비되는 메모리 고ㅓㅇ간이 커진다.

#### 9.2.3.2 정렬 알고리즘

- 레코드 정렬 시 레코드 전체를 소트 버퍼에 담는 `싱글 패스` 방식과 기준 컬러만 소트 버퍼에 담는 `투 패스` 방식이 있다.
  - 옵티마이저 트레이스 기능으로 어떤 정렬 모드를 사용하는지 확인할 수 있다.
- 투 패스 방식은 싱글 패스 방식이 도입되기 전 사용되던 방식으로 현재는 대부분 싱글 패스 방식을 사용한다.
  - MySQL 8.0에서는 특정 조건에서만 투 패스 방식을 사용한다.
    - 레코드이 크기가 max_lengtrh_for_sort_data 시스템 변수에 설정된 값보다 클 때
    - BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함할 때
- 투 패스 방식은 정렬 기준 컬럼을 조회한 후 전체 레코드를 가져오기 때문에 두 번 조회하기 떄문에 불합리하다.
- 싱글 패스는 모든 데이터를 소트 버퍼에 담아야 하기 때문에 더 많은 소트 버퍼 공간이 필요하다.
- SELECT 쿼리에서 모든 컬럼(\*)을 가져오는 것 보다 필요한 컬럼만 가져오는 것이 효율적인 이유도 소트 버퍼와 관련 있다.

#### 9.2.3.3 정렬 처리 방법

- 쿼리에서 `ORDER BY` 가 사용되면 다음 3가지 처리 방법 중 하나로 정렬이 처리된다.
  - 인덱스를 사용하는 방법: Extra 컬럼에 별도 표기가 되지 않는다.
  - 조인에서 드라이빙 테이블만 정렬: Extra 컬럼에 Using filesort가 표시된다.
  - 조인에서 조인 결과를 임시 테이블로 저장 후 정렬: Extra 컬럼에 Using temporary; Using filesort 가 표시된다.
- MySQL 옵타이마이저는 정렬 대상 레코드를 최소화하기 위해 두 가지 방법을 사용한다.
  - 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
  - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬
- 인덱스를 이용한 정렬
  - 반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
  - WHERE 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
- 조인의 드라이빙 테이블만 정렬
  - 조인이 실행되기 전 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것.
  - 첫 번째 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 ORDER BY 절이 작성되어야 한다.
- 임시 테이블을 이용한 정렬
  - 인덱스 사용이 불가능하고 드라이빙 테이블로 정렬이 불가능한 경우.
  - 전체 조회 후 정렬되기 때문에 가장 느리다.

##### 9.2.3.4 정렬 처리 방법의 성능 비교

- 일반적으로 LIMIT은 테이블 처리 일부만 가져오기 때문에 작업량을 줄이는 역할을 한다.
- ORDER BY나 GROUP BY 같은 경우 WHERE 조건에 맞ㄴ족하는 LIMIT 건수를 가져와야 하기 때문에 쿼리가 느려질 수 있다.
- 스트리밍 방식
  - 쿼리기 실행되면서 검색될 때마다 바로바로 전달해주는 방식.
  - 레코드를 찾는 즉시 전달받기 떄문에 동시에 데이터의 가공 작업을 시작할 수 있다.
- 버퍼링 방식
  - ORDER BY나 GROUP BY 같은 처리는 스트리밍되는 것이 불가능하다.
  - 클라이언트는 MySQL이 처리하는 동안 기다려야 하기 때문에 응답 속도가 느려진다.
- JDBC는 기본적으로 스트리밍 방식이라고 하더라도 내부 버퍼에 담아둔 후 마지막 레코드가 들어왔을 때 전달한다.
  - 즉, JDBC는 기본적으로 버퍼링 방식을 자체적으로 제공한다.
  - 대량의 데이터를 가져와야 할 때는 스트리밍 방식으로 변경하여 사용하면 된다.

### 9.2.4 GROUP BY 처리

- GROUP BY 절이 있는 쿼리에서는 HAVING 절을 사용할 수 있는데, GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없기 때문에 HAVING 절을 튜닝하기 위해 인덱스를 생성할 필요는 없다.

#### 9.2.4.1 인덱스 스캔을 이용한 GROUP BY(타이트 인덱스 스캔)

- ORDER BY 처럼 조인의 드라이빙 테이블에 속한 컬럼만 이용해 그루핑할 때 GROUP BY 컬럼으로 인덱스가 있다면 인덱스를 읽으면서 그루핑 작업을 수행한다.
- 그룹 함수 등의 그룹값을 처리하기 위해 임시 테이블이 필요할 때도 있다.,
- GROUP BY 가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것이기 때문에 쿼리 실행 시점에 추가적인 정렬 작업이나 임시 테이블이 필요하지는 않다.
  - 이러한 방식은 Extra 컬럼에 Using index for group-by 나 Using tempoaray, Using folesort 가 표시되지 않는다.

#### 9.2.4.2 루스 인덱스 스캔을 이용한 GROUP BY

- 루스(Loose) 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미한다.
- 루스 인덱스 스캔을 사용할 때는 Extra 컬럼에 Using index for group-by 코멘트가 표시된다.
- MySQL 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에 서만 사용할 수 있다.
- 프리픽스 인덱스(Prefix index, 컬럼 앞 일부만으로 생성된 인덱스)는 루스 인덱스 스캔을 사용할 수 없다.
- 루스 인덱스 스캔에서는 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다.
  - 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만들어낸다.
- 루스 인덱스 스캔으로 처리되는 쿼리에서는 별도의 임시 테이블이 필요하지 않다.

#### 9.2.4.3 임시 테이블을 사용하는 GROUP BY

- GROUP BY의 기준 컬럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때 이 방식으로 처리된다.
- MySQL 5.7 까지는 GROUP BY 사용 시 자동으로 그루핑 컬럼 기준으로 정렬을 수행했다.
- MySQL 8.0 부터는 GROUP BY 기준으로 자동 정렬이 되지 않는다.
