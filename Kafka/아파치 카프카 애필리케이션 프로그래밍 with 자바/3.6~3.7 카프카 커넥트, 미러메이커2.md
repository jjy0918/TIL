# 3.6 카프카 커넥트

- 카프카 커넥트를 이용하면 데이터 파이프라인 생성 시 반복 작업을 줄일 수 있다.
- 작업 형태를 템플릿으로 만들어 놓기 때문에 매번 프로듀서, 컨슈머를 개발 배포, 운영할 필요가 없어진다.
- `소스 커넥터(source connector)`는 프로듀서 역할을 한다.
  - 파일 소스 커넥터는 파일의 데이터를 카프카 토픽으로 전송한다.
- `싱크 커넥터(sink connector)`는 컨슈머 역할을 한다.
  - 파일 싱크 커넥터는 토픽의 데이터를 파일로 저장하는 컨슈머 역할을 한다.
- 사용자가 커넥트 생성 명령을 입력하면, 커넥트 내부에서는 커넥터와 태스트크를 생성한다.
  - 커넥터는 태스크들을 관리한다.
  - 태스크는 실질적인 데이터 처리를한다.
- 사용자가 커넥트 생성 시 컨버터와 트랜스폼 기능을 옵션으로 제공한다.
  - 컨버터는 데이터 처리 하기 전 스키마 변경을 도와준다.(JsonConverter, StringConverter 등)
  - 트랜스폼은 데이터 처리 시 각 메시지 단위로 데이터를 간단하게 변환하기 위해 사용된다.(Cast, Drop, ExtractField 등)

### 커넥트 실행 방법

- `단일 모드 커넥트(standalone mode kafka connect)`
  - 단일 애플리케이션으로 실행된다.
  - 1개의 프로세스만 실행된다.
  - 고가용성이 구성되지 않기 때문에 문제가 될 수 있다.
  - 주로 개발환경이나 중요도가 낮은 파이프라인을 운영할 때 사용된다.
- `분산 모드 커넥트(distributed mode kafka connect)`
  - 2대 이상의 서버에서 클러스터 형태로 운영하기 때문에 안정적이다.
  - 데이터 처리량의 변화에도 유연하게 대응할 수 있다.
- REST API를 이용하여 현재 실행 중인 커넥트의 커넥터 플러그인 종류, 태스크 상태, 커넥터 상태 등을 조회할 수 있다.
- 카프카 커넥트 빌드 시 직접 라이브러리나 직접 작성한 클래스를 함께 빌드하여 jar로 압축해야 한다.

## 3.6.1 소스 커넥터

- 오픈소스를 사용하지 않는다면, 카프카 커넥트 라이브러리에서 제공하는 SourceConnector와 SourceTask 클래스를 사용하여 직접 구현할 수 있다.
- `SourceConnector`는 태스크 실정 전 커넥터 설정파일을 초기화하고 어떤 태스크 클래스를 사용할 것인지 정의하는데 사용된다.
- `SourceTask`는 실제로 데이터를 다룬다.
  - SourceTask에서 데이터를 가공하여 토픽으로 보내는 역할을 한다.
- 소스 커넥터는 토픽의 오프셋이 아닌, `자체적인 오프셋`을 사용한다.
  - 자체적인 오프셋을 통해 소스 파일을 어디까지 읽었는지 저장하여 데이터 중복을 방지한다.
  - 예를 들어, 파일을 읽는 경우 데이터 보낸 줄을 오프셋으로 사용할 수 있다.

## 3.6.2 싱크 커넥터

- 카프카 커넥트 라이브러리에서 제공하는 SinkConnector와 SinkTask를 구현할 수 있다.
- `SinkConnector`는 사용자로부터 입력 받은 설정값을 초기화하고, 어떤 태스크 클래스를 사용할 것인지 정의한다.
- `SinkTask`는 실제 데이터 처리를 다룬다.
  - SinkTask가 커넥트에서 컨슈머 역할을 하고 데이터를 저장한다.

# 3.7 카프카 미러메이커2

- 카프카 미러메이커2를 이용하여 서로 다른 두 개의 카프카 클러스터 간 토픽을 복제할 수 있다.
- 미러메이커2는 양방향 토픽 복제와, 파티션 변화와 토픽 설정값 변화에 대한 동기화도 지원한다.

### 미러메이커2를 활용한 단방향 토픽 복제

- 미러메이커2를 사용하기 위해서는 카프카 bin/config 디렉토리의 connect-mirror-maker.proeprties 파일을 수정해야 한다.
- connect-mirror-maker.proeprties 파일은 카프카 클러스터들에 대한 정보와 토픽 정보, 토픽을 복제하면서 하용할 내부 토픽 정보를 포함하고 있다.
- 미러메이커는 기본값으로 `5초`마다 토픽의 설정값을 확인하고 동기화한다.

## 3.7.1 미러메이커2를 활용한 지리적 복제(Geo-Replication)

### Active-Standby 클러스터 운영

- 카프카 클러스터 외 재해 복구를 위해 임시 카프카 클러스터를 구성하는 경우 액티브-스탠바이 클러스터로 운영할 수 있다.
  - 실제 운영중인 카프카를 액티브 클러스터라고 한다.
  - 대기중인 예비 카프카를 스탠바이 클러스터라고 한다.
- 미러메이커2를 이용하여 엑티브 클러스터의 정보를 스탠바이 클러스터에 복제하여 장애에 대응할 수 있다.

### Active-Active 클러스터 운영

- 대규모 서비스르 운영해야 하는 경우 통신 지연을 최소화하기 위해 2개 이상의 클러스터를 두고 서로 데이터를 미러링하여 사용할 필요가 있다.
- Active-Active 클러스터 방식은 이러한 운영에 적합하다.

### Hub and Spok 클러스터 운영

- 소규모의 여러 카프카 클러스터가 있고, 이러한 소규모 클러스터를 모아 한 개의 데이터 레이크로 사용하고 싶은 경우 허브 앤 스포크 방식을 사용한다.
- 허브는 중앙의 레이크 용도의 카프카 클러스터를 의미한다.
- 스포크는 중앙과 연결된 소규모의 카프카 클러스터를 의미한다.
- 데이터 레이크 특성상 서비스에서 생성된 데이터를 수집, 가공, 분석하는 격리된 플랫폼이 필요하다.
