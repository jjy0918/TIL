# 4.1  토픽과 파티션

## 4.1.1 적정 파티션 개수

- 카프카에서 토픽의 개수는 성능과 매우 관련이 있기 때문에 운영함에 있어 적절한 파티션 개수 설정은 매우 중요하다.
- 파티션 개수가 많아지면, 1:1 매핑되는 컨슈머의 개수도 늘어난다.
- 토픽 생성 시 파티션 개수를 정하는데 고려해야할 사항은 3가지 존재한다.
  - 데이터 처리량
  - 메시지 키 사용 여부
  - 브로커, 컨슈머 영향도

### 데이터 처리량

- 데이터 처리 속도를 올리는 방법은 2가지 존재한다.
  1. 컨슈머의 처리량을 늘린다.(서버 스케일 업, GC 튜닝 등)
  2. 컨슈머를 추가하여 병령 처리량을 늘린다.
- 일반적으로 처리량을 늘리는 것은 어렵지만, 파티션 개수를 늘려 컨슈머를 추가하는 방법은 쉽다.
- 컨슈머 데이터 처리량과 프로듀서의 데이터 생성량, 파티션 개수 공식은 다음과 같다.
  - `프로듀서 전송 데이터량 < 컨슈머 데이터 처리량 X 파티션 개수`
- 파티션 개수를 늘리는 것이 만능은 아니다. 파티션 개수가 늘어나면서 컨슈머, 브로커의 부담이 있을 수 있다.

### 메시지 키 사용 여부

- 메시지 키를 사용한다는 것은 데이터 처리 순서를 지켜야 한다는 것이다.
- 기본 프로듀서의 경우 메시지 키를 해시 형태로 변환한 다음, 해시 값을 바탕으로 파티션을 결정한다.
- 파티션의 개수가 달라지면, 이미 매칭된 파티션과 메시지 키의 매칭이 깨질 수 있다.
- 즉, 파티션의 개수가 달라지는 순간 메시지 키 순서를 보장받지 못한다.
- 그렇기 때문에 메시지 처리 순서가 보장되어야 한다면, 최대한 파티션의 변화가 발생하지 않는 방향으로 운영해야 한다.
  - 변화가 많이 발생하는 경우 커스텀 파티셔너를 개발하는 것이 좋다,

### 브로커, 컨슈머 영향도

- 파티션은 각 브로커의 파일 시스템을 사용하기 때문에 파티션이 늘어나는 만큼 브로커에서 접근하는 파일 개수가 많아진다.
- 운영체제에서 프로세스당 파일에 접근할 수 있는 최대 개수가 제한되어 있기 때문에 주의가 필요하다.

## 4.1.2 토픽 정리 정책(cleanup.policy)

- 토픽의 데이터는 시간이나 용량에 따라 삭제 규칙을 정할 수 있다.(삭제하지 않을 수도 있다.)
- cleanup.policy 옵션을 사용하여 데이터 삭제가 가능하다.
  - delete 옵션을 사용하면 완전 삭제된다.
  - compact 옵션을 사용하면, 동일 메시지 키의 가장 오래된 데이터를 삭제하는 것이다.

### 토픽 삭제 정책(delete policy)

- 기본적으로 cleanup.policy 옵션은 delete로 설정한다.
- delete 옵션을 설정하면, 토픽의 데이터를 삭제할 때 세그먼트 단위로 삭제를 진행한다.
  - 세그먼트는 파티션마다 별개로 생성되며, 토픽의 데이터를 저장하는 명시적인 파일 시스템 단위이다.
  - 세그먼트는 segemnt.bytes 옵션으로 크기를 지정할 수 있다.
  - 데이터를 저장하기 위해 사용 중인 세그먼트를 액티브 세그먼트라고 한다.
  - 세그먼트의 이름은 오프셋 중 가장 작은 값이 된다.
- 삭제 옵션이 실행되는 시점은 시간 또는 용량이 된다.
  - `retention.ms`를 통해 토픽 데이터 유지 기간을 설정한다.
  - 카프카는 retention.ms를 바탕으로 주기적으로 세그먼트들을  체크하여 마지막 수정 시간이 retention.ms를 넘어가면 삭제한다.
  - `retention.bytes`를 통해 토픽 최대 데이터 크기를 설정한다.
  - 카프카는 retention.bytes를 바탕으로 주기적으로 세그먼트들을 체크하여 세그먼트 크기가 retention.bytes를 넘어가면 삭제한다.
- 삭제한 데이터는 복구할 수 없다.

### 토픽 압축 정책(compact policy)

- 여기서 압축은 오래된 데이터를 삭제하는 것이다.
- 메시지 키를 기준으로 오래된 데이터를 삭제하기 때문에 오프셋 값과는 관계 없다.
  - 1~10까지 오프셋이 있고, 4, 5, 6이 같은 키를 가질 경우, 오프셋과 상관 없이 4, 5번이 삭제될 수 있다.
- 압축 정책은 액티브 세그먼트를 제외한 나머지 세그먼트들에 한해 진행된다.
- `min.cleanable.dirty.raion` 옵션 값을 통해 압축 시점을 설정할 수 있다.
  - 해당 옵션은 액티브 세그먼트를 제외한 세그먼트에 남아 있는 데이터 tail 영역의 레코드 수와 head 영역의 레코드 개수의 비율을 의미한다.
  - tail 영역은 압축이 완료된 레코드들을 뜻한다.
  - tail 영역은 압축이 완료되었기 때문에 clean 로그(중복 데이터x)라고 부르고, haed 영역은 dirty 로그(중복 데이터 가능)라 부른다.
  - dirty ration는 (더티 영역 메시지 개수) / (총 레코드 수) 를 의미한다.
- min.cleanable.dirty.raion 값을 0.9로 설정하는 경우 한번 압축을 할 때 많은 데이터가 줄어들지만, 그 전에 용량을 많이 차지하고 있다.
- min.cleanable.dirty.raion 값을 0.1로 설정하는 경우 자주 압축을 하지만, 메시지 키의 최신 데이터만 유지할 수 있다.

## 4.1.3 ISR(In-Sync-Replicas)

- ISR은 리더 파티션과 필로워 파티션이 모두 싱크가 된 상태를 의미한다.
  - 모두 동기화된 상태라면, 리더 파티션에 장애가 발생하더라도 데이터를 안전하게 사용할 수 있다.
- 데이터의 적재는 리더 파티션에서 진행이 되고, 리더 파티션에 데이터가 적재되어 오프셋이 증가하면 팔로워 파티션은 복제를 진행해야한다.
- 리더 파티션은 `replica.lag.time.max.ms` 값만큼 주기를 가지고 팔로워 파티션이 데이터를 복제하는지 확인한다.
  - 해당 값보다 긴 시간 동안 팔로워가 데이터를 가져가지 않는다면 해당 팔로워 파티션에 문제가 발생한 것으로 판단하고 ISR 그룹에서 제외한다.
  - ISR 그룹에서 제외된 경우 리더 파티션으로 선출되지 못한다.
  - unclean.leader.election.enable 옵션을 true로 설정하는 경우 ISR 그룹에 속하지 않아도 리더 파티션이 될 수 있다.
  - unclean.leader.election.enable 옵션을 false로 설정하는 경우 ISR 그룹에서 리더 파티션을 선출하고, 리더 파티션이 없는 경우 재시작 될 때까지 대기한다.
