# Chapter1. 들어가며

## 1.1 카프카의 탄생

- 아파치 카프카는 링크드인에서 대량의 데이터를 처리하기 위해 고안한 시스템이다.
- 카프카는 애플리케이션끼리 연결하는 것이 아니라 중앙집중화하여 한 곳에 모아 처리할 수 있도록 구현했다.
- 카프카를 이용함으로써 애플리케이션 사이의 의존도를 최소화 하여 커플링을 완화했다.
- 카프카 내부의 동작은 FIFO(First In First Out) 방식의 큐와 유사하다.
  - 큐에 데이터를 넣는 것을 `프로듀서` 라고 한다.
  - 큐에서 데이터를 가져가는 것을 `컨슈머` 라고 한다.
- 카프카에 전달하는 데이터는 모두 ByteArray로 전달하기 때문에 직렬화, 역직렬화를 통하면 데이터 포맷의 제한이 없다.
  - 기본적으로 카프카에서는 ByteArray, ByteBuffer, Double, Long, String 타입에 대한 직렬화, 역직렬화를 제공한다.
  - 필요한 경우 Serializer<T>, Deserializer<T>를 상속 받아 커스텀하여 직렬화, 역직렬화를 사용할 수 있다.

## 1.2 빅데이터 파이프라인에서 카프카의 역할

- 현재는 테라바이트를 넘어 엑사바이트의 데이터가 쌓이고 있고, 이러한 데이터를 모두 `데이터 레이크`로 모아야 한다.
  - `데이터 레이크`란 빅데이터를 저장하고 활용하기 위해서 일단 생성되는 데이터를 모두 모으는 것이다.
- `데이트 레이크`로 모으기 위해서는 데이터의 파편화와 복잡성에 대해 안정적이고 확장 가능한 파이프라인이 필요하다.
- 아파치 카프카는 이러한 데이터 파이프라인을 안정적이고 확장성 높게 운영하도록 도움을 준다.

### 높은 처리량

- 카프카는 데이터를 보내고 받을 때 묶어서 전송하기 떄문에 네트워크 통신 횟수를 효율적으로 줄일 수 있다.
  - 즉, 동일 시간 내 빠르고 많은 데이터를 주고 받을 수 있다는 것이다.
- 파티션 단위로 분배하기 때문에 병렬 처리도 가능하여 데이터 처리량을 늘릴 수 있다.

### 확장성

- 데이터를 수집할 때 가장 예측하기 어려운 것이 데이터가 얼마나 들오는가 이다.
- 카프카는 이러한 가변적인 환경에서 안정적으로 확장이 가능하다.
- 데이터가 적을 때에는 브로커를 `스케일 인(Scale-in)` 하여 운영하고, 많을 때에는 `스케일 아웃(Scale-out)` 하여 운영한다.
  - 이러한 작업들은 모두 무중단으로 가능하다.

### 영속성

- 카프카는 데이터들을 메모리가 아닌 파일 시스템에 저장한다.
- 카프카는 파일 시스템을 최대한 활용하는 방법을 사용하여 파일 I/O 성능을 향상했다.
  - 페이지 캐시 영역을 메모리에 따로 생성하는 등의 방법을 사용한다.
- 디스크를 이용한 파일 시스템을 사용하기 때문에 급작스럽게 종료되더라도 데이터를 다시 처리할 수 있다.

### 고가용성

- 카프카는 데이터의 복제를 통해 고가용성의 특징을 가진다.
  - 데이터가 들어오면, 1대의 브로커에만 저장하는 것이 아니라 다른 브로커에도 저장한다.
  - 한 브로커가 장애가 발생해도, 다른 브로커가 데이터를 가지고 있기 때문에 데이터 처리가 가능하다.

### 카프카는 어떻게 디스크를 사용해도 빠를까?

- 일반적으로 디스크 보다 메모리가 빠르다.
- Zero - Copy

  - 카프카는 `zero-copy` 라는 전략을 이용한다.
  - 일반적으로 애플리케이션을 통해 데이터를 전송하게 되면 불필요한 copy가 많이 일어난다.
  - Dist -> buffer -> application -> buffer -> network
    ![image](https://user-images.githubusercontent.com/29697310/165935481-20d92e17-d32f-499c-b75f-bf39db0a9936.png)

  - `zero-copy`는 이러한 불필요한 copy 작업을 제거하여 I/O 속도를 향상시킨다.

![image](https://user-images.githubusercontent.com/29697310/165935529-173c6ac8-f802-4364-a7b6-deda20dead2b.png)

- LZ4, SNAPPY, GZIP 등을 통한 압축
- 순자 접근
  - 일반적으로 메모리가 디스크보다 매우 빠른 것은 `Random Access` 이다.
  - `Sequential Access` 에서는 메모리와 디스크 속도 차이가 크지 않다!?
  - kafka는 Disk를 `Sequential Access` 하기 때문에 큰 속도 차이를 보이지 않을 수 있다.
- GC 최소화
  - kafka는 JVM 위에서 실행되기 때문에 GC가 실행되면 비효율적이다.

> 참고: https://cloudnweb.dev/2019/05/heres-what-makes-apache-kafka-so-fast-kafka-series-part-3/ > https://preparingforcodinginterview.wordpress.com/2019/10/04/kafka-3-why-is-kafka-so-fast/
