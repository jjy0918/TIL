# 3장. 함수 정의와 호출

# 3. 함수 정의와 호출

## 3.1 코틀린에서 컬렉션 만들기

코틀린에서 컬렉션을 만드는 방법은 2장에서 본 것 처럼 of를 이용하면 된다.

```kotlin
val set = hashSetOf(1, 7, 35)

// 여기서 to는 특별한 키워드가 아니라, 일반 함수다.
val map = hashMapOf(1 to "one", 7 to "seven")
```

여기서 만들어지는 컬렉션들은 java의 컬렉션과 같은 것이다.

코틀린은 독자적인 컬렉션을 만드는 것이 아니라, 기존 java 컬렉션을 이용한다.

또한, 기존의 java에서 제공하는 기능보다 더 많은 기능을 제공한다.

즉, 코틀린 컬렉션 = 자바의 컬렉션 + a

```kotlin
val strings = listOf("first", "second", "fourtheenth")
println(strings.last())

val numbers = setOf(1, 14, 2)
println(numbers.max())
```

## 3.2 함수를 호출하기 쉽게 만들기

코틀린에서의 컬렉션은 기본적으로 toString이 구현되어 있다.

```kotlin
>>> val list = listOf(1, 2, 3)
>>> println(list)
[1, 2, 3]
```

### 3.2.1 이름 붙인 인자

기존 자바에서(JDK 1.8 미만)는 파라미터가 여러개인 경우, 구분이 힘들었다.

어떤 파라미터에 어떠한 값이 들어가는지 한눈에 파악하기 힘들었지만, 코틀린에서는 이름에 직접 대입을 하여 구분하기 쉽게 구현할 수 있다.

다만, 주의할 점은 이름을 붙인 파라미터와 그렇지 않은 파라미터가 섞일 경우 앞에서부터는 이름을 붙이지 않은 파라미터를 써야 한다.

```kotlin
fun testFunction(
	name1: String, 
	name2: String, 
	list: List<Int>, 
	num1: Int, 
	num2: Int, 
	num3: Int
)

// Java
testFunction("string1", "string2", list, 3, 6, 9)

//kotilin - 가능
testFunction(name2 = "string2", name1 = "string1", num2 = 6, num3 = 9, num1 = 3, list = listOf())

//kotilin - 가능
testFunction("string1", "string2", num2 = 6, num3 = 9, num1 = 3, list = listOf())

//kotilin - 불가능
testFunction(list, 3, name2 = "string2", name1 = "string1", num2 = 6, num3 = 9)
```

### 3.2.2 디폴트 파라미터 값

코틀린에서는 함수의 파라미터의 디폴트 값을 설정할 수 있다.

디폴트 값을 설정함으로 오버로딩의 경우를 줄일 수 있다.

주의할 점으로는 위와 같이 앞에서부터 값을 채워야 한다는 것이다.

즉, 생략이 가능한 것은 뒤에 원소들이라는 것이다.

또한, 이름을 통해 순서와 상관 없이 값을 대입할 수 있다.

```kotlin
fun testFunction(
	name1: String = "", 
	name2: String = "", 
	list: List<Int> = listOf(), 
	num1: Int = 0, 
	num2: Int = 0, 
	num3: Int = 0
)

// 가능
testFunction("string1", "string2")

// 가능
testFunction("string1", num3 = 3, name2 = "string2")

// 불가능
testFunction(3, 4, 5)
```

### 3.2.3 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티

코틀린에서는 최상위 수준인 모든 다른 클래스 밖에 위치하게 되면, 정적인 함수나 값으로 사용할 수 있다.

다만, 다른 패키지에서 사용해야 하는 경우 해당 패키지를 import 해야 한다.

```kotlin
package test

class testClass{
}

fun funTest() {
}

///////////////////////////////////////////

package otherP

import test.funTest

class otherClass{
	fun otherFun() {
		funTest()
	}
}
```

이 과정에서 JVM는 해당 정적 함수를 위해 클래스를 생성해준다.

이때 만들어주는 클래스는, 해당 함수의 이름+Kt이다.

즉, 위 예제에서는 funTestKt 라는 이름의 클래스가 만들어진다.

이러한 것은 함수 뿐만 아니라 프로퍼티도 가능하다.

프로퍼티를 사용하면서, final 키워드를 붙이고 싶다면 const 키워드를 붙여주면 된다.

val 키워드만 붙여주게 되면, getter를 생성하고 접근하게 된다.

const를 같이 붙여 const val이 되면, 그 값 자체에 접근할 수 있다.

하지만, const는 원시 타입과 String 타입의 프로퍼티만 가능하다는 단점이 있다.