# 6. 코틀린 타입 시스템

## 6.1 널 가능성

- `널 가능성(nullability)`는 NullPointerException 오류(NPE)를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.
- NPE는 사용자와 개발자를 모두 당황시킨다.
- 코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법을 최대한 실행 시점이 아닌 컴파일 시점으로 옮기는 것이다.
- null이 가능한 여부를 타입 시스템에 추가하여 컴파일 시점에 여러 오류를 미리 감지할 수 있게 도와준다.

### 6.1.1 널이 될 수 있는 타입

- 코틀린이 자바와 다른 큰 점 중 하나는 널이 될 수 있는 타입 시스템이 존재한다는 것이다.
- 널이 될 수 있는 타입은 프로퍼티나 변수에 null을 허용하는 것이다.
- 널이 될 수 있다는 것은 NPE가 발생할 수 있기 때문에 안전하지 않다.
- 널이 가능한 타입은 타입 이름 뒤에 `물음표(?)`를 붙이면 된다.
  - 물음표가 없는 타입은 모두 널이 올 수 없다.
  - 즉, 코틀린에서 기본 타입은 모두 널이 올 수 없다.
- 널이 될 수 있는 타입은 수행할 수 있는 연산이 제한된다.
  - 변수.메소드() 처럼 메소드를 직접 호출할 수 없다.
- 널이 될 수 있는 타입을 null과 비교하게 되면, 널이 될 수 없는 타입에 대입할 수 있다.

```kotlin
fun strLenSafe(s: String?): Int = 
    if (s != null) s.length else 0
val x: String? = null
println(strLenSafe(x))
```

### 6.1.2 타입의 의미

- 타입이란 분류(classification)로 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정해준다.
- 일반적으로 자바의 객체들은 null을 포함하는데, null은 하나의 타입이라고 볼 수 없다.
  - String 객체 안에 진짜 String 객체가 있을 수도 있지만, null이 있을 수 있다.
- 자바에서는 타입 시스템이 널을 제대로 다루지 못하기 때문에 널 여부를 추가로 검사해야 한다는 불편함이 존재한다.
- 코틀린에서는 널이 될 수 있는 타입과 될 수 없는 타입을 따로 존재하기 때문에 어떤 연산이 가능할지 명확하게 이해할 수 있다.

### 6.1.3 안전한 호출 연산자: ?.

- 코틀린에서 제공하는 가장 유용한 도구 중 하나가 `안전한 호출 연산`인 `?.` 이다.
- `?.` 연산자는 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.
- `?.` 연산자를 이용하게 되면, 해당 객체가 null인 경우 null을 반환하고 null이 아닌 경우 메소드를 수행한 결과가 반환된다.
  - foo?.bar() 호출 시
  - foo != null => foo.bar()
  - foo == null => null

```kotlin
// 안전한 호출 연산
s?.toUpperCase() 

// 같은 의미
if ( s != null) {
    s.toUpperCase()
} else {
    null
}
```

- 안전한 호출 연산자의 `결과 값`도 `널이 될 수 있는 타입`이다.
  - s?.toUpperCase()의 결과 값은 String? 이다.
- 안전한 호출의 결과를 연쇄적으로 사용하여 불필요한 if문을 간단하게 사용할 수 있다.
  - val country = this.company?.address?.country

### 6.1.4 엘비스 연산자: ?;

- null 대신 사용할 디폴트 값을 지정할 때 `엘비스 연산자`인 `?:`을 사용하면 편리하다.

```kotlin
fun foo(s: String?) {
    // s가 null이면 default, 아니면 그 값.
    val t: String = s ?: "default"
}
```

- 엘비스 연산자와 안전한 호출 연산자를 함께 사용하여 객체가 널인 경우를 대비한 값을 지정할 수 있다.
- 코틀린에서는 return이나 throw도 식이기 때문에 엘비스 연산자 우항에 넣을 수 있다.

```kotlin
fun printShippingLabel(person: Person) {
    // address가 null이면 예외 발생
    val address = person.company?.address ?: throw IllegalArgumentException("No Address")
    
    // address는 null이 아님
    with(address) {
        println(address)
        ...
    }
}
```

### 6.1.5 안전한 캐스트: as?

- 코틀린에서는 캐스트 연산자 as가 존재하고, as로 지정한 타입으로 바꿀 수 없으면 ClassCastException을 발생시킨다.
- `as?`는 지정한 타입으로 변경할 수 없을 때 `null`을 반환한다.
  - foo as? Type
  - foo is Type => foo as Type
  - foo !is Type => null
- 안전한 캐스트를 사용하는 일반적인 패턴은 캐스트를 수행한 뒤 엘비스 연산자를 사용하는 것이다.

```kotlin
fun equals(o: Any?): Boolean {
    // o가 Person 타입이 아닐 경우 null을 반환한다.
    // null이 반환될 경우 false를 return 한다.
    val otherPerson = o as? Person ?: return false
    return otherPerson.firstName == firstName
}
```

### 6.1.6 널 아님 단언: !!

- `널 아님 단언(not null assertion)`은 어떤 값이든 강제적으로 널이 될 수 없는 타입으로 바꿀 수 있다.
- null인 경우 NPE를 발생시킨다.
  - foo!!
  - foo != null => foo
  - foo == null => NullPointerException
- 코틀린 설계자들은 컴파일러가 검증할 수 없는 단언(!! 연산자)을 사용하기 보다는 더 나은 방법을 찾아 사용하도록 권한다.
- `!!` 연산자는 예외 스택 트레이스에서 몇 번째 줄에서 발생했는지는 알려주지만, 어떤 식에서 예외가 발생해는지는 알려주지 않기 떄문에 한 줄에 많이 쓰는 것은 좋지 않다.
  - person.company!!.address!!.country

### 6.1.7 let 함수

- `let` 연산자는 해당 객체(수신 객체)에 대한 처리를 한 후 값을 리턴할 수 있다.
- `let` 연산자와 안전한 호출 연산자를 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음 그 결과를 변수에 넣는 식을 간단하게 사용할 수 있다.
  - let은 함수이기 때문에 null인 경우 let에서 받은 람다를 실행하지 않고 null을 리턴한다.

```kotlin
fun sendEmailTo(email: String) { /* ... */ }

// email == null => email?.let { } ==> null
// email != null => email?.let { } => { } 실행 
email?.let { email -> sendEmailTo(email) }
```

- let 호출을 중첩시켜서 여러 값이 null인지 체크할 수 있지만, 그러한 로직은 코드가 복잡해지기 때문에 일반적으로 if문에서 한 번에 처리하는 것이 좋다.

### 6.1.8 나중에 초기화할 프로퍼티

- 프로퍼티 중 객체가 생성 된 후 초기화가 되어야할 필요가 있을 수 있다.
- `lateinit`을 선언한 프로퍼티는 나중에 초기화 될 수 있다.
  - 초기화 전에 접근하면, lateinit property has not been initialzed 예외가 발생한다.
- `lateinit` 프로퍼티는 반드시 var 이어야 한다.
- 스프링 등 DI 프레임워크와 함께 사용하는 경우가 많다.

### 6.1.9 널이 될 수 있는 타입 확장

- 널이 될 수 있는 타입에 대한 확장을 정의하면, 널이 될 수 있는 값에 대해 그 확장 함수를 호출할 수 있다.
- String? 타입의 isNullOrBlank 메소드는 null 체크 등의 연산자(?.)가 필요 없다.
- 널이 될 수 있는 타입의 확장 함수는 this의 값이 null이 될 수 있다.
  - 자바에서는 this가 null이 될 수 없지만, 코틀린에서는 this가 null일 수 있다.

### 6.1.10 타입 파라미터의 널 가능성

- 일반적으로 코틀린의 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.
- 타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면, 이름 끝에 물음표가 없어도 널이 될 수 있다.

```kotlin
fun <T> printHashCode(t: T) {
    println(t?.hashCode())
}
```

- 타입 파라미터가 널이 아님을 확실히 하기 위해서는 널이 될 수 없는 `타입 상한`을 지정해주면 된다.

```kotlin
fun <T: Any> printlnHashCode(t: T) {
    println(t.hashCode())
}
```

### 6.1.11 널 가능성과 자바

- 코틀린은 자바와의 호환이 가능하다.
- 자바에서 어노테이션을 통해 코틀린 타입을 확실하게 할 수 있다.
  - `@Nullable` + Type = Type?
  - `@NotNull` + Type = Type

#### 플랫폼 타입

- 플랫폼 타입은 자바에서 널 가능성 어노테이션이 없어 코틀린에서 널 관련 정보를 알 수 없는 타입을 말한다.
- 플랫폼 타입을 널이 될 수 있는 타입으로 처리해도 되고, 널이 될 수 없는 타입으로 처리해도 된다.
  - 컴파일러는 모든 연산을 허용한다.
  - Type = Type or Type?
- 자바의 API를 제대로 사용하기 위해서는 문서를 자세히 살펴보고, 널을 반환하는지 아닌지를 알아내고 검사해야 한다.
- 에러 내용에서 `!`만 있는 경우 해당 타입의 널 가능성에 대해 아무 정보도 없다는 뜻이다.
  - ERROR: Type mismatch: inferred type is String! but Int was expected

#### 상속

- 코틀린에서 자바의 메소드를 오버라이딩 할 때 파라미터와 반환 타입을 널이 될 수 있는 타입인지, 아닌지를 결정해야 한다.
- 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 코틀린은 널이 아님을 검사하는 단언문을 만들어준다.
  - 자바 코드가 그 메소드에 널 값을 넘기면, 단언문이 발동되어 예외가 발생한다.

### 6.1.12 정리

- `안전한 호출(?.)`: null이면 메소드 실행 X + null 리턴, null이 아니면 메소드 실행 O
- `엘비스 연산자(?:)`: null일 때 기본 값 설정
- `안전한 캐스팅(as?)`: 캐스팅 가능하지 않을 경우 null 리턴
- `단언(!!)`: 널이 될 수 없는 타입으로 변환 