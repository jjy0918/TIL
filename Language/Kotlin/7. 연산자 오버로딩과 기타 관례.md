# 7. 연산자 오버로딩과 기타 관례

## 7.1 산술 연산자 오버로딩

- Java에서는 원시 타입과 String에서만 `+` 연산자를 사용할 수 있다.
- 코틀린에서는 클래스에서도 `+`와 같은 산술 연산자를 정의할 수 있다.

### 7.1.1 이항 산술 연산 오버로딩

```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}

val p1 = Point(10, 20)
val p2 = Point(30, 40)
println(p1 + p2) // Point(x=40, y=60)
```

- 산술연산자는 `operator`라는 키워드를 붙여서 오버로딩한다.
- `operator`와 함께 오버로딩을 하면, 산술 연산자 키워드로 두 객체를 처리할 수 있다.
  - 연산자 정의 시 반드시 두 피연산자가 같은 타입일 필요는 없다.
  - 코틀린 연산자는 자동으로 교환 법칙을 지원하지 않기 때문에, 따로 구현해주어야 한다.
- 산술 연산자 오버로딩은 직접 만들수는 없고, 코틀린이 정해 놓은 연산자만 가능하다.
  - a * b: `time`
  - a / b: `div`
  - a % b: `mod`, `rem`(1.1부터)
  - a + b: `plus`
  - a - b: `minus`
- 코틀린 산술 연산자 역시 일반적은 산술 연산자와 우선순위가 같다.
- 자바의 메소드 이름이 코틀린의 관례와 맞아 떨어지면, 연산자 식을 사용할 수 있다.
- operator 함수도 오버라이딩이 가능하기 때문에 파라미터 타입이 서로 다른 연산자 함수를 여럿 만들 수 있다.

### 7.1.2 복합 대입 연산자 오버로딩

- `+=`, `-=` 등의 `복합 대입 연산자`도 오버로딩이 가능하다.
- 복합 대입 연산자는 변수가 변경 가능한 경우에만 사용할 수 있다.
- a += b: `plusAssign`
- a -= b: `minusAssign`
- a *= b; `timesAssign`
- 이론적으로 +=는 plus와 plusAssign 양쪽으로 컴파일할 수 있지만, 두 함수 모두 정의한 경우 컴파일러는 오류를 보고한다.
- 결과 값이 변경 불가능하여 새로운 값을 반환한다면 plus, 변경 가능하다면 plusAssign을 제공하는 것이 좋다.
- 코틀린의 표준 라이브러리 컬렉션은 `+`, `-`, `+=`, `-=` 모두 제공한다.
  - `+`, `-`는 항상 새로운 컬렉션을 반환한다.
  - `+=`, `-=`는 변경 가능한 컬렉션의 상태를 변화시키고, 변경 불가능한 컬렉션은 계산된 새로운 객체를 반환한다.

```kotlin
operator fun <T> MutableCollection<T>.plusAssign(element: T) {
    this.add(element)
}
```

### 7.1.3 단항 연산자 오버로딩

- 코틀린에서는 단항 연산자 오버로딩도 지원한다.
- 단항 연산자 역시 `operator`와 함께 정헤진 이름의 함수를 오버로딩하면 된다
  - +a: `unaryPlus`
  - -a: `unaryMinus`
  - !a: `not`
  - ++a, a++: `inc`
  - --a, a--: `dec`
  - ++a, a++, a--, --a 같은 경우에는 전위 후우외 연산자와 같은 의미를 제공한다.

```kotlin
operator fun BigDecimal.inc() = this + BicDecimal.ONE

var bd = BigDecimal.ZERO
println(bd++) // 0
println(++bd) // 2
```