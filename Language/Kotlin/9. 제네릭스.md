# 9. 제네릭스

## 9.1 제네릭 타입 파라미터

- 제네릭스를 사용하면 타입 파라미터type parameter)를 받는 타입을 정의할 수 있다.
- 제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 타입 인자(type argument)로 치환해야 한다.
- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있다.
  - val authors = listOf("Dmitry", "Svetlanan") // List<String> 임을 추론
- 자바와 달리 코틀린에서는 제네릭 타입의 타입 인자를 프로그래머가 명시하거나 컴파일러가 추론할 수 있어야 한다.

### 9.1.1 제네릭 함수와 프로퍼티

- 컬렉션의 대부분은 제네릭 함수다.
- 클래스나 인터페이스 안에 정의된 메소드, 확장 함수 또는 최상위 함수에서 타입 파라미터를 선언할 수 있다.
- 제네릭 함수를 정의할 때와 마찬가지로 방법으로 제네릭 확장 프로퍼티를 선언할 수 있다.
  - 일반 프로퍼티는 타입 파라미터를 가질 수 없다.
  - 클래스 프로퍼티에 여러 타입의 값을 저장할 수는 없으므로 제네릭한 일반 프로퍼티는 말이 되지 않는다.
    - 클래스 제네렉이 아닌, 프로퍼티 자체 제네릭이 불가능하다는 것.

```kotlin
val <T> List<T>.penultimate: T
    get() = this[size-2]

class MyClass {
    val <T> x: T = TODO() // 불가능
}
```

### 9.1.2 제네릭 클래스 선언

- 자바와 마찬가지로 코틀린에서도 타입 파라미터를 넣은 꺾쇠 기호(<>)를 클래스(인터페이스) 이름 뒤에 붙이면 클래스(인터페이스)를 제네릭하게 만들 수 있다.
- 타입 파라미터를 이름 뒤에 붙이고 나면, 클래스 본문 안에서 타입 파라미터를 다른 일반 타입처럼 사용할 수 있다.
- 제네릭 클래스를 확장하는 클래스(또는 제네릭 인터페이스를 구현하는 클래스)를 정의하려면 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 한다.
  - 이때 구체적인 타입을 넘길 수도 있고(하위 클래스도 제네릭이라면) 타입 파라미터로 받은 타입을 넘길 수도 있다.

```kotlin
class StringList : List<String> { // 구체적인 타입을 넘김
    override fun get(index: Int): String = ... 
}

class ArrayList<T> : List<T> {  // 제네릭 타입 파라미터를 타입 인자로 넘김
    override fun get(index: Int)  T = ...
}
```

### 9.1.3 타입 파리미터 제약

- 타입 파라미터 제약(type parameter constraint)은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능이다.
- 어떤 타입을 제네릭 타입의 타입 파리미터에 대한 상한(upper bound)으로 지정하면, 그 제네릭 타입 인스턴스 시 그 상한 타입이거나 그 타입의 하위 타입이어야 한다.

```kotlin
fun <T : Number> List<T>.sum(): T

println(listOf(1, 2, 3).sum()) // 가능
println(listOf("1", "2", "3").sum()) // 불가능
```

- `where` 구문을 이용하면, 타입 파라미터에 여러 제약을 가할 수 있다.

```kotlin
fun <T> ensureTrailingPeriod(seq: T)
    where T: CharSequence, T: Appendable {
        if(!seq.endWith(".")) {
            seq.append('.')
    }
}
```