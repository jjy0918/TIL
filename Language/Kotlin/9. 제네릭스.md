# 9. 제네릭스

## 9.1 제네릭 타입 파라미터

- 제네릭스를 사용하면 타입 파라미터type parameter)를 받는 타입을 정의할 수 있다.
- 제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 타입 인자(type argument)로 치환해야 한다.
- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있다.
  - val authors = listOf("Dmitry", "Svetlanan") // List<String> 임을 추론
- 자바와 달리 코틀린에서는 제네릭 타입의 타입 인자를 프로그래머가 명시하거나 컴파일러가 추론할 수 있어야 한다.

### 9.1.1 제네릭 함수와 프로퍼티

- 컬렉션의 대부분은 제네릭 함수다.
- 클래스나 인터페이스 안에 정의된 메소드, 확장 함수 또는 최상위 함수에서 타입 파라미터를 선언할 수 있다.
- 제네릭 함수를 정의할 때와 마찬가지로 방법으로 제네릭 확장 프로퍼티를 선언할 수 있다.
  - 일반 프로퍼티는 타입 파라미터를 가질 수 없다.
  - 클래스 프로퍼티에 여러 타입의 값을 저장할 수는 없으므로 제네릭한 일반 프로퍼티는 말이 되지 않는다.
    - 클래스 제네렉이 아닌, 프로퍼티 자체 제네릭이 불가능하다는 것.

```kotlin
val <T> List<T>.penultimate: T
    get() = this[size-2]

class MyClass {
    val <T> x: T = TODO() // 불가능
}
```

### 9.1.2 제네릭 클래스 선언

- 자바와 마찬가지로 코틀린에서도 타입 파라미터를 넣은 꺾쇠 기호(<>)를 클래스(인터페이스) 이름 뒤에 붙이면 클래스(인터페이스)를 제네릭하게 만들 수 있다.
- 타입 파라미터를 이름 뒤에 붙이고 나면, 클래스 본문 안에서 타입 파라미터를 다른 일반 타입처럼 사용할 수 있다.
- 제네릭 클래스를 확장하는 클래스(또는 제네릭 인터페이스를 구현하는 클래스)를 정의하려면 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 한다.
  - 이때 구체적인 타입을 넘길 수도 있고(하위 클래스도 제네릭이라면) 타입 파라미터로 받은 타입을 넘길 수도 있다.

```kotlin
class StringList : List<String> { // 구체적인 타입을 넘김
    override fun get(index: Int): String = ...
}

class ArrayList<T> : List<T> {  // 제네릭 타입 파라미터를 타입 인자로 넘김
    override fun get(index: Int)  T = ...
}
```

### 9.1.3 타입 파리미터 제약

- 타입 파라미터 제약(type parameter constraint)은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능이다.
- 어떤 타입을 제네릭 타입의 타입 파리미터에 대한 상한(upper bound)으로 지정하면, 그 제네릭 타입 인스턴스 시 그 상한 타입이거나 그 타입의 하위 타입이어야 한다.

```kotlin
fun <T : Number> List<T>.sum(): T

println(listOf(1, 2, 3).sum()) // 가능
println(listOf("1", "2", "3").sum()) // 불가능
```

- `where` 구문을 이용하면, 타입 파라미터에 여러 제약을 가할 수 있다.

```kotlin
fun <T> ensureTrailingPeriod(seq: T)
    where T: CharSequence, T: Appendable {
        if(!seq.endWith(".")) {
            seq.append('.')
    }
}
```

### 9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정

- 제네릭 클래스나 함수를 정의하고 그 타입을 인스턴스화할 때 널이 될 수 없는 타입을 지정할 수 있다.
- 널이 될 수 없는 타입만 넣고 싶다면, 타입 파라미터에 제약을 가해야 한다.
  - <T : Any>는 널이 될 수 없는 타입만 올 수 있다.
  - Any뿐 아니라 다른 널이 될 수 없는 타입을 명시해도 된다.

```kotlin
// T는 널이 될 수 있는 타입이 올 수 있다.
class Processor<T> {
    fun process(value: T) {
        value?.hashCode()
    }
}

// T는 널이 될 수 없는 타입만 올 수 있다.
class Processor<T : Any> {
    fun process(value: T) {
        value.hashCode()
    }
}
```

## 9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

- JVM의 제네릭스는 보통 타입 소거(type erasure)를 사용하여 구현된다.
  - 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어 있지 않다는 뜻이다.

### 9.2.1 실행 시점의 제네릭: 타입 검사와 캐스트

- 자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다.
  - 즉, 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인 타입 인자에 대한 정보를 유지하지 않는다는 뜻이다.
- List<String>과 List<Int> 모두 런타임시에는 그냥 List로만 보인다.
- 컴파일러는 타입을 구분하기 때문에 올바른 타입의 값만 각 리스트에 넣도록 보장해주기 때문에 런타임시에는 검사하지 않는다.
- 타입 소거에 의하여 런타임시에는 `is` 검사에 의하여 타입 인자로 지정한 타입을 검사할 수 없다.
  - value is List<String> ==> 에러 발생
- 코틀린에서는 타입 검사를 할 때 스타 프로젝션(star projection)을 이용한다.
  - value is List<\*>
  - value가 List임은 알지만, 어떤 타입인지는 모른다.
- 컴파일러가 캐스팅 시 관련 경고를 하기는 하지만, 코드는 문제 없이 동작한다.

### 9.2.2 실체화한 타입 파라미터를 사용한 함수 선언

- 코틀린 제네릭 타입의 타입 인자는 런타임 시점에 지워지기 때문에 인스턴스가 있어도 사용한 타입 인자를 알 수 없다.
- 제네릭 함수 역시 함수의 본문에서는 호출 시 쓰인 타입 인자를 알 수 없다.
- inline 함수의 경우, 타입 파라미터가 실체화되기 때문에 실행 시점에 함수의 타입 인자를 알 수 있다.
  - `filterIsInstance` 인라인 함수의 경우 인자를 알 수 있다.
  - `reified` 키워드를 통해 타입 파라미터가 런타임시 지워지지 않음을 표현한다.
  - 타입 파라미터가 아닌, 구체적인 타입으로 만들어진 바이트 코드를 사용하기 때문에 타입 소거의 영향을 받지 않는다.
  - 자바에서는 reified 타입 파라미터를 사용하는 inline 함수를 사용할 수 없다.
-

```kotlin
fun <T> isA(value: Any) = value is T
Error: Cannot check for instance of erased type: T

// 컴파일 가능
inline fun <reified T> isA(value: Any) = value is T
```

### 9.2.3 실체화한 타입 파라미터로 클래스 참조 대신

- java.lang.Class를 사용하는 JDK의 ServiceLoader에서는 클래스나 인스턴스를 구현한 인스턴스를 반환한다.
- 이때 사용하는 것이 `::class.java` 구문이다.
  - val serviceImpl = ServiceLoader.load(Service::class.java)
  - Service::class.java는 java의 Serivce.class와 완전히 같다.
- 코틀린에서는 ServiceLoader 타입 파라미터와 인라인 함수를 이용하여 간단하게 구현할 수 있다.

```kotlin
val serviceImpl = loadService<Service>()

inline fun <reified T> loadService() {
    return ServiceLoader.load(T::class.java)
}
```

### 9.2.4 실체화한 타입 파라미터의 제약

- 실체화한 타입 파라미터는 유용하지만 제약이 존재한다.
- 실체화한 타입 파라미터를 사용할 수 있는 경우
  - 타입 겁사와 캐스팅(is, !is, as, as?)
  - 코틀린 리플랙션 API(::class)
  - 코틀린 타입에 대응하는 java.lang.Class를 얻기(::class.java)
  - 다른 함수를 호출할 때 타입 인자로 사용
- 실체화한 타입 파라미터를 사용할 수 없는 경우
  - 타입 파라미터 클래스의 인스턴스 생성하기
  - 타입 파라미터 클래스의 동반 객체 메소드 호출하기
  - 실체화한 타입 파라미터를 요구하는 함수르 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넣기
  - 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기

## 9.3 변성: 제네릭과 하위 타입

- 변성(variance)은 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지에 대한 개념이다.

### 9.3.1 변셩이 있는 이유: 인자를 함수에 넘기기

- 코틀린에서는 원소를 추가하거나 변경할 수 있는 경우 List<Any> 대신 List<String>을 넘길 수 없다.
- 단순 조회하는 경우 List<Any> 대신 List<String>을 넘길 수 있다.

### 9.3.2 클래스, 타입, 하위 타입

- 일반적으로 제네릭이 아닌 클래스의 타입은 클래스의 이름과 같다.
- 제네릭 클래스의 경우 올바른 타입을 알기 위해서는 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.
  - List는 클래스이지만 타입이 아니다.
  - List<Int>, List<STring?> 은 타입이다.
  - 제네릭 클래스는 무수히 많은 타입을 만들어낼 수 있다.
- 타입 사이의 관계에서 가장 중요한 개념은 `하위 타입(subtype)`과 `상위 타입(supertype)`이다.
  - 타입 A의 값이 필요한 곳에 타입 B를 넣어도 문제가 없다면 B는 A의 하위 타입이라고 한다.
  - Int는 Number의 하위 타입이다.
  - 하위 타입은 간단하게 하위 클래스와 근본적으로 같다.
  - 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이다.
  - 상위 타입은 타위 타입의 반대다.
  - A가 B의 하위 타입이면, B는 A의 상위 타입이다.
  - 모든 타입이 자신의 하위 타입이기도 한다는 뜻이다.
  - List<String>은 List<Any>의 하위 타입이 아니다.
- 제네릭을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가고 타입 사이의 하위 관계가 성립하지 않는 경우 `무공변(invariant)`이라고 한다.
- 자바에서는 모든 클래스가 무공변이다.
