# 3장 템플릿

## 3.1 다시 보는 초난감 DAO

### 3.1.1 예외처리 기능을 갖춘 DAO

기존 UserDao 코드에 DI를 적용하여 관심사를 분리하여 확장과 변경에 용이하도록 개선하였다.
하지만, 개선한 UserDao 코드에 아직 문제점이 남아 있다.
UserDao 코드를 실행하는 과정에서 예외처리에 대한 부분이 고려되지 않았다.

```java
// DI 를 적용하여 개선한 UserDao의 deletaAll 코드
public void deletaAll() throws SQLException {
    Connection c = dataSource.getConnection();

    PreparedStatement ps = c.prepareStatement("delete from users");
    ps.executeUpdate();

    ps.close();
    c.close();
}
```

- UserDao 코드에서는 DB 커넥션을 만들어서 접속하고 있고, 이러한 커넥션은 풀로 관리된다.
- 즉, 에러가 발생할 경우 커넥션이 반환되지 않고 커넥션 풀에 여유가 없어지기 때문에 리소스가 모자라게 된다.
- 에러가 발생할 경우 커넥션을 반환하는 코드를 추가하여 개선해야 한다.

```java
// 에러 발생 시 리소스 반환 개선 코드
public void deletaAll() throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;

    try {
        c = dataSource.getConnection();
        ps = c.prepareStatement("delete from users");
        ps.executeUpdate();
    } catch (SQLException e) {
        throw e;
    } finally {
        if (ps != null) {
            try {
                ps.close();
            } catcy (SQLException e) {

            }
        }

        ifc(c != null) {
            try {
                c.close();
            } catcy (SQLException e) {
                
            }
        }
    }
}
```

## 3.2 변하는 것과 변하지 않는 것

### 3.2.1 JDBC try/catch/finally 코드의 문제점

- 위에서 개선한 UserDao 코드는 try/catch/finally 블록이 반복되고 중첩되어 적용되어 있다.
- 이렇게 반복되는 코드를 효과적으로 다루기 위해서는 `변하지 않는` 코드와 `확장이 가능한` 코드를 분리하는 것이다.

### 3.2.2 분리와 재사용을 위한 디자인 패턴 적용

#### 메소드 추출

- 변하지 않는 부분과 변하는 부분을 분리하여 변하지 않는 부분만 재사용하는 방법 중 하나가 메소드로 추출하는 것이다.,

#### 템플릿 메소드 패턴

- 템플릿 메소드 패턴은 상속을 통해 기능을 확장하는 패턴이다.
- 고정된 로직을 상위 클래스에 구현해놓고, 변경되는 로직은 하위 클래스에서 각 역할에 맞게 구현하여 사용하는 것이다.
- 템플릿 메소드 패턴의 단점은 모든 하위 로직이 상속을 통해 새로운 클래스를 만들어야 한다는 점 때문에 확장 구조가 고정되어버린다.
- 즉, 템플릿 메소드 패턴은 OCP(개방 폐쇄 원칙)을 잘 지키고는 있지만 관계에 대해 유연성이 떨어진다.

#### 전략 패턴

- 전략 패턴은 오브젝트를 아예 둘로 분리하여 클래스 레벨에서는 인터페이스를 통해서만 의존하는 것이다.
- 그렇기 때문에 전략 패턴은 템플릿 메소드 패턴보다 유연하다.
- 전략 패턴은 기본적으로 고정된 로직을 가진 클래스와 변경되는 로직은 전략을 구현하는 인터페이스와 해당 구현체가 나뉜다.
  - 고정된 로직을 가진 클래스는 인터페이스를 통해 전략을 실행한다.
  - 각 전략은 인터페이스를 구현하여 수행한다. 
- 전략 패턴은 템플릿 메소드 패턴처럼 필요에 따라 고정된 로직은 그대로이면서 변경 가능한 전략은 바꿔 쓸 수 있다.
  - 그리고 인터페이스로 연결되어 있기 때문에 유연성도 높아진다.

#### DI를 이용한 전략 패턴 적용

- 전략 패턴은 Context(고정 로직)가 어떤 전략을 사용할 것인가는 앞단 Client(context 사용 코드)가 결정한다.
  - Client는 하나의 전략을 선택하여 오브젝트로 만들어서 Context에 전달한다.
- DI는 제3자의 도움을 통해 두 오브젝트 사이의 유연한 관계를 설정하는 것이기 때문에 Client의 역할은 DI의 역할을 한다고 볼 수 있다.