# 7장 스프링 핵심 기술의 응용

## 7.2 인터페이스의 분리와 자기참조 빈

### 7.2.3 빈의 초기화 작업

- 생성자에서 예외가 발생 가능한 복잡한 초기화 작업을 하는 것은 좋지 않다.
  - 상속하기 불편하며, 보안에 문제가 생길 수 있다.
  - 복잡한 로직이 필요하다면, 초기화 메소드를 따로 만들어 선언하는 방법이 좋다.
- 스프링에서는 Bean 생성 시 객체 생성 후 `빈 후처리기`라는 객체 생성 후 부가 작업을 실행해주는 제공한다.
  - 빈 후처리기는 AOP에서 사용했던 것 처럼 어노테이션을 이용하여 설정할 수 있다.
- 빈 후처리기는 <bean> 태그를 이용하여 하나씩 등록하기 보다는 `context` 스키마의 `annotation-config` 태그를 사용하는 것이 편리하다.
  - 설정 파일에 `<context:annotation-config/>` 태그를 넣어주면 어노테이션을 통해 빈 후처리기를 등록할 수 있다.
- 빈 후처리기 중 하나가 `@PostConstruct` 다.
  - `@PostConstruct` 빈 오브젝트 초기화 메소드를 지정하는 데 사용한다.
  - `@PostConstruct` 를 사용하면, 생성자에서 불필요하게 복잡한 초기화 기능을 넣지 않고 오브젝트 생성 시 간단하게 초기화 메소드를 실행시킬 수 있다.
- 빈 후처리기는 DI 작업 후 실행된다.

#### 주의점

`@PostConstruct` 는 `JDK 6`에서 추가된 Common Annotation 이다.
하지만, `JDK 11` 에서 Common Annotation에서 `@PostConstruct` 는 제거되었다.
즉, 스프링을 실행할 때 JDK 6 ~ JDK 10 까지는 `@PostConstruct` 를 별다른 의존성 없이 사용이 가능하지만
JDK 11 부터는 `@PostConstruct` 사용 시 의존성 추가가 필요하다.(`implementation "javax.annotation:javax.annotation-api:1.3.2"`)
`@PostConstruct` 뿐 아니라 `@PostDestroy` 도 동일하다.

> https://stackoverflow.com/questions/52701459/i-cant-use-postconstruct-and-postdestroy-with-java-11

### 7.2.4 변화를 위한 준비: 인터페이스 분리

- XmlSqlService는 SQL을 가져오기 위해 특정 기술에 고정되어 있고 SQL은 HashMap에 무조건 저장되기 때문에 유연한 확장이 불가능해진다.
  - Xml이 아니라 다른 포멧의 SQL을 가져오기 위해서는 새로운 클래스를 만들거나 XmlSqlService를 수정해야 한다.
  - SQL을 HashMap이 아니라 다른 포멧으로 저장하고 검색하기 위해서도 수정이 필요하다.

#### 책임에 따른 인터페이스 정의

- `XmlSqlService` 는 독립적으로 변경 가능한 책임 두 가지를 가지고 있다.
  - 1 SQL 정보를 외부의 리소스에서 읽어 오는 것.
  - 2 SQL을 보관해두었다가 필요할 때 제공하는 것.
- SqlService가 두 개의 책임을 모두 가진 상태가 아니라, 각각의 책임을 가진 오브젝트와 협력하도록 만들어야 한다.
  - SQL을 외부 리소스에서 읽는 것은 `SqlReader` 가 해야 한다.
  - SQL을 보관 및 제공은 `SqlRegistry` 가 해야 한다.
- `SqlReader`와 `SqlRegistry` 에 대한 전략은 두 가지로 정리할 수 있다.
  1. `SqlReader` 에서 SQL을 읽고 그 값을 `SqlRegistry` 에 전달하여 저장
     - SqlReader가 읽어오는 SQL은 SqlRegistry에 전달되어 등록되어야 하는데, 이때 JAXB에서 만들어준 Sql 클래스를 그대로 쓰는 것은 좋지 않다.
       - JAXB에서 만들어준 Sql 클래스를 그대로 쓴다는 것은 SqlReader가 JAXB에 강력하게 의존하게 된다.
       - SqlReader가 읽은 SQL은 범용성 있게 전달하려면 Map 으로 전달하도록 하는 것이 좋다.
  2. `SqlReader` 에게 `SqlRegistry`` 전략을 제공하여 저장.
     - `SqlReader` 는 SQL을 읽는 역할을 하고, 결국 `SqlRegistry`에서 해당 SQL을 등록하기 때문에 불필요하게 SqlReader에서 읽은 후 그 데이터를 SqlRegistry에 전달할 필요가 없다.
       - `SqlReader` 에서 읽은 데이터와 `SqlRegistry` 에서 저장할 포멧을 항상 맞춰주어야 하는 불편함이 존재한다.
     - `sqlReader.readSql(sqlRegistry);`
     - SqlRegistry는 특정 포멧에 맞게 구현할 필요 없고, SqlReader는 SQL을 굳이 특정 오브젝트로 변환할 필요가 없어진다.
- 2번 전략의 경우 각자의 오브젝트가 자신의 역할만 충실하게 작업하면 되고, 불필요한 내부 데이터를 외부에 노출할 필요가 없어서 더 좋은 방법이라 할 수 있다.

```java
interface SqlRegitrstry {
    void registerSql(String key, String sql);

    String findSql(String key) throws SqlNotFoundException;
}

interface SqlReader {
    void read(SqlRegistry sqlRegistry);
}
```