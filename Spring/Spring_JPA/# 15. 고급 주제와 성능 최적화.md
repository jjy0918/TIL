# 15. 고급 주제와 성능 최적화

## 15.1 예외 처리

- JPA의 예외들은 `javax.persistence.PersistenceException`의 자식이며, `RuntimeException`의 자식이다.
- JPA 예외들은 두 가지로 나뉜다.
  - 트랜잭션 롤백을 표시하는 예외
    - 이 예외는 심각한 사항이기 때문에 강제 커밋이 불가능하다.
    - EntityExistsException
    - EntityNotFoundException
    - OptimisticLockException
    - PessimisticLockException
    - RollbackException
    - TransactionRequiredException
  - 트랜잭션 롤백을 표시하지 않는 예외
    - 예외 발생 시 트랜잭션을 커밋할 지 롤백할 지 판단하면 된다.
    - NoResultException
    - NonUniqueResultException
    - LockTimeoutException
    - QueryTimeoutException

### 스프링 프레임워크의 JPA 예외 변환

- 스프링 프레임워크는 JPA의 예외를 스프링 예외로 변환시켜줄 수 있다.
- 기본적으로 JPA는 스프링에 종속적인 기술이 아니기 때문에 별도의 예외가 존재한다.
- JPA의 예외를 그대로 사용할 경우 JPA에 종속적인 코드를 작성해야 하기 때문에 스프링에서는 스프링 예외를 사용하는 것이 좋다.

```java
@Bean
public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {
    return new PersistenceExceptionTranslationPostProcessor();
}
```

- 특정 메소드에서만 예외를 변화시키고 싶지 않으면 throws에 해당 예외를 명시해주면 된다.

### 트랜잭션 롤백 시 주의사항

- JPA에서 트랜잭션 롤백이란, 말 그대로 데이터베이스에 반영된 사항을 롤백하는 것이다.
- 엔티티들의 상태를 복구하는 것이 아니다.
  - 즉, 롤백이 일어나도 엔티티 객체들의 값은 롤백이 되지 않는다.
  - 영속성 컨텍스트 안에 수정된 상태로 남아있게 된다.
- 롤백이 일어날 경우 `EntityManager.clear()` 등을 통해 영속성 컨텍스트를 초기화하거나 새로 만들어서 사용해야 한다.

## 15.2 엔티티 비교

- 같은 트랜잭션이라는 것은 같은 영속성 컨텍스를 사용한다는 것이다.
- 같은 영속성 컨텍스트를 사용한다는 것은 엔티티 조회 시 반환되는 객체 자체가 같다는 것이다.
  - 동일성(객체 주소 비교, ==) 비교가 일치한다는 것이다.
  - 동일성 비교가 일치하기 때문에 당연히 동등성 비교도 일치하게 된다.
- 영속성 컨텍스트가 다를 경우, 같은 데이터라 하더라도 동일성 비교는 실패하지만, 동등성 비교는 성공한다.
  - 영속성 컨텍스트가 다르기 때문에 객체 자체가 달라진다.
- 영속성 컨텍스가 프록시 객체를 반환하는 경우, 프록시를 반환한다.
  - 엔티티 객체의 동등성 비교(equals)를 구현할 때 객체의 타입 비교를 넣는 것은 문제를 발생시킨다.
  - 프록시 객체의 경우 기존 객체를 상속 받아 구현한 것이기 때문에 객체 타입이 같은지 비교하는 것은 문제가 된다.
  - 프록시 객체와 실제 엔티티 객체는 객체 타입이 다르다.
  - 프록시 동등성 비교 시 instanceof를 사용해야 한다.

## 15.4 성능 최적화

### N+1 문제

- N+1 문제는 JPA 사용 중 1개의 데이터 조회 시 조인으로 조회하지 않고 연관된 데이터 N 개를 모두 각각 조회하는 SQL을 실행하는 문제다.
- N+1 문제는 단순히 fetch 값을 LAZY로 설정한다고 해결되지 않는다.
  - LAZY라고 하더라도 결국 모두 조회 시 N번 더 실행된다.
- 해결 방법
  - 패치 조인(JQPL)
  - 하이버네이트 @BatchSize
    - size 만큼 in 절을 통해 조회한다.
  - 하이버네이트 @Fetch(FetchMode.SUBSELECT)
    - 연관 데이터 조회 시 서브 쿼리를 사용하여 조회한다.
- 일반적으로는 fetch 타입을 LAZY로 설정하여 해결할 수 있지만, 그렇지 못하는 경우 위 3가지 방법을 사용하자.

### 읽기 전용 쿼리의 성능 최적화

- 영속성 컨텍스트가 관리하는 엔티티가 많이질 수록 더 많은 메모리가 필요하다.
  - 관리 엔티티가 많아진다는 것은 성능이 안좋아질 수 있다는 것이다.
- 조회한 엔티티가 다시 조회될 일이 없다면, 읽기 전용으로 조회하는 것이 메모리 사용량을 최적화할 수 있다.
- 읽기 전용으로 조회 방법
  - 스칼라 타입으로 조회(엔티티가 아니기 때문에 영속성 컨텍스트가 관리하지 않는다.)
  - 읽기 전용 쿼리 힌트 사용
    - 하이버네이트 전용 힌트(org.hibernate.readOnly) 사용
  - 읽기 전용 트랜잭션 사용
    - 스프링의 트랜잭션은 읽기 전용 모드가 존재한다.
    - 이 트랜잭션에서는 강제로 플러시를 호출하지 않는 이상 플러시가 일어나지 않는다.
  - 트랜잭션 밖에서 읽기

### 트랜잭션을 지원하는 쓰기 지연과 성능 최적화

- 일반적은 DB sql의 경우 하나의 쿼리 실행 시 한 번의 sql을 DB에 전달한다.
- JPA에서는 batch_size 값을 조절하여 한 번에 전달할 sql 숫자를 정할 수 있다.
- JPA에서는 한 번에 sql을 전달할 수 있기 때문에 트랜잭션의 lock 시간을 최소화할 수 있다.
  - JPA에서는 트랜잭션 커밋이 일어나야 플러시가 일어나기 때문에(일반적으로) 그때 쿼리가 전달된다.
  - 즉, update, insert 쿼리가 발생할 경우 생기는 lock을 최소화할 수 있다는 것이다.
  - 일반적으로는 update, insert 등 관련 로직 수행 후 커밋이 일어나기 전까지 lock이 발생한다.