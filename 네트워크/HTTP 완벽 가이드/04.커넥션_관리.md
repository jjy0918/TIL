# 4.커넥션 관리

## 4.1 TCP 커넥션

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- HTTP 커넥션은 일반적으로 TCP 커넥션을 이용한다.(버전에 따라 다르다.)
- TCP 커넥션은 안정적으로 연결을 도와준다.
- TCP 커넥션은 신뢰할 만한 통신 방식을 제공한다.

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.

- TCP는 데이터 전송 시 IP 패킷(IP 데이터그램)으로 나뉘어 전송한다.
- HTTP는 데이터 전송 시 TCP 커넥션을 통해 데이터를 순서대로 보낼 수 있다.
- TCP는 이러한 데이터를 세그먼트 단위로 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아 데이터를 전달한다.

### 4.1.3 TCP 커넥션 유지하기

- TCP는 `발신지 IP 주소`, `발신지 포트`, `수신지 IP주소`, `수신지 포트` 의 4가지 값으로 커넥션을 식별한다.
  - 이 4가지 값들은 일부 같을 수 있지만, 4가지가 모두 같을 수는 없다.

## 4.2 TCP의 성능에 대한 고려

- HTTP는 TCP 위에 있는 계층이기 떄문에 HTTP 트랜잭션은 TCP 성능에 영향을 받는다.

### 4.2.1 HTTP 트랜잭션 지연

- HTTP 트랜잭션에서 지연이 발생하는 이유는 대부분 TCP 네트워크 지연에서 발생한다.
  - URI를 IP와 Port로 변환하는 DNS 과정에서 지연이 발생할 수 있다.
  - 클라이언트가 TCP 커넥션을 서버에 요청한 후 응답을 대기하는 동안 지연이 발생할 수 있다.
  - 커넥션이 연결된 후 데이터를 전송하고 서버가 데이터를 처리하는 지연이 발생할 수 있다.
  - 서버가 HTTP 응답을 보내는 동안 지연이 발생할 수 있다.

### 4.2.2 성능 관련 중요 요소

- TCP 커넥션의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작(slow-start)
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
- TCP의 편승(piggyback) 확인 응답(acknowledgment)을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

- TCP는 커넥션 연결 시 조건을 맞추기 위한 IP 패킷을 교환한다.
  1. 클라이언트는 TCP 커넥션 생성을 위해 생성 요청이라는 뜻의 작은 TCP `SYN` 플래그 패킷(40~60 바이트)을 서버에게 보낸다.
  2. 서버는 `SYN` 패킷을 받으면 커넥션 요청이 받아들였음을 알리는 `SYN`과 `ACK` 플래그 패킷을 보낸다.
  3. 클라이언트는 서버로부터 `SYN`과 `ACK` 패킷을 받으면 커넥션이 잘 연결됨을 알리는 확인응답 신호를 보낸다.
- 매우 작은 크기의 데이터를 전송하기 위해 패킷 교환을 하는 것은 성능 저하를 야기시킨다.
  - 그렇기 때문에 오늘날의 TCP는 3번과정에서 데이터를 같이 전송할 수 있다.
- 대부분의 트랜잭션 지연은 1, 2번 과정에서 발생하게 된다.

### 4.2.4 확인응답 지연

- TCP는 안정적인 데이터 전송을 위해 확인 체계가 존재한다.
  - TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가지고 있다.
  - 각 세그먼트의 수신자는 세그먼트를 받으면 작은 확인응답 패킷을 반환한다.
  - 송신자는 확인응답 패킷을 받지 못하면 문제가 발생했다 판단하여 다시 데이터를 전송한다.
- 확인응답 패킷은 크기가 작기 때문에 데이터 패킷을 같은 방향의 TCP에 편승 시킨다.
  - TCP는 송출 데이터 패킷과 확인응답을 하나로 묶기 때문에 효율적으로 네트워크를 사용한다.
  - 편승을 효율적으로 하기 위해 `확인응답 지연 알고리즘`을 사용한다.
  - 확인응답 지연 알고리즘이란, 확인응답 패킷을 버퍼에 저장해두고 편승을 위한 송출 데이터를 찾는 것이다.
  - 일정 시간동안 찾지 못하는 경우 별도 패킷을 만들어 전송한다.
- 확인응답 지연 기능은 수정하거나 비활성화 할 수 있지만, 주의해야한다.

### 4.2.5 TCP 느린 시작(slow start)

- TCP Slow Start란 처음에는 커넥션 속도를 최대한 제한하고, 성공적으로 전송되면 속도 제한을 높여가는 것이다.
- TCP Slow Start는 TCP가 한 번에 전송할 수 있는 패킷의 수를 제한한다.(전송 성공 시 늘어난다.)
- 그렇기 때문에 새로운 커넥션보다 이미 열려있던 커넥션들이 더 빠르다.

### 4.2.6 네이글(nagle) 알고리즘과 TCP_NODELAY

- 일반적으로 매우 작은 크기의 데이터를 전송하게 되면 매우 비효율적이다.
- 네이글 알고리즘은 이러한 비효율을 개선시켜준다.
  - 패킷을 전송하기 전 많은 양의 TCP 데이터를 한 개의 덩어리로 합친다.
  - 이러한 덩어리가 최대 크기가 되지 않으면 전송하지 않는다.
  - 다만, 패킷이 확인 응답을 받은 경우 크기가 충족되지 않아도 전송한다.
- 네이글 알고리즘도 비효율적인 측면이 존재한다.
  - 작은 패킷들은 크기를 충족시키지 못하기 떄문에 추가 데이터를 기다리며 지연될 수 있다.
  - 확인응답 지연과 같이 쓰이면 효율성이 떨어진다.
- HTTP 애프리케이션은 HTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화할 수 있다.

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- 일반적으로 TCP 커넥션이 종료되면, 해당 커넥션의 IP와 Port를 세그먼트의 최대 생명주기 2배 정도의 시간동안 메모리에 저장한다.
  - 일반적으로 `2MSL` 이라고 불리는 2분 정도 저장된다.
- 메모리에 저장된 IP와 Port를 통해 중복 패킷을 방지한다.
- 커넥션을 구성하는 4가지 중 발신자 포트를 제외한 3가지는 2MSL동안 고정이 된다.
- 즉, 클라이언트는 커넥션을 위해 새로운 포트를 사용해야 하고 그 과정에서 포트 고갈이 발생할 수 있다.

## 4.3 HTTP 커넥션 관리

### 4.3.1 Connection 헤더

- HTTP는 서버와 클라이언트 사이에 여러 중개 서버가 놓이는 것을 허락한다.
- 이러한 중개 서버마다 적용될 커넥션 옵션을 지정할 수 있다.
- HTTP Connection 헤더를 통해 해당 서버가 받아야할 데이터와 다른 서버로 넘기지 말아야 할 데이터를 정할 수 있다.

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- 일반적으로 순차적인 트랜잭션은 성능이 좋지 않다.
- HTTP 커넥션 성능 향상을 위한 최신 기술이 존재한다.
  - 병렬 커넥션
  - 지속 커넥션
  - 파이프라인 커넥션
  - 다중 커넥션

## 4.4 병렬 커넥션

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다.

- 하나의 커넥션이 네트워크 대역폭의 모든 부분을 차지하지 않기 때문에 병렬 커넥션은 일반적으로 더 빠르다.

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다.

- 네트워크 대역폭이 좁을 경우, 병렬 커넥션은 객체를 전송 받는 것도 느리기 때문에 성능상의 장점이 없어진다.
- 또한, 서버에서도 병렬로 처리하게 되면 사용자 수 보다 많은 커넥션이 연결되기 때문에 성능상 문제가 발생한다.
- 브라우저는 대부분 병렬 커넥션을 사용하지만, 적은 수(대부분 6개~8개)만 허용한다.

## 4.5 지속 커넥션

- HTTP/1.1 부터는 처리가 완료되어도 커넥션을 유지하여 재사용할 수 있다.
- 이미 연결된 커넥션을 사용함으로써 커넥션을 맺기 위한 작업 시간을 줄일 수 있다.
- 병렬 커넥션과 지속 커넥션은 같이 사용하면 좋다.

### 4.5.1 HTTP/1.0+의 Keep-Alive 커넥션

- HTTP/1.0+ 에서는 Keep-Alive 옵션을 통해 지속 커넥션을 사용했고, HTTP/1.1에서는 해당 옵션을 제거하고 기본으로 제공한다.

### 4.5.2 Keep-Alive 동작

- Keep-Alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해서 Connection:Keep-Alive 헤더를 포함시켜야 한다.
- Connection:Keep-Alive 헤더가 포함된 데이터를 받은 서버는 커넥션을 유지하기 위해 Connection:Keep-Alive 헤더를 포함한 응답을 한다.
- Connection:Keep-Alive 헤더가 없다면, 서버는 응답 후 커넥션을 종료한다.
- 프록시 서버가 있는 경우 Keep-Alive 옵션 때문에 문제가 발생할 수 있기 때문에 주의가 필요하다.

### 4.5.3 Keep-Alive 옵션

- Keep-Alive 헤더를 받았다고 해서 무조건 커넥션을 유지해야 하는 것은 아니다.
- 다양한 옵션을 통해 커넥션 유지 관련된 설정을 하거나 제한할 수 있다.
- timeout 파라미터: 커넥션이 얼마나 유지될 것인지 의미한다.
- max 파라미터: 이 커넥션이 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지할 것인지 의미한다.
- 이러한 옵션은 요구일 뿐 동작한다는 보장은 없다.

### 4.5.4 HTTP/1.1의 지속 커넥션

- HTTP/1.1 에서는 Keep-Alive 옵션을 제공하지 않고, 더 개선된 지속 커넥션을 기본으로 제공한다.
- HTTP/1.1 에서는 지속 커넥션이 기본이기 때문에 사용하지 않는다는 설정을 할 수 있다.
  - 트랜잭션 후 커넥션을 끊기 위해서 Connection: close를 헤더에 명시해야 한다.
  - 헤더가 없다고 하더라도 클라이언트와 서버는 언제든 커넥션을 끊을 수 있다.

## 4.6 파이프라인 커넥션

- 파이프라인 커넥션은 제약이 많아 기본적으로 비활성화되어 있다.
- HTTP/2 에서는 더 향상된 알고리즘인 멀티플랙싱으로 대체되었다.

## 4.7 커넥션 끊기에 대한 미스터리

### 4.7.1 Content-Length와 Truncation

- HTTP 응답은 본문의 크기은 Content-Length가 필요하다.
- 일부 서버는 커넥션 끊기로 데이터 전송의 끝을 의미하기도 한다.
  - Content-Length를 명시하지 않고 커넥션만 끊음으로써 데이터 전송이 끝이라고 하기 때문에 문제가 발생한다.
  - 클라이언트는 Content-Length가 없기 때문에 데이터 전송이 끝인지 물어봐야 한다.

### 4.7.2 커넥션 끊기의 허용, 재시도 ,멱등성

- 커넥션은 에러가 없더라도 언제든 끊을 수 있다.
- 클라이언트는 커넥션이 끊어질 경우 대비가 필요하다.
  - 트랜잭션 중 커넥션이 끊어지는 경우, 트랜잭션 재시도 등을 통해 다시 커넥션을 맺어야 한다.
  - GET 요청은 괜찮지만, POST류의 경우 트랜잭션 재시도를 통해 문제가 발생할 수 있다.
  - 어떠한 요청에도 항상 같은 결과를 반환하는 `멱등성`이 있는 요청에 대해서는 요청할 수 있다.

### 4.7.3 우아한 커넥션 끊기

- TCP 커넥션은 양방향으로, 입력 큐와 출력 큐가 있다.
- 전체 끊기
  - close() 호출 시 입력과 출력 전체가 끊긴다.
- 절반 끊기
  - shutdown() 호출 시 입력 또는 출력 중 하나만 끊긴다.
  - 예상치 못한 에러를 예방하기 위해 절반 끊기를 사용하는 것이 좋다.
- 우아한 커넥션 끊기는 절반 끊기를 통해 출력 채널을 끊는 것이 좋다.
- 출력 채널을 먼저 끊은 후 주기적으로 입력 채널에 대해 상태 검사를 해야 한다.
