# 8. 통합점: 게이트웨이, 터널, 릴레이

- 웹에서는 기본적으로 HTTP를 사용한다.
- HTTP 외 다른 프로토콜을 사용하는 경우, HTTP로 프로토콜을 감싸서 사용한다.
- 여러 종류의 리소스에 접근하는데 HTTP가 사용될 수 있고, 다른 프로토콜이나 애플리케이션 간 통신에 HTTP가 사용될 수 있다.

## 8.1 게이트웨이

- 웹이 발전됨에 따라 HTTP만으로 모든 컨텐츠와 데이터를 처리할 수 없기 때문에 게이트웨이가 고안되었다.
- `게이트웨이`는 리소스와 애플리케이션을 연결하는 역할을 한다.
- 게이트웨이는 요청을 받고 응답을 보낼 수도 있고, 동적인 콘텐츠 생성이나 데이터 베이스 질의를 보낼 수도 있다.
- 게이트웨이는 트래픽을 다른 프로토콜로 자동 변환하여 HTTP가 다른 프로토콜을 알지 못해도 통신할 수 있도록 도와준다.
  1. HTTP/FTP 서버 측 FTP 게이트웨이
     - HTTP 클라이언트 <-> 게이트웨이 <-> FTP 서버
     - 게이트웨이는 클라이언트로부터 FTP URL을 가리키는 HTTP 요청을 받는다.
     - 게이트웨이는 FTP 커넥션을 맺고 FTP 서버에 적절한 명령을 전송한다.
     - 클라이언트는 게이트웨이로부터 FTP 결과를 HTTP로 받는다.
  2. HTTPS/HTTP 클라이언트 측 보안 게이트웨이
     - HTTPS 클라이언트 <-> 게이트웨이 <-> 웹 서버
     - 게이트웨아는 SSL 요청을 받는다.
     - 게이트웨이는 HTTP 요청을 웹 서버에 보낸다.
     - 클라이언트는 게이트웨이로부터 웹 서버의 응답을 HTTPS로 받는다.
  3. HTTP/CGI 서버 측 애플리케이션 게이트웨이

### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

- 웹 게이트웨이는 HTTP와 HTTP 외 다른 프로토콜로 통신하기 때문에 빗금(/)으로 프로토콜을 구분한다.
- `<클라이언트 프로토콜>/<서버 프로토콜>`
  - HTTP와 NNTP 뉴스 서버인 경우 => HTTP/NNTP
- 클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜 통신을 하고, 서버와는 HTTP로 통신한다.(타프로토콜/HTTP)
- 서버 측 게이트웨이는 클라이언트와 HTTP 통신을 하고, 서버와는 외래 프로토콜로 통신한다.(HTTP/타프로토콜)

## 8.2 프로토콜 게이트웨이

- `HTTP/*` 형태의 서버 측 웹 게이트웨이는 HTTP 요청을 타 프로토콜로 변환하여 처리한 후 결과를 HTTP로 리턴한다.
- `HTTP/HTTPS` 형태의 서버 측 보안 게이트웨이는 내부적으로 요청을 암호화하여 통신한다.
- `HTTPS/HTTP` 형태의 클라이언트 측 보안 가속 게이트웨이는 사용자 요청만 HTTPS로 처리하고, 내부 요청은 HTTP 요청을 한다.

## 8.3 리소스 게이트웨이

- 게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합한다.
- 애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고 서버 측 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이다.
- 애플리케이션 게이트웨이에서 최초의 API는 공용 게이트웨이 인터페이스(Common Gateway Interface, CGI)이다.
  - CGI는 특정 URL 요청에 따라 프로그램을 실행하여 출력을 수집하고 결과로 리턴한다.

### 8.3.1 공용 게이트웨이 인터페이스(CGI)

- CGI는 사용자에게 내부적 로직을 보여주지 않고, 단순한 요청만 한다.
- 다만, CGI는 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형이든 처리해내는 단순한 기능을 제공한다.
- 이러한 확장은 문제가 많은 확장으로부터 서버를 보호한다는 점에서 훌륭하다.
- 다만, CGI는 요청마다 새로운 프로세스를 만들기 때문에 부하가 크다.
- 이러한 문제를 해결하기 위해 데몬으로 동작하는 Fast CGI가 개발되었다.

### 8.3.2 서버 확장 API

- 서버 확장 API를 통해 서버 자체의 동작을 바꾸거나 서버 처리능력을 향상시킬 수 있다.
- 확장 API는 프로그래머가 자신의 코드를 서버에 연겨하거나 서버의 컴포넌트를 자신이 만든 것으로 교체할 수 있게 도와준다.
- 마이크로소프트, 넷스케이프, 아파치 등 서버들은 확장 API를 제공한다.

## 8.4 애플리케이션 인터페이스와 웹 서비스

- 데이터를 교환하기 위해 HTTP를 사용하지만, HTTP 헤더로는 표현하기 힘든 데이터들도 있다.
- 인터넷 커뮤니티는 각 웹 애플리케이션이 서로 통신하는데 사용할 표준과 프로토콜 집합을 개발하였다.
- 웹 서비스라고 불리는 이러한 것은 HTTP 같은 웹 표준 웹 기술 위에서 개발된다.
- SOAP을 통해 XML을 사용하여 정보를 교환하거나, REST를 사용하거나, JSON을 사용하여 데이터를 전송한다.

## 8.5 터널

- 웹 터널이란 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방식을 제공하는 것이다.
- 즉, 터널을 이용하면, HTTP 커넥션을 통해 HTTP가 아닌 트래픽을 전송할 수 있다.

### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

- 웹 터널은 HTTP의 CONNECT 메서드를 사용하여 커넥션을 맺는다.
- CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺은 후 데이터를 무조건 전달하기를 요청한다.

#### CONNECT 요청

- CONNECT 요청은 시작줄을 제외하고는 HTTP 메서드와 같다.
- 요청 URI는 호스트 명이 대신하며, 콜론에 이어 포트를 기술한다.
- 시작줄 다음에는 다른 HTTP 메시지와 같이, 추가적인 HTTP 요청 헤더 필드가 있거나 없다.

#### CONNECT 응답

- 일반적인 HTTP 메시지와 같이 성공시에는 200 응답 코드를 리턴한다.
- 일반적으로 사유 구절에는 `Connection Establish`로 기술한다.
- 일반적인 HTTP 응답과 달리 Content-Type헤더를 포함할 필요가 없다.

```HTTP
// CONNECT 요청
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/4.0

// CONNECT 응답
HTTP/1.0 200 Connection Established
Proxy-agent: Netscape-Proxy/1.1

```

### 8.5.2 데이터 터널링, 시간, 커넥션 관리

- 터널이 연결되면, 게이트웨이는 터널을 통해 전달되는 데이터를 확인할 수 없다.
- 게이트웨이는 커넥션이 맺어지는 대로 헤더를 포함하여 읽어들인 데이터를 서버에 전송한다.
- 요청 후 터널을 통해 데이터를 전송한 클라이언트는 200외 인증요구등의 응답이 왔을 때 요청 데이터를 다시 보낼 준비가 되어 있어야 한다,


### 8.5.3 SSL 터널링

- 터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하기 위해 개발되었다.
- SSL과 같은 암호화 프로토콜은 낡은 방식의 프락시에서는 처리되지 않기 때문이다.
- 터널을 사용하면, SSL 트래픽을 HTTP 커넥션으로 전송하여 HTTP만 처리할 수 있어도 통신할 수 있게 된다.
- 터널을 통해 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 된다.

### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

- HTTP/HTTPS에는 몇 가지 단점이 존재한다.
  1. 클라이언트-게이트웨이에는 보안이 적용되지 않은 HTTP 통신을 하게 된다.
  2. 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할 수 없다.
  3. 게이트웨이는 SSL을 완벽하게 지원해야 한다.
- SSL 터널링을 사용하면, 프락시에 SSL을 구현할 필요가 없고, 프락시가 트랜잭션의 보안에 전혀 관여하지 않아도 된다.


### 8.5.5 터널 인증

- 프락시 인증 기능을 통해, 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수 있다.
- CONNECT 요청이 오는 경우, 인증요구를 반환하고 인증이 된 경우에만 CONNECT 요청을 서버에 전송한다.

## 8.6 릴레이

- 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달한다.
- 맹목적 릴레이가 Connection 헤더를 제대로 처리하짐 못하는 경우 keep-alive 커넥션이 행(hang)에 걸리는 문제가 발생할 수 있다.
  - 클라이언트와 서버는 keep-alive 헤더를 통해 커넥션을 끊지 않고 데이터를 요청하게 된다.
  - 릴레이 서버는 keep-alive를 모르기 때문에 요청을 전달한 후 커넥션이 종료되기만을 기다린다.
