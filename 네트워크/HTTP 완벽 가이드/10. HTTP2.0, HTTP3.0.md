# 10. HTTP/2.0, HTTP/3.0

## 10.1 HTTP/2.0의 등장과 배경

- HTTP/1.1은 기본적으로 하나의 요청에 하나의 응답을 받는다.
- 즉, 새로운 요청을 보내기 위해서는 그 전 요청에 대한 응답을 받아야만 요청을 보낼 수 있다.
- 이러한 특성 때문에 성능상 latency를 피할 수 없었다.
- HTTP/2.0은 이러한 속도를 향상시키기 위해 고안되었고, SPDY를 기반으로 설계되었다.
  - SPDY는 구글의 더 빠른 웹을 위한 실험적인 프로토콜이다.
  - SPDY는 RTT(Rount-tip delay time)가 20ms인 상황에서 12.34%의 성능 개선 효과가 있었다.
- 기본적으로 SPDY의 특징을 그대로 유지하고 있고, 달라전 사항으로는 deflate 알고리즘을 사용하지 않는 것이다.

## 10.2 개요

- HTTP/2.0은 기본적으로 TCP 커넥션 위에서 동작한다.
- TCP 커넥션을 초기회하는 것은 클라이언트가 담당한다.
- 요청과 응답은 길이(최대 16383 바이트)가 정의된 한 개 이상의 `프레임`에 담기고, 헤더는 압축되어 담기며 이러한 프레임들은 `스트림`을 통해 전달된다.
  - 한 개 이상의 스트림은 한 쌍의 요청&응답을 처리한다.
  - 하나의 커넥션 위에 여러 스트림이 생성될 수 있기 때문에 여러 개의 요청과 응답을 동시에 처리할 수 있다.
  - 이러한 스트림에 대한 흐름 제어와 우선 순위 부여 기능도 존재한다.
- 기존과 다른 특징 중 하나는 `서버측 푸시` 기능이다.
  - 이 기능을 이용하면, 클라이언트가 요청하지 않아도 서버측에서 리소스를 보내줄 수 있다.
- 기존 HTTP/1.1과의 호환성을 위해 기본적으로 요청과 응답 메시지의 의미는 같도록 유지되어 있다.
  - 다만, 이러한 것들을 표현하는 문법에는 변화가 있다.
  - Content-Length는 :content-lentgh로 404 Not Found는 :status 헤더의 404로 변경되는 등의 변화가 존재한다.
  
## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

- 기본적으로 HTTP/2.0의 모든 메시지는 프레임에 담겨 전송된다.
  - 프레임은 8바이트 헤더로 시작하고 최대 16383바이트의 페이로드로 구성되어 있다.
- 프레임의 종류는 DATA, HEADERS, PRIORITY, RST_STREAM 등 10가지가 존재한다.
  - 각 프레임은 페이로드 형식이나 내용이 다르다.

### 10.3.2 스트림과 멀티플렉싱

- 스트림을 통해 전송되는 프레임들은 모두 독립된 양방향 시퀀스이다.
- 클라이언트측에서 스트림을 생성하여 요청을 보내면, 서버측은 그 스트림에 응답을 보낸 후 스트림은 닫힌다.
  - 즉, 커넥션은 지속적으로 연결되어 있고 스트림만 생성되고 닫히게 된다.
  - 스트림은 무제한으로 열리지는 않고, SETTINGS 프레임의 SETTINGS_MAX_CONCURRENT_STREAMS 매개변수 값을 조절하여 스트림 수를 제한할 수 있다.
- 스트림은 우선순위를 가질 수 있다.
  - 리소스의 중요도에 따라 먼저 전달되어야 하는 우선순위 설정이 가능하다.
  - 다만, 우선순위대로 처리 된다는 보장은 없다.
- 모든 `스트림`은 `31비트`의 무부호로 구성된 `고유한 식별자`를 가진다.
  - 기본적으로 `초기화된 쪽(클라이언트)`는 식별자가 `홀수`이어야 하고, `서버`측은 `짝수`이어야 한다.
  - 새로 만들어지는 스트림의 식별자들은 기존에 만들어진 스트림의 식별자들보다 반드시 커야 한다.
  - 커넥션이 오래 지속되어 스트림이 많이 만들어진 경우 식별자가 부족해질 수 있는데, 이러한 경우 커넥션을 다시 연결하면 된다.
- TCP 커넥션은 맺어질 때 3-wayhandshake 등의 과정을 통해 패킷을 주고 받아야 하지만, 스트림은 그러한 과정이 없다.
  - 기본적으로 스트림의 생성은 초기화하는 측에서 일방적으로 만든다.

### 10.3.3 헤더 압축

- HTTP/1.1에서는 헤더 압축을 진행하지 않고 그대로 전송했지만, HTTP/2.0에서는 헤더 압축을 진행한다.
- SPDY 프로토콜에서는 deflate 알고리즘을 이용하여 헤더를 압축했지만, 취약점이 발견되어 HPACK명세에 따라 압축을 진행한다.
  - HPACK은 헤더를 압축, 해제할 때 압축 콘텍스트(compression context)를 사용한다.
  - 즉, 올바른 압축을 위해서는 압축 콘텍스트를 유지해야 한다.
  - 압축 콘텍스트는 수신한 헤더의 압축을 풀면, 이에 영향을 받아 변경된다.
  - 즉, 송신한 측은 수신한 측이 압축을 풀었다고 가정하여 압축 콘텍스트를 변경하여 다음 헤더를 압축한다.
  - 그렇기 때문에 수신한 측은 반드시 압축을 해제해야 한다.
- 압축을 한 후 헤더 블록 조각들로 쪼개어 전송하게 된다.

### 10.3.4 서버 푸시

- HTTP/2.0은 하나의 요청에 대해 여러 리소스를 응답으로 보낼 수 있도록 지원한다.
- 예를 들어, 클라이언트 요청이 들어왔을 때 서버는 HTML, CSS, JS 요청을 각각 푸시해서 전송할 수 있다.
- 이러한 기능을 통해 클라이언트측에서 서버로 요청 하는 리소스를 줄일 수 있다.
- 리소스를 푸시하기 위해서 `서버`는 `클라이언트`에게 `PUSH_PROMISE 프레임`을 미리 보내야 한다.
  - PUSH_PROMISE 프레임을 받은 클라이언트는 해당 스트림으로 푸시받을 수 있도록 예상한다.
  - 클라이언트가 `푸시 거절`을 하기 위해서는 `RST_STREAM 프레임`을 전송하면 된다.
  - RST_STREAM 프레임을 받게 되면, 그 스트림은 닫히게 된다.

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격(Intermediary Encaptulation Attacks)

- HTTP/2.0의 메시지를 중간 프락시가 HTTP/1.1 메시지로 변환하는 경우 메시지 의미가 변질될 수 있다.
- HTTP/2.0은 헤더를 바이너리로 인코딩하기 때문에 헤더 필드로 어떠한 문자도 사용할 수 있다.
  - 즉, HTTP/2.0에서 받은 헤더를 비정상적인 HTTP/1.1 헤더로 변경될 수 있다는 것이다.
- HTTP/1.1에서 HTTP/2.0으로 변환하는 과정에서는 이러한 문제가 발생하지는 않는다.

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

- HTTP/2.0은 기본적으로 커넥션을 오래 연결하기 때문에 개인정보 누출이 될 수 있기 때문에 주의가 필요하다.

## 10.5 HTTP/3.0

### 10.5.1 TCP에서 UDP로

- HTTP/2.0 까지는 TCP를 이용하였지만, HTTP/3.0부터는 UDP기반의 `QUIC` 프로토콜을 이용한다.
  - QUIC(Quick UDP Internet Connection)은 구글에서 개발한 프로토콜이다.
- 기존 HTTP/1.1이하에서는 TCP 커넥션을 요청, 응답마다 맺고 끊었기 때문에 비효율적이었다.
  - TCP는 기본적으로 연결할 때 3-way, 끊을 때 4-way 과정이 필요하기 때문에 패킷 이동이 많다.
- HTTP/2.0에서는 TCP 커넥션을 한 번만 연결하고 요청, 응답마다 스트림을 생성하였지만, 여전히 커넥션 연결시 비효율적이다.
- QUIC은 기본적으로 UDP를 사용하기 때문에 handShake 과정을 생략하게 되고 신뢰성을 해결하기 위해 여러 장치를 사용하였다.
- 또한, TCP를 이용하는 경우 HOLB(Head of Line Blocking) 문제가 발생할 수 있다.
  - 기본적으로 TCP는 신뢰성 있는 통신을 하기 때문에 패킷이 유실되면, 다음 패킷으로 넘어가지 않는다.


### 10.6.2 QUIC

- UDP는 기본적으로 데이터그램 방식을 사용하기 때문에 각각 패킷이 독립적이다.
- 또한, UDP는 패킷 구조가 단순하기 때문에 `커스터마이징이 쉽다`.
  - 패킷 구조를 변경함에 따라 TCP 처럼 신뢰성 있는 통신도 가능하다.
  - UDP의 헤더에는 출발지, 도착지, 패킷 길이, 체크섬과 같은 간단한 값들만 존재한다.
  - TCP의 경우 handshake 과정이 필수고, 여러 헤더들이 이미 정의되어 있기 때문에 커스터마이징이 힘들다.
- QUIC의 경우 TCP와 달리 처음 커넥션을 맺을 때 `연결 정보를 모두 전달`하는 방식을 사용한다.
  - TCP와 TLS를 사용하는 경우, 패킷들을 전송하여 인증된 사용자인지 검증을 시도한다.
  - QUIC의 경우 인증 정보가 담긴 값을 처음에 모두 전송한다.
  - 처음에는 커넥션 ID 값을 모르기 때문에 이 값을 사용한 특별한 Initail key를 전달하는 방식을 사용한다.
    - 이러한 Initail Key를 서버는 캐싱해놓았다가 전송 시 사용한다.
- QUIC은 `패킷 순서에 대한 번호를 저장`하는 방식을 사용하는 등의 `5가지 방법`을 통해 손실을 방지한다.
- 또한 기본적으로 `멀티플렉싱` 방식도 제공된다.
- TCP의 경우 IP와 Port로 연결을 식별하기 때문에 IP:Port 가 변경되는 경우 커넥션이 유지가 되지 않지만, QUIC은 `Connection ID`를 이용하여 `커넥션을 식별`하기 때문에 유지된다.

> HTTP/3.0 출처 : https://evan-moon.github.io/2019/10/08/what-is-http3/
