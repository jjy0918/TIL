# 13. 다이제스트 인증

- 기본 보안은 단순히 base64로 인코딩 되었기 때문에 안전하지 않다.
- 기본 보안을 안전하게 이용하기 위해서 다이제스트 인증과 SSL을 결합하여 사용해야 한다.
- 다이제스트 인증은 기본 인증과 호환되는 더 안전한 이증 방식이다.

## 13.1 다이제스트 인징의 개선점

- 다이제스트의 특징
  - 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
  - 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
  - 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
  - 그 외 몇몇 잘 알려진 형태의 공격을 막는다.
- 다이제스트 인증이 잘 사용되지는 않지만, 기본 보안 보다는 안전한 것은 확실하다.

### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기

- 다이제스트 인증은 비밀번호를 비가역적으로 뒤섞은 지문(fingerprint) 혹은 요약(digest)을 보낸다.
- 다이제스트 동작 원리
  1. 클라이언트가 보호된 문서를 요구
  2. 서버는 클라이언트에게 사용자 이름과 요약된 형태의 비밀번호를 요구한다.
  3. 클라이언트는 서버에게 사용자 이름과 요약된 형태의 비밀번호를 전송한다.
  4. 서버는 클라이언트가 제공한 정보를 바탕으로 일치하는지 판단한다.
- 다이제스트 인증 과정을 통해 비밀번호 그 자체는 전달되지 않고, `비밀번호로부터 요약된 정보`만 전달된다.

### 13.1.2 단방향 요약

- 요약을 통해 입력값을 일정한 크기의 데이터로 변환한다.
  - MD5는 임의의 바이트 배열을 원래 길이와 상관 없이 128비트로 요약 변환한다.
- 요약 함수는 보통 암호 체크섬으로 불리며, 단방향 해시 함수이거나 지문 함수이다.

### 13.1.3 재전송 방지를 위한 난스(nonce) 사용

- 요약 정보는 인증에 대한 암호를 뜻하기 때문에 악의적인 집단들은 요약 정보를 탈취하여 재전송 공격에 사용할 수 있다.
- 그렇기 때문에 재전송 공격을 방지하기 위해 난스(nonce)라 불리는 특별하고 자주 바뀌는 요약 정보를 보낸다.
- 다이제스트는 난스를 사용할 것을 권장한다.
- 난스는 WWW-Authenticate 인증요구에 담겨서 서버에서 클라이언트로 넘겨진다.

### 13.1.4 다이제스트 인증 핸드셰이크

1. 서버는 다이제스트 인증 시 난스 값을 계산한다.
2. 서버는 난스를 WWW-Authenticate 인증 요구 메시지에 담아 알고리즘 목록과 함께 클라이언트에게 전달한다.
3. 클라이언트는 알고리즘을 선택하고 비밀번호와 그 외 데이터의 요약을 계산한다. 그 값을 Authorization에 담아 서버로 전송한다.
   - 클라이언트가 서버의 인증을 하기 위해 난스를 보낼 수 있다.
4. 서버는 클라이언트가 선택한 알고리즘을 바탕으로 요약을 계산하여 정상적인지 판단한다.

## 13.2 요약 계산

### 13.2.1 요약 알고리즘 입력 데이터

- 단방향 해시 함수 H(d)
- 요약 함수 KD(s, d)
  - s는 secret, d는 data
- 비밀번호 등 보안 정보를 담고 있는 데이터 덩이리 A1
- 요청 메시지 중 비밀이 아닌 정보를 담고 있는 데이터 덩어리 A2

### 13.2.2 H(d)와 KD(s, d) 알고리즘

- 다이제스트 인증은 여러 요약 알고리즘을 선택할 수 있다.
- RFS-2617에서 제안한 알고리즘은 MD5와 MD5-sess이다.
- 기본 값은 MD5이다.

### 13.2.3 보안 관련 데이터(A1)

- A1은 비밀 정보와 관련된 데이터를 의미한다.
- A1은 H, KD, A2와 마찬가지로 요약을 계산하기 위해 사용된다.
- MD5에서 A1은 사용자 이름, 영역, 비밀번호를 콜론으로 연결한 것이다.
  - A1 = <사용자>:<영역>:<비밀번호>
- MD5-sess에서 A1은 사용자 이름, 영역, 비밀번호에 대한 해시 값을 현재 난스와 클라이언트 난스를 붙인 것이다.

### 13.2.4 메시지 관련 데이터(A2)

- A2는 URL, 요청 메시지, 메시지 엔터티 본문과 같은 메시지 자체 정보를 나타낸다.
- A2는 메서드, 리소스, 메시지의 위조를 방지하기 위해 사용된다.
- A2은 H, KD, A1와 마찬가지로 요약을 계산하기 위해 사용된다.
- RFC 2617에 두 가지 사용법이 정의되어 있다.
  - HTTP 요청 메서드와 URL만 포함하기.
    - 기본 값으로 사용된다.
    - qop="auth"일 때 사용된다.
  - 메시지 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가한다.
    - qop = "auth-int"일 때 사용된다.

### 13.2.5 사전(preemptive)인가

- 일반적으로 인증에서는 트랜잭션이 완료되기 전 요청/인가 요구 사이클이 필수적이다.
- 다음 난스가 어떤 값인지 알 수 있다면 서버가 물어보기 전 Authorization 헤더를 생성하여 요청/인가 요구 사이클을 생략할 수 있다.
- 다음 난스 미리 생성하기
  - 서버가 Authentication-Info 성공 헤더를 통해 다음 난스 값을 미리 제공할 수 있다.
  - 다음 난스를 통해 클라이언트는 Authorization 헤더를 미리 만들어 둘 수 있다.
  - 난스를 미리 생성하여 요청/인가 사이클은 벗어나지만, 다중 요청을 하는 파이프라이닝은 쓸모가 없어진다.
- 제한된 난스 재사용
  - 난스를 제한적으로 재상용할 수 있도록 설정할 수 있다.
  - WWW-Athenticate:stale=true 지시어를 통해 설정을 한다.
  - 클라이언트는 미리 난스를 알 수 있지만, 재전송 공격에 취약해진다.
- 동기화된 난스 생성
  - 미리 공유된 비밀키에 기반하여 클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록 시간적으로 동기화된 난스 알고리즘을 사용할 수 있다.

### 13.2.6 난스 선택

- RFC 2617 에서는 난스 공식으로 `BASE64(타임스탬프 H(타임스탬프 ":" Etag ":" 개인키))`를 제안한다.
