# 15. 엔터티와 인코딩

## 15.1 메시지는 컨테이너, 엔터티는 화물

- HTTP 메시지를 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 실질적인 화물이다.
- HTTP 엔터티는 엔터티 헤더와 엔터티 본문으로 구성되어 있다.
  - 엔터티 헤더에는 Content-Type, Content-Length, Content-Language, Content-Encoding 등이 있다.

### 15.1.1 엔터티 본문

- 엔터티의 본문은 가공되지 않은 데이터만을 담고 있다.
- 엔터티에 대한 정보는 모두 엔터티 헤더에 담겨 있다.
  - 엔터티 헤더를 통해 엔터티 본문이 어떠한 데이터를 의미하는지 담아 보내야 한다.
  - 예를 들어 Content-Type은 엔터티 본문을 어떻게 해석해야 하는지 정보를 담고 있다.
- 엔터티 헤더와 본문은 빈 CRLF 줄로 구분된다.
- 엔터티 본문의 콘텐츠는 텍스트, 바이너리, 문서, 이미지 등 모든 것이 가능하다.

## 15.2 Content-Length: 엔터티의 길이

- 엔터티 헤더 중 Content-Length는 엔터티 본문의 크기를 바이트 단위로 나타낸다.
- 메시지를 청크 인코딩으로 전달하지 않는 이상 엔터티 본문을 포함하는 메시지에서는 필수적이다.
- Content-Length를 통해 메시지가 잘렸는지 확인이 가능하고, 분할하여 메시지를 보낼 수 있게 도와준다.

### 15.2.1 잘림 검출

- HTTP가 발전함에 따라 커넥션이 지속적으로 연결되기 때문에 메시지가 끝났는지, 잘렸는지 검출할 필요가 생겼다.
- 클라이언트는 메시지 잘림을 검출하기 위해 Content-Length를 사용할 수 있다.
- 메시지 잘림은 클라이언트뿐만 아니라 서버측에사도 취약하다.
  - 특히 캐싱을 하는 프락시 서버의 경우에는, 잘못된 컨텐츠를 캐싱할 수 있으니 Content-Length를 통해 잘림 검출을 확인할 필요가 있다.

### 15.2.2 잘못된 Content-Length

- Content-Length가 잘못된 경우 큰 피해를 유발할 수 있다.
- 그렇기 때문에 HTTP/1.1 부터는 사용자 에이전트는 잘못된 길이를 받고 그 사실을 인지한 경우 사용자에게 알려주게 되어 있다.

### 15.2.3 Content-Length와 지속 커넥션

- 지속 커넥션에선 Conent-Length는 필수적이다.
- 하나의 커넥션에서 한 메시지가 끝나면, 그 다음 메시지가 바로 전송되는데, Content-Length가 없다면 문제가 발생할 수 있다.
- 청크 인코딩을 사용하는 경우 Content-Length가 없을 수 있다.

### 15.2.4 컨텐츠 인코딩

- 콘텐츠가 압축되거나 인코딩된 경우 원본 Content-Length가 아니라, 진짜 전송 되는 Content-Length를 전송해야 한다.

### 15.2.5 엔터티 본문 길이 판별 규칙

- 이 규칙은 반드시 나열된 순서대로 적용되어야 한다.

1. HEAD와 같이 본문을 갖는 것이 허용되지 않는 타입의 경우 Content-Length는 무시된다.
2. 메시지가 Transfer-Encoding 헤더를 포함한다면, 메시지 커넥션이 끊기지 않는 이상 0 바이트 청크라는 특별한 패턴으로 끝나야 한다.
3. 메시지가 Content-Length를 갖는다면, 본문 크기의 Content-Length를 가져야 한다.
4. 메시지가 multipart/byteranges 미디어 타입을 사용하고, Content-Length가 없다면 메시지의 각 부분은 스스로 길이를 결정한다.
5. 위 어떤 규칙도 해당하지 않는다면, 커넥션이 끊길 때 엔터티는 닫힌다.
6. HTTP/1.0과 호환을 위해 HTTP/1.1 요청은 반드시 유효한 Content-Length를 전달해야 한다.

## 15.3 엔터티 요약

- 엔터티가 변화되었는가를 판단하기 위해 Content-MD5 헤더와 함께 체크섬 검사를 할 수 있다.
- Content-MD5 기본적으로 암호화가 아니기 때문에 안전과는 다르다.

### MD5란

> https://ko.wikipedia.org/wiki/MD5

- MD5(Message-Digest algorithm 5)는 128비트 암호화 해시 함수이다.
- RFC 1321로 지정되어 있으며, 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사 등에 사용된다.
- 현재는 MD5 알고리즘을 보안 관련 용도로 쓰는 것은 권장하지 않으며, 심각한 보안 문제를 야기할 수도 있다

## 15.4 미디어 타압과 Charset

- Content-Type에는 엔터티 본문의 MIME 타입을 기술한다.
- MIME 타입이란 전달되는 데이터 기저 형식의 표준화된 이름이다.
- MIME 타입은 `{주 미디어 타입}/{구체적인 미디어 타입}` 으로 구성된다.
  - text/html, text/plain, image/gif, multipart/byteranges 등
- Content-Type은 본문의 미디어 타입을 명시하기 때문에 인코딩을 거친 경우에도 본문의 타입을 명시한다.

### 15.4.1 텍스트 매체를 위한 문자 인코딩

- Content-Type은 비트 집합을 텍스트 파일의 글자로 변환하기 위한 chartset 매개 변수도 제공한다.

## 15.5 콘텐츠 인코딩

- HTTP 애플리케이션은 콘텐츠를 인코딩하여 보낼 수 있다.

### 15.5.1 콘텐츠 인코딩 과정

1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
2. 콘텐츠 인코딩 서버는 인코딩된 메시지를 생성한다.(Content-Type은 같지만, Conent-Length는 다르다.)
3. 수신측은 인코딩 데이틀 받아 디코딩하여 원본을 얻는다.

### 15.5.2 콘텐츠 인코딩 유형

- HTTP에서는 표준 인코딩 유형과 확장 인코딩 유형을 제공한다.
- gzip, compress, deflate, identity 등의 표준 인코딩 유형이 존재한다.

### 15.5.3 Accept-Encoding 헤더

- 클라이언트는 서버측에 자신이 선호하는 인코딩 방식을 Accept-Encoding 헤더를 통해 전달할 수 있다.
- Accpet-Encoding 헤더가 포함되지 않거나 *을 전달하는 경우 어떤 인코딩이든 받아들일 수 있는 것으로 간주된다.

## 15.6 시간에 따라 바뀌는 인스턴스와 델타 인코딩

- 같은 리소스(URL)이라도 시간에 따라 다른 인스턴스를 받을 수 있다.
- 클라이언트는 리소스가 캐싱되어 있지 않거나, 만료가 된 경우 서버에 리소스를 요청한다.
- 리소스가 존재하고, 만료가 되지 않았다면 캐싱된 리소스를 사용한다.
- 서버는 리소스 요청이 온 경우, 리소스의 일부가 바뀌든 전체가 바뀌든 리소스를 전달한다.
- 델타 인코딩은 이렇게 리소스 요청 시 전체를 보내는 것 보다는 사본에서 변경된 부분만 전달하는 프로토콜이다.
- 클라이언트는 델타(변경된 부분)을 받아들이기 위해 어떠한 알고리즘을 적용할 수 있는지 서버에게 전달해야 한다.
- 델타 인코딩은 전송 시간을 줄일 수 있지만, 사본을 모든 클라이언트가 캐싱하고 있어야 하고 서버는 차이점을 계산해야 하기 때문에 구현이 까다로울 수 있다.
  - 서버는 사본을 모두 가지고 있어야 한다.

## 15.7 범위 요청

- HTTP는 문서 일부분이나 특정 범위만 요청할 수 있는 기능을 제공한다.
