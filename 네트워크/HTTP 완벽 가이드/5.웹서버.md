# 5. 웹서버

## 5.1 다채로운 웹 서버

- 웹 서버란 웹 서버 소프트웨어와 웹페이지 제공에 특화된 장비 양쪽 모두를 가리킨다.
- 웹 서버는 HTTP 요청을 처리하고 응답을 제공한다.

### 5.1.1 웹 서버 구현

- 웹 서버는 HTTP 및 그와 관련된 TCP 처리와 웹 리소스 관리, 웹 서버 관리 기능을 제공한다.
- 웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.

### 5.1.2 다목적 소프트웨어 웹 서버

- 다목적 소프트웨어 웹 서버는 네트워크에 연결된 표준 컴퓨터 시스템에서 동작한다.
  - 아파치 등
- 웹 서버 소프트웨어는 거의 모든 컴퓨터와 운영체제에서 동작한다.

### 5.1.3 임베디드 웹 서버

- 임베디드 웹 서버는 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버다.
  - 프린터, 가전제품 등

## 5.2 진짜 웹 서버가 하는 일

1. 커넥션을 맺는다.

- 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다.

2. 요청을 받는다.

- HTTP 요청 메시지를 네트워크로부터 읽어 들인다.

3. 요청을 처리한다.

- 요청 메시지를 해석하고 행동을 취한다.

4. 리소스에 접근한다.

- 메시지에서 지정한 리소스에 접근한다.

5. 요청을 만든다.

- 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.

6. 응답을 보낸다.

- 응답을 클라이언트에게 돌려준다.

7. 트랜잭션을 로그에 남긴다.

- 로그파일에 트랜잭션 완료에 대한 기록을 남긴다.

## 5.3 단계 1: 클라이언트 커넥션 수락

- 이미 커넥션이 열려 있다면 해당 커넥션을 사용하면 되지만, 그렇지 않다면 새 커넥션을 열 필요가 있다.

### 5.3.1 새 커넥션 다루기

- 클라이언트가 웹 서버에 TCP 요청을 하면, 웹 서버는 커넥션을 맺고 IP 주소를 추출하여 클라이언트를 확인한다.
- 커넥션이 맺어지면, 서버는 새 커넥션을 커넥션 목록에 추가하고 대기한다.
- 웹 서버는 클라이언트 IP 주소나 호스트명을 통해 인가되지 않았거나 악의적인 경우 커넥션을 닫을 수 있다.

### 5.3.2 클라이언트 호스트명 식별

- 웹 서버는 클라이언트 호스트 명을 구체적인 접근 제어와 로깅을 위해 사용할 수 있다.
  - 하지만, 호스트 명 분석은 오랜 시간이 걸릴 수 있기 때문에 대용량의 경우 꺼놓거나 특정 컨텐츠에서만 켜놓는다.

### 5.3.3 ident를 통해 클라이언트 사용자 알아내기

- 특정 웹 서버는 IETF ident 프로토콜을 지원하여 어떤 사용자 이름이 HTTP 커넥션을 초기화 했는지 찾아낼 수 있게 도와준다.
- ident는 클라이언트의 TCP 113번 포트를 이용하여 정보를 주고 받는다.
- 클라이언트에서 identd 프로토콜을 설치하지 않았거나 방화벽에 막히는 등 다양한 이유로 잘 동작하지는 않는다.
- 아파치 웹 서버의 경우 IdentitiyCheck를 통해 ident 룩업을 상요하게 할 수 있다.
  - ident 정보가 없다면, ident 로그 필드를 하이픈(-)으로 채운다.

## 5.4 단계 2: 요청 메시지 수신

- 커넥션을 통해 데이터가 도착하면 웹 서버는 데이터를 읽고 파싱하여 메시지를 구성한다.
- 메시지 구성 과정
  1.  요청줄을 파싱하여 메서드, URI, 버전 번호를 찾는다.
  2.  메시지 헤더를 읽는다.
  3.  요청 본문을 읽는다.
- 웹 서버는 입력 데이터를 네트워크로부터 불규칙적으로 받기 때문에 파싱이 가능한 수준까지 일부 데이터를 임시로 저장할 수 있어야 한다.

### 5.4.1 메시지의 내부 표현

- 몇몇 웹 서버는 요청 메시지를 쉡게 다룰 수 있도록 내부의 자료구조에 저장한다.
- 자료구조에는 메시지의 각 조각에 대한 포인터와 길이 등을 담을 수 있다.

### 5.4.2 커넥션 입력/출력 처리 아키텍처

- 고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원한다.
- 단일 스레드 웹 서버
  - 한 번에 하나씩 요청을 처리한다.
  - 트랜잭션이 완료되면 다음 커넥션이 처리된다.
  - 구현은 간단하지만, 처리 도중 다른 커넥션은 모두 무시된다.
  - 성능상 문제가 있다.
- 멀티프로세스와 멀티스레드 웹 서버
  - 프로세스와 스레드는 필요시 만들어질 수 있고, 미리 만들 수도 있다.
  - 너무 많은 프로세스와 스레드는 메모리와 시스템 리소스 소비가 심하기 때문에 최대 개수 제한을 건다.
- 다중 I/O 서버
  - 모든 커넥션은 상태를 감시하다가 사용이 가능해지면 작은 양의 처리가 수행된다.
  - 그 커넥션이 작업을 수행해야 할 때만 작업을 수행하기 떄문에 스레드와 프로세스는 유휴 상태의 커넥션을 기다리느라 리소스를 낭비하지 않는다.
- 다중 멀티스레드 웹 서버
  - 여러 스레드는 각 열려 있는 커넥션을 감시하고 각 커넥션에 대해 조금씩 작업을 수행한다.

## 5.5 단계 3: 요청 처리

- 서버는 요청으로부터 메서드, 리소스, 헤더, 본문을 얻어 처리한다.

## 5.6 단계 4: 리소스의 매핑과 접근

- 웹 서버는 HTML 페이지나 JEPG 같은 이미지와 같은 정적 리소스나 동적 콘텐츠를 제공한다.
- 이러한 리소스들을 제공하기 위해 콘텐츠의 원천을 식별해야 한다.

### 5.6.1 Docroot

- URI를 웹 서버의 파일 시스템안에 있는 파일 이름으로 사용할 수 있다.
- docroot는 웹 서버의 파일 시스템의 특별한 폴터를 웹 컨텐츠를 위해 예약하고 사용한다.
- docroot으로 예약된 파일을 기준으로 URI에서 가져온 문서 루트를 붙여 리소스를 찾는다.
- 서버는 docroot를 벗어나는 부분을 노출하는 URI를 허용하면 안된다.

  - `http://www.naver.com/../`

- 가상 호스팅된 docroot

  - 가상 호스팅 웹 서버를 통해 분리된 문서 루트를 주고 한 웹 서버에 여러 웹 사이트를 호스팅할 수 있다.
  - 가상 호스팅 웹 서버는 URL이나 Host 헤더를 통해 올바른 문서 루트를 식별한다.
  - 요청 A가 도착하는 경우 `/docs/joe/index.html`에서 파일을 가져온다.
  - 요청 B가 도착하는 경우 `/docs/mary/index.html`에서 파일을 가져온다.

- 사용자 홈 디렉터리 docroots
  - 사용자들이 한 대의 웹 서버에서 각자의 개인 웹 사이트를 만들 수 있도록 할 수 있다.
  - `/~` 다음에 사용자 이름이 오는 것으로 시작하는 URI는 사용자의 개인 문서 루트를 가르킨다.

### 5.6.2 디렉터리 목록

- 웹 서버는 경로가 아닌 디렉터리 URL 요청을 받는 경우 몇 가지 행동을 취하도록 설정할 수 있다.
  - 에러 반환,
  - 디렉터리 대신 특별한 색인 파일을 반환.
  - 디렉터리를 탐색해서 그 내용이 담긴 HTML 페이지를 반환.
- 웹 서버는 디렉터리 URL 요청 시 해당 디렉터리 안에 index.html 혹은 index.htm 파일을 찾는다.
  - 있다면 해당 파일을 리턴한다.
- 아파치에서는 DirectorytIndex 설정 지시자를 사용해 기본 디렉터리 파일로 사용될 파일 이름의 집합을 설정할 수 있다.

### 5.6.3 동적 콘텐츠 리소스 매핑

- 웹 서버는 URI를 동적 리소스와 매핑할 수 있다.
- 아파치에서는 URI의 경로명이 실행 가능한 프로그램이 위치한 디렉토리로 매핑되도록 설정할 수 있다.
- 또한, 아파치에서는 특정 확장자의 파일만 실행하도록 설정할 수도 있다.

### 5.6.4 서버사이드 인클루드(Server-Side Includes, SSI)

- 서버는 리소스를 클라이언트에게 보내기 전 특별한 패턴 변수 값이나 실행 가능한 스크립트로 출력 값을 치환하여 동적 콘텐츠를 만들 수 있다.

### 5.6.5 접근 제어

- 접근 제어되는 리소스에 요청이 도착하는 경우 서버는 접근 제어할 수 있다.

## 5.7 단계 5: 응답 만들기

- 응답 메시지는 응답 상태 코드, 응답 헤더, 응답 본문을 퐇마한다.

### 5.7.1 응답 엔티티

- 응답 본문이 존재하는 경우 다음을 포함한다.
  - 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더
  - 응답 본문의 길이를 서술하는 Content-Length 헤더
  - 실제 응답 본문의 내용

### 5.7.2 MIME 타입 결정하기

- 응답 본문의 MIME 타입을 결정하기 위해 여러 방법이 존재한다.
- mime.types
  - 파일 이름의 확장자를 사용한다.
  - 서버는 각 리소스의 MIME 타입을 계산하기 위해 확장자별 MIME 타입이 담겨 있는 파일을 탐색한다.
- 매직 타이핑(magic typing)
  - 파일의 내용을 검사하여 알려진 패턴에 대한 테이블에 해당하는 패턴이 있는지 찾아 결정한다.
  - 느리긴하지만, 표준 확장자 없이 이름이 지어지는 경우 편리하다.
- 유형 명식(Explicit typing)
  - 특정 파일이나 확장자, 내용 등에 상관 없이 어떤 MIME 타입을 갖도록 웹 서버에서 결정하는 것.
- 유형 협상(Type negotitation)
  - 서버는 한 리소스가 여러 종류의 문서 형식에 속하도록 설정할 수 있다.
  - 웹 서버는 사용자와의 협상 과정을 통해 사용하기 가장 좋은 형식을 판단할 수 있다.

### 5.7.3 리다이렉션

- 영구히 리소스가 옮겨진 경우
  - 301 Moved Permanetly 상태 코드를 통해 전달한다.
- 임시로 리소스가 옮겨진 경우
  - 303, 307
- URL 증강
  - 서버는 상태 정보를 내포한 URL을 새로 생성하여 전달한다.
  - 새로 생성된 URL에 상태 정보가 추가된 완전한 URL을 포함한 요청을 다시 보낸다.
  - 303, 307
- 부하 균형
  - 부하가 덜 걸린 서버로 리다이렉션
  - 303, 307
- 친밀한 다른 서버가 있을 때
  - 클라이언트의 정보를 갖고 있는 다른 서버로 리다이렉션
  - 303, 307
- 디렉터리 이름 정규화
  - URI 끝에 `/`을 빠뜨린 경우 포함하여 리다이렉션

## 5.8 단계 6: 응답 보내기

- 응답 받을 때와 비슷한 이슈에 직면한다.

## 5.9 단계 7: 로깅

- 트랜잭션 완료 후 트랜잭션 수행 결과에 대한 로그를 로그파일에 기록한다.
