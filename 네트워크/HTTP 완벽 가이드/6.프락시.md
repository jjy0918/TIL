# 6. 프락시

## 6.1 웹 중개자

- 프락시 서버는 클라이언트와 서버를 중개해주는 역할을 한다.
  - 중간에서 중개해주기 때문에 클라이언트이자 서버라고 볼 수 있다.
  - HTTP 프락시를 만들게 되면, HTTP 클라이언트와 HTTP 서버의 양쪽 규칙 모두 주의 깊게 따라야 한다.

### 6.1.1 개인 프락시와 공유 프락시

- 프락시 서버는 개인 프락시와 공용 프락시로 나뉜다.
- 개인 프락시: 클라이언트 당 할당되는 프락시(일대일).
- 공용 프락시: 여러 클라이언트를 한번에 처리하는 프락시(다대일).

#### 공용 프락시

- 다수의 클라이언트가 접속하기 때문에 중앙 집중형 프락시이다.
- 중앙 집중형이기 때문에 관리하기가 쉽다.
- 캐시 프락시와 같은 프락시들은 공용으로 관리하는게 효율적이다.(공통 요청이 많기 때문에)

#### 개인 프락시

- 일반적으로 많이 사용되는 형태는 아니다.
- 몇몇 ISP 서비스에서 브라우저 기능을 확장하는 등에 사용된다.

### 6.1.2 프락시 대 게이트웨이

- 프락시와 게이트웨이는 공통적으로 애플리케이션을 연결하는 중개인의 역할을 한다.
- 프락시와 게이트웨이의 가장 큰 차이점은 프로토콜의 변환이다.
- 프락시는 프로토콜을 그대로 사용한다.
  - 클라이언트(HTTP) -> 프락시 -> 서버(HTTP) 
- 게이트웨이는 프로토콜의 변화가 일어난다.
  - 클라이언트(HTTP) -> 게이트웨이 -> 서버(POP)
- 다만, 이 구분은 애매모호한 부분이 있다.
- 상용 프락시 서버는 SSL, SOCKS 방화벽, FTP 접근 등을 지원하기 때문에 게이트웨이 기능을 구현할 수 있다.

## 6.2 왜 프락시를 사용하는가?

- 필터 기능: 특정 사용자에게 노출이 되는 컨텐츠와 노출이 되면 안되는 컨텐츠를 필터링할 수 았다.
- 문서 접근 제어: 특정 권한이 있는 사용자에게만 노출하거나, 문서 접근 전 암호 요구 등 문서 접근을 제어할 수 있다.
- 보안 방화벽: 바이러스 제거나, 트래픽 감시 등의 기능을 제공한다.
- 웹 캐시: 컨텐츠의 빠른 제공을 위해 캐시 기능을 제공할 수 있다.
- 대리 프락시: 진짜 웹 서버인 것 처럼 행동하여 컨텐츠를 바탕으로 다른 웹 서버에 요청을 보낼 수 있다.
- 콘텐츠 라우터: 조건과 컨텐츠에 따라 특정 웹 서버에 요청을 보낼 수 있다.(돈을 지불하여 더 빠른 서비스 제공 등)
- 트랜스코더: 콘텐츠를 클라이언트에게 제공하기 전 본문 포맷을 수정하여 제공할 수 있다.
- 익명화 프락시: HTTP 요청에서 신원을 식별할 수 있는 데이터를 제거하여 개인 정보 보호와 익명성에 기여할 수 있다.


## 6.3 프락시는 어디에 있는가?

### 6.3.1 프라시 서버 배치

#### 출구(Egress) 프락시

- 로컬 네트워크 출구에 배치하는 프락시
- 방화벽 제공, 인터넷 트래픽 개선, 부적절한 콘텐츠 필터링 등의 역할을 할 수 있다.
- 클라이언트 -> 출구 프락시 -> 네트워크 -> 서버

#### 접근(입구) 프락시

- ISP 접근 지점에 존재하는 프락시
- ISP 에서 다운로드 속도 개선, 인터넷 대여폭 비용 감소 등을 위해 캐시 프락시를 사용하여 문서를 저장하는 등의 역할을 한다.
- 클라이언트 -> ISP, 접근 프락시 -> 네트워크 -> 서버

#### 대리 프락시(리버스 프락시)

- 네트워크를 타고 들어가 서버 바로 앞단에 존재하는 프락시.
- 웹 서버의 모든 요청을 받아 필요할 때만 서버에 요청할 수 있도록 도와준다.
- 보안 기능이나 캐싱 역할을 한다.
- 대리 프락시는 이름과 IP 주소로 스스로를 가장하기 때문에 모든 요청은 서버가 아닌 프락시로 간다.
- 클라이언트 -> 네트워크 -> 대리 프락시 -> 서버


#### 네트워크 교환 프락시

- 네트워크 사이 피어링 교환 지점들에 존재하는 프락시
- 캐시를 이용하여 네트워크 혼잡을 완화하거나 트래픽 흐름 감시 등의 역할을 한다.
- 클라이언트 -> 네트워크 -> 프락시 -> 네트워크 -> 서버

### 6.3.2 프락시 계층

- 프락시는 하나만 존재하는 것이 아니라 여러대 존재할 수 있다.
- 클라이언트 -> 프락시1 -> 프락시2 -> 프락시3 -> 서버
- 이러한 프락시들은 계층이 존재하고, 부모 자식 관계가 성립된다.
- 기본적으로 서버쪽에 가까우면 부모, 클라이언트쪽에 가까우면 자식이다.
  - 위 예시에서는 프락시2 기준으로 프락시1은 자식, 프락시3은 부모가 된다.
- 프락시는 하나의 방향으로만 갈 수 있는게 아니라, 조건에 따라 여러 프락시 or 서버들과 연결할 수 있다.
- 동적으로 부모를 선택하는 방법은 여러 가지가 존재한다.
  - 부하 균형: 부하 분산을 위해 부모 프라시의 작업량 수준을 근거하여 부모 프락시를 선택한다.
  - 지리적 인접성: 지리적 인접성을 근거로 부모를 선택할 수 있다.
  - 프로토콜/타입 라우팅: URI에 근거하여 다른 부모나 원 서버로 라우팅할 수 있다.
  - 유료 서비스 가입자를 위한 라우팅: 추가 요금을 지불한 경우 성능이 좋은 대형 캐시나 성능이 좋은 부모를 선택할 수 있다.

### 6.3.3 어떻게 프라시가 트래픽을 처리하는가?

- 클라이언트가 서버가 아닌 프락시로 먼저 접근할 수 있도록 만드는 방법은 4가지가 존재한다.

1. 클라이언트 수정
   - 브라우저등을 이용하는 경우 클라이언트에서 수동 혹은 자동으로 프락시 서버를 설정할 수 있다.
2. 네트워크 수정
   - 네트워크 중간에 트래픽을 프락시로 가도록 조정할 수 있다.
   - 이를 위해 스위칭 장치와 라우팅 장치가 추가로 필요하다.
   - 인터셉트 프락시라고도 부른다.
3. DNS 수정
   - 웹 서버 이름과 IP 주소를 프락시가 대신 사용한다.
4. 웹 서버 수정
   - 웹 서버에서 HTTP 리다이렉션 명렁(305 등)을 돌려주어 클라이언트에게 프락시로 가도록 유도할 수 있다.

## 6.4 클라이언트 프락시 설정

- 클라이언트에서 프락시를 설정하는 방법은 4가지 존재한다.

1. 수동 설정
   - 프락시를 사용하겠다고 명시적으로 설정한다.
2. 브라우저 기본 설정
   - 대부분의 브라우저는 수동 프락시 설정 기능을 제공한다.
3. 프락시 자동 설정
   - 자바스크립트의 프락시 자동 설정(PAC) 파일에 대한 URI를 제공하여 프락시 설정을 제공한다.
4. WPAD
   - 대부분의 브라우저는 자동설정 파일을 다운받을 수 있는 웹 프락시 자동발견 프로토콜(WPAD)를 제공한다.


## 6.5 프락시 요청의 미묘한 특징들

### 6.5.1 프락시 서버 URI는 일반 서버 URI와 다르다

- 메시지 문법은 동일하지만, URI는 차이를 보인다.
- 클라이언트는 서버로 요청을 보내는 경우 URI에서 스킴, 호스트, 포트번호가 없는 부분 URI를 보낸다.
- 클라이언트는 프락시로 요청을 보내는 경우 완전한 URI를 가진다.

```HTTP

// 서버로 요청
GET /index.html HTTP/1.0
User-Agent: SuperBrowser v1.3

// 프락시로 요청
GET http://www.marys-antiques.com/index.html HTTP/1.0
User-Agent: SuperBrowser v1.3


```

- 원래 HTTP 요청은 단일 서버와만 통신을 하도록 구현되어 있기 때문에 불필요한 전송을 막기 위해 스킴, 호스트, 포트번호는 생략된다.
- 프락시와 통신하기 위해 새로운 커넥션을 생성해야 하는데, 생략된 URI는 문제를 발생시킨다.
- 프락시 기반으로 요청하는 경우, 완전한 URI를 요구하게 된다.
- `HTTP/1.0` 에서는 원 서버는 생략된 URI, 프락시 서버는 완전한 URI를 요청하도록 구현되어 있다.
- `HTTP/1.1` 에서는 원 서버와, 프락시 서버 모두 완전한 URI를 요청하도록 변경되었다.


### 6.5.2 가상 호스팅에서 일어나는 같은 문제

- 가상 호스팅의 경우, 하나의 물리 서버에 여러 서버가 존재한다.
- 가상 호스팅된 웹 서버는 호스트 이름, 포트를 바탕으로 해당 클라이언트가 요청한 컨텐츠, 기능을 제공한다.
- 생략된 URI는 호스트 이름, 포트가 생략되었기 때문에 정확한 컨텐츠, 기능을 제공할 수 없다.

### 6.5.3 인터셉트 프락시, 대리 프락시는 부분 URI를 받는다

- 인터셉터 프락시, 대리 프락시가 있는 경우, 클라이언트는 서버와 바로 통신한다고 판단하지만 실제로는 프락시를 거치게 된다.
- 클라이언트 입장에서는 서버와 바로 통신하기 때문에 생략 URI를 보내게 된다.

### 6.5.4 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다

- 다목적 프락시 서버는 요청 메시지의 완전한 URI와 부분 URI 모두 지원해야 한다.
- 완전한 URI: 해당 URI를 이용한다.
- 불완전 URI + Host 헤더: Host 헤더를 이용하여 원 서버의 이름과 포트를 알아낸다..
- 불완전 URI: 대리 프락시나, 인터셉터 프락시의 경우 정보를 얻을 수 있지만, 그렇지 않은 경우 에러 메시지를 리턴한다.

### 6.5.5 전송 중 URI 변경

- 프락시 서버에 의해 URI가 변경되는 경우 주의가 필요하다.
- 표준 형식으로 정규화 하거나, 잘못 사용한 예약 글자를 변경하는 등의 작업도 문제를 일으킬 수 있다.
- 특히, 절대 경로를 고쳐쓰는 것을 주의해야 한다.(예외의 경우는 빈 경로를 `/`로 바꾸는 것 뿐이다.)

### 6.5.6 URI 클라이언트 자동확장과 호스트 명 분석

- 대부분의 브라우저는 URI를 바탕으로 호스트명을 찾는다.
- URI에 맞는 호스트명을 찾지 못하는 경우 자동 확장된 URI를 만들어 시도한다.(test -> www.test.com 등)

### 6.5.7 프락시 없는 URI 분석

1. 사용자가 `naver`를 입력한다.
2. 브라우저는 DNS에서 `naver`를 찾는다.
3. 존재하지 않는 경우 브라우저는 자동으로 `www.naver.com`으로 확장하여 DNS에서 찾는다.
4. DNS에서 해당 IP를 찾은 경우 커넥션을 맺고 요청을 보낸다.

### 6.5.8 명시적인 프락시를 사용할 때의 URI 분석

1. 사용자가 명시적 프락시인 `naver`를 입력한다.
2. DNS에 명시적 프락시 정보가 존재하기 때문에 IP를 리턴한다.
3. 프락시 서버와 커넥션을 맺고 요청을 보낸다.

- 이 경우, DNS에 존재하기 때문에 자동 확장이 일어나지 않는다.

### 6.5.9 인터셉트 프락시를 이용한 URI 분석

- 인터셉터 프락시를 이용하는 경우, 문제가 발생하는 부분은 원 서버가 다운됐을 경우이다.
- 클라이언트는 DNS 를 통해 인터셉터 프락시와 연결이 되고, 클라이언트는 원 서버와 연결이 되었다고 판단하여 커낵션을 맺는다.
- 이후 요청을 보내는 경우 실제 다운된 서버에게 가기 때문에 문제가 발생하게 된다.
- 그렇기 때문에 프락시 서버는 원 서버에 대한 장애 허용을 체크해야 한다.

## 6.6 메시지 추적

### 6.6.1 Via 헤더

- Via 헤더 필드는 메시지가 지나는 각 중간 노드의 정보를 나열한다.
- 다른 노드를 지날 때마다 중간 노드는 Via 목록의 끝에 반드시 추가되어야 한다.
- Via 헤더는 메시지 전달을 추적, 메시지 루프 진단등에 사용된다.
- 프락시는 네트워크 진단할 때 Via 헤더를 활용한다.(라우팅 루프 등 체크)
- Via 헤더 구성은 프로토콜 이름, 프로토콜 버전, 노드 이름, 코멘트로 구성된다.
  - 프로토콜 버전과 노드 이름은 필수이고, 프로토콜 이름과 코멘트는 필수가 아니다.
  - Via: HTTP/1.0 www.naver.com NAVER
- 요청 메시지와 응답 메시지 모두 프락시를 거치는 경우 Via 헤더가 존재한다.
- Via는 게이트웨이에서 프로토콜이 변화되는 경우도 입력되기 때문에 프로토콜의 변화도 알 수 있다.
- Via 헤더의 경우 서버에 대한 정보를 담고 있어 악의적으로 이용될 수 있는 가능성이 존재하기 때문에 가명을 사용하거나 항목들을 하나로 합칠 수 있다.
- `Server 헤더`의 경우 원 서버의 정보를 담고 있다.

### 6.6.2 TRACE 메서드

- TRACE 메서드를 통해 메시지가 어떻게 수정되는지 추적/관찰이 가능하다.
- 하지만, 대부분 TRACE 메서드는 구현하지 않는다.
- 원 서버에 도달하거나, Max-Forwards 값이 0인 경우 응답을 리턴하고, 그 응답을 바탕으로 추적/관찰한다.
  - Max-Forwards는 지날 수 있는 hop의 개수

## 6.7 프락시 인증

- 프락시는 젭곤 제어 장치로 제공되어 콘텐츠 차단이나 권한 요청을 할 수 있다.
- 제한된 콘텐츠 요청에 프락시에 도착한 경우 407(Proxy Authorization Required) 상태 코드와 권한 제출 자격 방법인 Proxy-Authenticate를 리턴하여 권한을 요구한다.
- 클라이언트는 Proxy-Authenticate 헤더 필드에 권한에 맞는 자격을 담아 요청을 보낸다.
- 프락시가 여러개 있는 경우 권한 체크는 잘 동작하지 않는다.(HTTP의 확장 기능을 사용하면 되지만, 널리 구현되지는 않았다.)

## 6.8 프락시 상호운용성

### 6.8.1 지원하지 않는 헤더와 메서드 다루기

- 프락시에게 넘어온 헤더에서 프락시가 이해하지 못하는 헤더가 있는 경우 반드시 그대로 넘겨야 한다.(내용과 순서 모두 그대로 넘겨야 한다)
- HTTP/1.1 부터는 메서드 확장을 지원하기 때문에 프락시는 알 수 없는 헤더의 경우 그대로 넘겨야 한다.

### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기

- HTTP의 OPTIONS 메서드를 이용하여 리소스가 어떤 기능을 지원하는지 확인할 수 있다.
