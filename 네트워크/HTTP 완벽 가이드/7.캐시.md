# 7. 캐시

- 캐시의 장점

1. 불필요한 데이터 전송을 줄여준다.
2. 네트워크 병목을 줄여준다.
3. 원 서버에 대한 요청을 줄여준다.
4. 거리로 인한 지연 시간을 줄여준다.

## 7.1 적중과 부적중

- 캐시가 모든 데이터를 저장할 수 없다.
- 캐시에 데이터가 있는 경우 `캐시 적중(cache hit)`이라고 한다.
- 캐시에 데이터가 없는 경우 `캐시 부적중(cache miss)`이라고 한다.

### 7.1.1 재검사(Revalidation)

- 캐시는 `신선도 검사`를 통해 원 서버와 캐시 서버의 데이터가 변경되었지 확인해야 한다.
- HTTP는 서버로부터 '신선도 검사'를 효율적으로 하기 위해 전체 데이터를 요청하지 않는다.
- 캐시된 사본 재검사를 위하여 작은 재검사 요청을 보낸다.
  - 콘텐츠가 변경되지 않았다면 서버는 `304 Not Midified` 응답을 보낸다.
  - 캐시는 304를 받은 경우 사본이 신선하다 판단한다.
  - 이러한 것을 `재검사 적중`, `느린 적중`이라고 한다.
- 이러한 특성 때문에 일반 캐시 적중보다는 느리지만, 캐시 부적중 보다는 빠르다.
- `GET If-Modified-Since` 요청 헤더를 추가하여 캐시된 시간 이후에 변경된 경우에만 데이터를 보내도록 요청한다.
  - 객체가 변경되지 않은 경우 `304 Not Modified` 리턴.
  - 객체가 변경된 경우 `200 OK`와 함께 `콘텐츠 전체`를 보낸다.
  - 객체가 삭제된 경우 `404 Not Found`를 리턴하고, 캐시는 데이터를 삭제한다.

### 7.1.2 적중률

- 캐시 적중률이 0%인 경우에는 원 서버로부터 데이터를 모두 가져와야 하는 경우
- 캐시 적중률이 100%인 경우에는 캐시에 데이터가 있는 경우
- 캐시 적중률이 100%에 근접하는 것이 좋다.
- 오늘날의 경우 40%의 적중률이면 괜찮은 편이라 판단할 수 있다.

### 7.1.3 바이트 적중률

- 컨텐츠당 적중률이 아니라, 바이트 단위 적중률을 사용할 수 있다.
- 바이트 단위로 측정하여, 네트워크 트래픽을 더 정확하게 절감할 수 있다.

### 7.1.4 적중과 부적중의 구별

- 클라이언트는 응답이 캐시 적중이었는지 아니었는지 판단하기 어렵다.
- Via 헤더를 붙이거나 Date 헤더나 Age 헤더를 이용하여 시간을 판단해야 한다.

## 7.2 캐시 토폴리지

### 7.2.1 개인 전용 캐시

- 개인 전용 캐시는 개인만을 위한 캐시로 한 명의 사용자가 자주 찾는 페이지를 담는다.
- 개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않기 때문에 작고 저렴한다.
- 대부분의 브라우저는 자주 쓰이는 문서를 디스크와 메모리에 캐시해 놓고 사용한다.

### 7.2.2 공용 프락시 캐시

- 공용 캐시는 사용자 집단에게 자주 쓰이는 페이지를 담는다.
- 공용 캐시에는 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있다.
- 캐시는 자주 찾는 객체를 단 한 번만 가져와 모든 요청에 대한 공유된 사본을 제공함으로써 네트워크 트래픽을 줄인다.

### 7.2.3 프락시 캐시 계층들

- 캐시도 계층을 가질 수 있다.
- 작은 캐시에서 캐시 부적중이 발생한 경우 더 큰 부모 캐시가 남겨진 트래픽을 처리하도록 계층을 만들 수 있다.
- 계층이 깊다면, 요청은 더 길어지고 성능은 저하될 수 있다.

### 7.2.4 캐시망, 콘텐츠 라우팅, 피어링

- 계층 단계 대신 복잡한 캐시망을 사용할 수 있다.
- 캐시망은 계층 단계와 달리 바로 부모 단계로 보내지 않고 원 서버로 보내는 등 다양한 판단을 한다.
  - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
  - URL에 근거하여, 특정 부모 캐시를 동적으로 선택한다.
  - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아본다.
  - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 캐시를 통한 인터넷 트랜짓은 허용하지 않는다.
- 피어링을 지원하는 형제 캐시도 존재하지만, HTTP에서는 지원하지 않기 때문에 ICP, HTCP 같은 프로토콜을 사용해야 한다.

## 7.3 캐시 처리 단계

### 7.3.1 단계 1: 요청 받기

- 네트워크 커넥션에서 들어오는 데이터를 읽는다.

### 7.3.2 단계 2: 파싱

- 메시지를 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담는다.

### 7.3.3 단계 3: 검색

- 파싱된 데이터를 바탕으로 해당 컨텐츠가 캐시되어 있는지 확인한다.
- 전문적인 캐시는 객체를 로컬 캐시에서 가져올 수 있는지 판단하기 위해 빠른 알고리즘을 사용한다.
- 캐시되어 있지 않다면, 원 서버에 요청하거나 실패를 반환한다.

### 7.3.4 단계 4: 신선도 검사

- HTTP는 신선도 검사를 통해 변경이 되었는지 판단한다.

### 7.3.5 단계 5: 응답 생성

- 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성한다.
- 캐시는 클라이언트에 맞게 헤더를 조정해야 하는 책임이 있다.
- 캐시의 신선도 정보를 삽입하거나 Via 헤더를 삽입할 수 있다.
- 캐시가 Date헤더를 조정해서는 안된다.

### 7.3.6 단계 6: 전송

- 응답이 준비되면, 캐시는 응답을 클라이언트에게 돌려준다.

### 7.3.7 단계 7: 로깅

- 캐시 트랜잭션 완료 후 통계 캐시 적중과 부적중 횟수등에 대한 통계를 갱신하고 로그 파일에 정보를 로깅한다.
- 가장 많이 사용되는 캐시 로그 포맷은 스쿼드 로그 포맷(Squid log format)과 넷스케이프 확장 공용 로그 포맷이다.(커스텀도 가능하다.)

## 7.4 사본을 신선하게 유지하기

### 7.4.1 문서 만료

- HTTP는 Cache-Control과 Expires 헤더를 이용하여 콘텐츠의 유효기간을 붙일 수 있다.
- 해당 헤더를 바탕으로 캐시는 만료 기간을 판단하고, 만료되면 서버에 검사를 요청한다.

### 7.4.2 유효기간과 나이

- Cache-Control:max-age는 해당 콘텐츠가 발행 시점부터 사용할 수 있는 기간을 전달한다.
- Expires는 해당 콘텐츠가 사용될 수 있는 기간이 정해져 있다.

```http
HTTP/1.0 200 OK
Date: Sat, 29 Jun 2002, 14:30:00 GMT
Content-type: text/plan
Expires: Fri, 05 Jul 2002, 05:00:00 GMT

HTTP/1.0 200 OK
Date: Sat, 29 Jun 2002, 14:30:00 GMT
Content-type: text/plan
Cache-Contol: max-age=484200

```

### 7.4.3 서버 재검사

- 캐시 문서 만료는 콘텐츠의 변경을 의미하는 것이 아니라 재검사를 해야 한다는 것을 의미한다.
- 재검사 후 콘텐츠가 변경되었다면, 사본을 가져와 저장한다.
- 재검사 후 콘텐츠가 변경되지 않았다면, 새 만료일을 포함한 헤더를 가져와 헤더들을 갱신한다.

### 7.4.4 조건부 메서드와의 재검사

- HTTP는 조건부 메서드를 통해 캐시 데이터를 요청할 수 있다.
- `If-Modified-Since`(IMS) 헤더를 통해 해당 날짜 이후로 콘텐츠가 바뀌면 콘텐츠를 보내도록 요청할 수 있다.
  - 원 서버는 콘텐츠가 변경된 경우 콘텐츠의 마지막 수정일을 IMS에 담아서 리턴한다.
- `If-None-Match` 헤더를 통해 엔터티 태그를 검사할 수 있다.
  - 태그 값을 통해 해당 데이터가 변했는지 판단한다.
  - 원 서버는 콘텐츠가 변경된 경우 해당 태그를 담아 리턴한다.

### 7.4.5 약한 검사기와 강한 검사기

- HTTP/1.1 부터는 약한 검사기를 지원한다.
- 콘텐츠가 수정되었지만, 중요도가 낮다면 변경된 값을 가져오지 않는다.
- 약한 검사기 기능은 헤더의 값 앞에 `W/`를 붙인다.
  - `If-None-Match: W/"v2.6"`

## 7.5 캐시 제어

- 캐시 데이터 제어에 대한 HTTP 우선순위는 다음과 같다.

1. Cache-Control: no-store
   - 캐시에 대한 사본 생성, 저장 금지
2. Cache-Control: no-cache
   - 캐시에 대한 사본 생성 금지, 로컬에 저장을 할 수 있지만 서버와 재검사를 해야 클라이언트에게 제공 가능.
3. Cache-Control: must-revalidate
   - 원 서버와 최초 재검사 없이는 제공해서는 안됨을 의미한다.
4. Cache-Control: max-age
5. Expires
   - 항상 만료되었다고 판단하기 위해 0으로 설정하는 경우 문제가 될 수 있따.
6. 만료 정보를 주지 않고, 휴리스틱 방법으로 결정
