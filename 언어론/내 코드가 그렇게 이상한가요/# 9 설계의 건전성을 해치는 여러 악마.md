# 9 설계의 건전성을 해치는 여러 악마

## 9.1 데드 코드

- 실행되지 않는 조건 내부에 있는 코드를 `데드 코드(dead code)` 또는 도달 불가능한 코드 라고 한다.
- 데드 코드는 큰 문제가 없어 보이지만, 여러 폐해를 가져온다.
  - 가독성을 떨어뜨린다.
  - 언젠가 버그가 될 수 있다.
- 데드 코드를 발견한다면 즉시 제거하는 것이 좋다.
  - 깃 등을 이용해 이력 관리하면 제거했을 때 발생하는 문제를 걱정하지 않아도 된다.

```java
if(level > 99) {
    level = 99;
}

if(level = 1) {
    ...
} else if(level == 100) {
    // 절대 도달 불가
    ...
}
```

## 9.2 YAGNI 원칙

- 개발 시 미래를 예측하고 미리 만들어 두는 경우가 있다. 이런 코드들은 거의 사용 되지도 않고 버그의 원인이 된다.
- YAGNI(You Aren't Gonna Need it) 이라는 원칙을 지켜라
  - 지금 필요 없는 기능을 만들지 말라!
- 미래를 예측하고 구현해도 대부분 맞지 않고, 이러한 코드는 데드 코드가 된다.

## 9.3 매직 넘버

- 설명이 없는 숫자는 개발자를 혼란스럽게 만든다.
- 이러한 숫자들을 `매직 넘버` 라고 한다.
  - 매직 넘버는 구현자 본인만 의도를 이해할 수 있다.
  - 매직 넘버는 동일한 값이 여러 위치에 등장하여 중복 코드를 만들어 낸다.
- 매직 넘버를 사용하지 않기 위해서는 상수를 활용하면 된다.

## 9.4 문자열 자료형에 대한 집착

- 의미가 없는 다른 여러 개의 값을 하나의 String에 넣지 말라.
  - 의미를 알기가 어렵다.
  - 가독성이 떨어진다.

## 9.5 전역 변수

- 전역 변수는 여러 로직에서 접근할 수 있기 떄문에 변경에 대한 파악이 힘들다.
  - 전역 변수를 다른 곳에서 변경하게 되면 버그가 발생할 가능성이 높다.
- 단순히 전역으로 선언된 변수뿐 아니라 전역의 성질이 있는 변수도 쓰지 않는 것이 좋다.
  - 너무 많은 데이터를 가지고 여러 곳에서 사용되는 데이터 클래스
- 전역 변수의 동기화를 위해 lock을 사용할 경우 성능상의 문제도 발생한다.

### 9.5.1 영향 범위가 최소화되도록 설계하기

- 전역 변수가 안좋은 이유 중 하나가 영향 범위가 넓다는 것이다.
- 영향 범위는 가능한 한 좁게 설계해야 한다.
  - 관계 없는 로직에서는 접근할 수 없게 설계하라
- 전역 변수를 사용해야 한다면 정말 필요한지 검토하라.
- 전역 변수로 만들기 보다는 최대한 한정된 클래스에서만 접근할 수 있는 형태로 설계하라.

## 9.6 null 문제

- null 이 들어갈 수 있다고 전제하고 로직을 작성하게면, 모든 곳에서 null 체크를 해야 한다.
- null 체크가 많아지면 가독성이 떨어지고, 실수로 누락되면 곧바로 버그가 발생한다.

### 9.6.1 null을 리턴/전달하지 말기

- null 체크를 하지 않으려면, 애초에 null을 다루지 않게 만들어야 한다.
- null을 리턴하지 않는 설계
  - 반환 값에 null을 절대 리턴하지 않는다.
  - null 대신 다른 객체를 리턴한다.
- null을 전달하지 않는 설계

### 9.6.2 null 안전

- null 안전이란 null에 의한 오류가 아예 발생하지 않게 만드는 구조를 말한다.
- 일부 프로그래밍 언어에서는 언어 자체가 null 안전 사양을 지원한다.
- null 안전을 구현하기 위한 기능으로 null 안전 자료형이 있는 경우도 있다.
  - ex) kotlin
  - null 안전 자료형에 null을 대입하면 컴파일조차 되지 않는다.

## 9.7 예외를 catch 하고서 무시하는 코드

- try~catch 구문에서 예외를 catch 해놓고 별다른 처리를 하지 않는 코드는 굉장히 사악한 코드다.
- 이러한 코드는 원인 분석을 어렵게 만든다.
  - 오류가 발생해도 오류를 탐지할 방법이 없다.
  - 문제가 발생할 경우 원인 찾는데에 개발자의 시간과 체력이 상당히 들어간다.
- 문제가 발생했다면 소리쳐라
  - 잘못된 상태에 어떠한 관용도 베풀어서는 안 된다.
  - 잘못된 상태에서 계속해서 처리를 진행하는 것은 위험하다.
  - 예외를 확인했다면 곧바로 통지, 기록하는 것이 좋다.

## 9.8 설계 질서를 파괴하는 메타 프로그래밍

- 프로그램 실행 중 해당 프로그램 구조 자체를 제어하는 프로그래밍을 메타 프로그래밍이라 한다.
- 자바에서는 메타 프로그래밍을 활용하여 리플렉션 API를 사용한다.
- 메타 프로그래밍은 일반적인 프로그래밍에서는 접근할 수 없는 부분까지 접근하기 때문에 흑마법이라 할 수 있다.
  - 메타 프로그래밍의 용법과 의도를 제대로 이해하지 못하고 사용했을 때 전체적인 설계를 무너뜨릴 수도 있다.

### 9.8.1 리플렉션으로 인한 클래스 구조와 값 변경 문제

- 리플렉션을 사용하면 final로 지정한 변수의 값도 바꿀 수 있는 등 여러 조작을 할 수 있다.
- 리플렉션을 남용하게 되면 기존에 설명했던 설계들이 모두 의미가 없어진다.
- 집을 안전하게 보호하려 했지만, 뒷문을 열어 놓는 것과 같다.

```java
Field field = Level.class.getDeclaredField("value");
field.setAccessible(true);
field.setInt(level, 999);   // final로 선언된 value 라는 변수 수정
```

### 9.8.2 자료형의 장점을 살리지 못한 하드 코딩

- 자바로 대표되는 정적 자료형 언어는 정적 분석으로 정확한 코드 분석이 가능하다는 것이 장점이다.
- 메타 프로그래밍은 이러한 장점을 무너뜨린다.
  - generateInstance 를 통해 클래스 생성 시 클래스의 이름이 변경되면 문제가 발생할 수 있다.

### 9.8.3 단점을 이해하고 용도를 한정해서 사용하기

- 메타 프로그래밍은 단점을 이해하지 못하고 사용하면 유지보수와 변경이 매우 힘들어진다.
- 메타 프로그래밍을 사용하고 싶다면 시스템 분석 용도로 한정하거나, 아주 작은 범위에서만 활용하는 등 리스크를 최소화해야 한다.

## 9.9 기술 중심 패키징

- 패키징을 구분할 떄도 폴더를 적절하게 나누지 않으면, 악마를 불러들일 수 있다.
- 시스템 구조에 따라 패키지와 폴더 구조를 나누느 것을 `기술 중심 패키징`이라고 한다.
  - 대표적으로 장고, 스프링에서 models, views, controllers로 나누어 관리하는 것을 말한다.
- 모든 클래스를 기술 중심 패키징 하는 것 보다는 비즈니스 로직을 가진 경우, 비즈니스 로직으로 나눈 뒤 기술 중심 패키징을 하는 것이 좋다.
  - 재고, 주문 결제 단위로 나눈 후 기술 중심 패키징
- 비즈니스 단위로 나누게 될 경우 관계없는 부분에서 참조할 가능성도 없고, 관련된 개념끼리 모여 있으므로 찾기도 쉬워진다.

## 9.10 샘플 코드 복사해서 붙여 넣기

- 샘플 코드를 그대로 복사하고 붙여 넣어 구현하면 설계 측면에서 좋지 않다.
- 샘플은 설명을 위해 작성된 것이기 때문에 참고만 하자

## 9.11 은 탄환

- 문제를 해결하기 위해 상황을 고려하지 않고 자신이 알고 있는 편리한 기술만 활용할 경우 더 심각해질 수 있다.
- 소프트웨어 개발에서는 `은 탄환(Silver bullet)`은 존재하지 않는다.
  - 무조건 옳은 방법은 없다.
- 어떤 문제가 있을 때 어떤 방법이 해당 문제에 효과적인지, 비용이 더 들지는 않는지 평가하고 판단하려는 자세가 중요하다.