# Chapter10 람다를 이용한 도메인 전용 언어

- 도메인 전용 언어(DSL)이란 특정 도메인을 대상으로 만들어진 특수 프로그래밍 언어다.
  - maven, ant 등이 있다.(빌드를 위한 DSL)
  - html(웹 페이지 구조 정의 DSL)
- 자바의 스트림 API는 플루언트 스타일(fluent style) 형태라서 쉽게 DSL에 적용할 수 있다.
  - `외부 DSL`을 사용할 경우 외부 DSL에 대한 문법과 파서가 별도로 필요하다.
  - `내부 DS`L을 사용할 경우에는 코드 구현도 쉽고, 기존 환경에서 빠르고 효과적으로 구현할 수 있다.
  - `외부 DSL`이란 현재 환경(지금은 java)가 아닌 외부에서 사용하는 DSL(SQL, maven 등)을 의미하고, `내부 DSL`은 현재 환경에서 사용하는(구현된) DSL을 의미한다.

## 10.1 도메인 전용 언어

- DSL은 위에서 설명한 것 처럼 특정 비즈니스 도메인의 문제를 해결하려고 만든 언어다.
  - 즉, 특정 비즈니스 도메인을 인터페이스로 만든 API라고 생각할 수 있다.
- DSL을 이용하면 사용자가 특정 도메인의 복잡성을 더 잘 다룰 수 있고, 저수준의 세부 구현은 숨길 수 있다.
- DSL을 개발하기 위해서는 비즈니스에 대한 정확한 파악이 필요하며, 가독성이 핵심이다.

### DSL 장점, 단점

- 장점: 간결함, 가독성, 유지보수, 높은 수준의 추상화, 집중, 관심사 분리
- 단점: DSL 설계의 어려움, 개발 비용, 추가 우회 계층, 새로 배워야 하는 언어, 호스팅 언어의 한계

### JVM에서 이용할 수 있는 다른 DSL

- 내부 DSL은 순수 자바 코드 같은 기존 호스팅 언어를 기반으로 구현하며, 외부 DSL은 호스팅 언어와는 독립적은 자체 문법을 가진다.
- JVM에서는 외부, 내부 중간에 존재하는 DSL이 존재한다.
  - 스칼라나 그루비는 자바는 아니지만 JVM에서 실행되어 유연하고 표현력이 강력하다.
  - 이러한 DSL을 다중 DSL이라 부른다.
    - 다중 DSL은 JVM이라는 같은 환경에서 빌드되기 때문에 별도로 컴파일, 빌드를 진행할 필요가 없다.

## 10.2 최신 자바 API의 작은 DSL

- 스트림 API는 컬렉션을 조작하는 DSL이라 할 수 있다.
- DSL이란 결국 비즈니스 로직을 정해진 규칙을 사용하여 구현하는 언어다.
- 스트림 API에서는 컬렉션 조작 시 정해진 규칙(map, limit, filter 등)이 있고, 이를 통해 동작을 구현하기 떄문에 간단한 내부 DSL이라 볼 수 있다.
- 스트림 API는 플루언트 형식이기 때문에 알아보기도 쉽다.

## 10.3 자바로 DSL을 만드는 패턴과 기법

- DSL은 특정 도메인 모델에 적용할 친화적이고 가독성 높은 API를 제공한다.

### 기본 자바 빈즈

```java
Order order = new Order();
order.setCustomer("BigBank");

Trade trade1 = new Trade();
trade1.setType(Trade.Type.Buy);

Stock stock1 = new Stock();
stock1.setSymbol("IBM");
stock1.setMarket("NYSE");

trade1.setStock(stock1);
trade1.setPrice(125.0.0);
...
```

- 기본 자바 빈즈로 도메인 로직을 구현할 경우 굉장히 장황해진다.

### 메서드 체인

```java
Order order = forCustomer("BigBank")
    .buy(80)
    .stock("IBM")
    .on("NYSE")
    .at(125.00)
    .sell(50)
...
```

- DSL에서 가장 흔한 방식 중 하나는 메서드 호출 체인이다.
- 메서드 호출 체인 방식으로 변경하기만 해도 상당히 개선된다.
- 메서드 호출 체인 방식으로 변경하기 위해서는 몇 개의 `빌더(Builder)`를 구현해주어야 한다.
- 빌더를 사용하기 때문에 파라미터가 빌더 내부로 국한되며 정적 메서드 사용을 최소화하기 때문에 메서드 이름이 인수의 이름을 대신하여 가독성을 개선한다.
- 하지만 `빌더를 구현`해야 한다는 것이 메서드 체인의 `단점`이다.
  - 상위 수준의 빌더를 하위 수준의 빌더와 연결할 접착 코드가 필요하게 된다.
  - 도메인의 객체 중첩 구조와 일치하게 들여쓰기를 강제할 방법도 없다.

### 중첩된 함수 이용

- 중첩된 함수 DSL 패턴은 다른 함수 안에 함수를 이용하여 도메인 모델을 만든다.

```java
Order order = order("BigBank", 
    buy(80, stock("IBM", on("NYSE")), at(125.00)),
    sell(50, stock...)
    )
```

- 메서드 체인에 비해 중첩 방식이 도메인 객체 계층 구조에 그대로 반영된다.
- 하지만, 이러한 방식은 더 많은 괄호가 사용하여 가독성이 떨어지고, 인수 목록을 정적 메서드에 넘겨줘야 한다는 제약도 있다.
  - 선택사항이 있는 필드가 있으면 이 가능성을 처리할 수 있도록 오버라이드 해야 한다.

### 람다 표현식을 이용한 함수 시퀀싱

```java
Order order = order(o -> {
    o.forCustomer("BigBank");
    o.buy(t -> {
        t.quantity(80);
        t.price(125.00);
        ...
    });
    o.sell(t -> {
        t.quantitiy(50);
        ...
    });
    ...
})

```

- 람다 표현식 처럼 구현하기 위해서는 매우 많은 빌더를 구현해야 한다.
- 람다 표현식은 메서드 체인과 중첩 함수의 장점을 모두 가지고 있다.
- 하지만, 많은 설정 코드가 필요하며, 람다 표현식 문법에 의한 잡음에 영향을 받는 다는 것이 단점이다.
- 람다 표현식의 경우 메서드 참조를 이용하면 조금 더 간결하며 가독성 좋게 만들 수 있다.

### 조합하기

- 위 3가지 방법은 개별로만 적용할 수 있는 것이 아니라, 조합하여 적용할 수 있다.

## 10.4 실생활의 자바8 DSL

### DSL 패턴 장점과 단점

- 메서드 체인
  - 장점
    - 메서드 이름이 키워드 인수 역할을 한다.
    - 선택형 파라미터와 잘 동작한다.
    - DSL 사용자가 정해진 순서로 메서드를 호출하도록 강제할 수 있다.
    - 정적 메서드를 최소화하거나 없앨 수 있다.
    - 문법적 잡음을 최소화한다.
  - 단점
    - 구현이 장황하다.
    - 빌드를 연결하는 접착 코드가 필요하다.
    - 들여쓰기 규칙으로만 도메인 객체 계층을 정의한다.
- 중첩 함수
  - 장점
    - 구현의 장황함을 줄일 수 있다.
    - 함수 중첩으로 도메인 객체 계층을 반영한다.
  - 단점
    - 정적 메서드의 사용이 빈번하다.
    - 이름이 아닌 위치로 인수를 정의한다.
    - 선택형 파라미터를 처리할 메서드 오버로딩이 필요하다.
- 람다를 이용한 함수 시퀀싱
  - 장점
    - 선택형 파라미터와 잘 동작한다.
    - 정적 메서드를 최소화하거나 없앨 수 있다.
    - 람다 중첩으로 도메인 객체 계층을 반영한다.
    - 빌더의 접착 코드가 없다.
  - 단점
    - 구현이 장황하다.
    - 람다 표현식으로 인한 문법적 잡음이 DSL에 존재한다.

### jOOQ

- jOOQ는 SQL을 구현하는 내부적 DSL로 자바에 직접 내장된 형식 안전 언어다.
- 데이터베이스 스키마를 역공학하는 소스코드 생성기 덕분에 자바 컴파일러가 복잡한 SQL 구문의 형식을 확인할 수 있다.
- jOOQ DSL 구현 시 메서드 체인 패턴을 사용하여 쉽게 파악이 가능하다.
- 스트림 API와 조합하여 사용할 수 있다.


```java
DSL.using(c)
    .select(BOOK.AUTHOR, BOOK.TITLE)
    .where(BOOK.PUBLISHED_IN.eq(2016))
    .orderBy(BOOK.TITLE)
    .fetch()
    .stream()   // stream api로 전환
    .collect(...)
```

### 큐컴버

- 동작 주도 개발(BDD)은 테스트 주도 개발의 확장으로 다양한 비즈니스 시나리오를 구조적으로 서술하는 간단한 도메인 전용 스크립팅 언어를 사용한다.
- 큐컴버는 다른 BDD 프레임워크와 마찬가지로 명령문을 실행할 수 있는 테스트 케이스로 변환한다.
- 즉, 큐컴버를 이용하면 비즈니스 기능을 구술함과 동시에 테스트를 동시에 진행하는 것이다.
- 큐컴버는 개발자가 비즈니스 시나리오를 평문 영어로 구현할 수 있도록 도와준다.
- 큐컴버는 전제 조건 정의(Given), 실질 호출(When), 결과 확인(Then) 으로 구분되는 개념을 사용한다.
  - 해당 개념들을 사용하여 서술된 스크립트는 테스트 케이스의 변수를 캡처하는 정규 표현식으로 사용된다.

```
Feature: Buy stock
    Scenario: Buy 10 IBM stocks
        Given the price of a "IBM" stock is 125$
        When I buy 10 "IBM"
        Then the order value should be 1260$
```

```java
// 람다를 이용한 큐컴버
public class BuyStocksSteps implements En {
    public BuyStocksSteps() {
        Given("^the price of a \"(.*?\") stock is (\\d+)\\$$", (String stockName, int unitPrice) -> {
            ...
        })
        ...(When, Then)
    }
}
```

### 스프링 통합

- 스프링 통합(Spring Integration)은 유명한 엔터프라이즈 통합 패턴을 지원할 수 있도록 의존성 주입에 기반한 스프링 프로그래밍 모델을 확장한다.
- 스프링 통합은 스프링 기반 애플리케이션 내의 경량의 원칙, 메시징, 스케쥴링을 지원한다.
- 스프링 통합은 채널, 앤드포인트, 폴러, 채널 인터셉터 등 메시지 기반의 애플리케이션에 필요한 가장 공통 패턴을 모두 구현한다.
- 가독성이 높아지도록 엔드포인트는 DSL에서 동사로 구현하며 여러 엔드포인트를 한 개 이상의 메시지 흐름으로 조합해서 통합 과정이 구성된다.

## 10.5 마치며

- DSL의 주요 기능은 개발자와 도메인 전문가 사이의 간격을 좁히는 것이다.
- DSL은 크게 내부적 DSL과 외부적 DSL로 분류할 수 있다.
  - 내부적 DSL은 개발 노력이 적게 드는 반면 호스팅 언어의 문법 제약을 받는다.
  - 외부적 DSL은 높은 유연성을 제공하지만 구현하기 어렵다.
- JVM언어에서 이용할 수 있는 스칼라, 그루비 등의 다른 언어로 다중 DSL을 개발할 수 있다.
- 자바의 장황함과 문법적 엄격함 때문에 보통 자바는 내부적 DSL을 개발하는 언어로서 적합하지 않다.
  - 하지만, 람다 표현식과 메서드 참조 덕분에 상황이 많이 개선되었다.
- 최신 자바는 자체 API에 작은 DSL을 제공한다.
  - Stream, Collectors
- 자바 DSL을 구현할 때 보통 메서드 체인, 중첩 함수, 함수 시퀀싱 세 가지 패턴이 사용된다.
  - 각각 장단점이 있으며, 여러개 패턴을 합쳐서 사용할 수도 있다.
- 많은 자바 프레임워크와 라이브러리를 DSL을 통해 이용할 수 있다.