# Chapter15 CompltetableFuture

- 최근 웹 애플리케이션들은 MSA 구조로 변화하고 있고, 다른 애플리케이션의 API를 이용하여 합치는 매시업 형태가 되고 있다.
- 이러한 형태의 시스템은 네트워크 통신이 많이 증가하게 된다.
- 애플리케이션이 여러 웹 서비스에 접근할 때 응답을 기다리는 동안 연산이 블록되는 경우가 있다.
- 블록되는 것을 방지하기 위해 멀티태스크 프로그래밍을 도입할 수 있으며, 이는 `병렬성`과 `동시성`으로 구분할 수 있다.
  - `병렬성`은 여러 태스크를 CPU의 다른 코어 또는 머신을 통해 병렬로 실행하는 것이다.
  - `동시성`은 여러 태스크를 하나의 코어에서 동작시키는 것으로, 코어를 바쁘게 유지한다.
- 자바에서는 멀티 테스크를 지원하기 위해 `Future` 인터페이스를 제공하며, 자바8의 `CompletableFuture`를 통해 간단하게 구현할 수 있다.
- 자바9 에서는 `플로 API`를 이용하여 리액티브 프로그래밍 개념을 이용하여 접근한다.

## 15.1 동시성을 구현하는 자바 자원의 진화

- 초기 자바에서는 `Runnable`과 `Thread`를 동기화된 클래스와 메서드를 이용하여 잠갔다.(synchronized)
- 자바5 에서는 스레드 실행과 태스크 제출을 분리하는 `ExecutorService`를 제공했다.
  - 태스크 제출은 `Runnable`, `Callable`을 통해 이루어진다.
  - 스레드 실행은 `ExecutorService`를 통해 이루어진다.
- 자바7 에서는 `포크/조인` 프레임워크를 도입하여 개선된 동시성 지원이 추가되었다.
- 자바8 에서는 `스트림`과 `람다`를 이용하여 병렬 프로세싱이 추가되었고 `Future`를 이용한 `CompletableFuture`를 이용하여 동시성을 강화하였다.
- 자바9 에서는 분산 비동기 프로그래밍을 리액티브 프로그래밍 형식으로 제공하기 위해 `Flow` API를 제공한다.
- CompletableFuture와 Flow 모두 가능한한 동시에 실행할 수 있는 독립적인 태스크를 가능하게 만들면서 멀티코어 또는 여러 기기를 통한 병렬성을 쉽게 이용하도록 하는 것이다.

### 15.1.1 스레드의 높은 수준의 추상화

- 운영체제는 여러 프로세스가 실행될 경우 주기적으로 번갈아가며 각 프로세스에 CPU를 할당하여 실행한다.
- 프로세스는 스레드를 이용하여 태스크를 동시에 또는 협력적으로 실행할 수 있다.
- 멀티코어에서 하나의 프로세스가 실행되고, 해당 프로세스에서 하나의 스레드만 실행된다면 컴퓨팅 파워를 모두 사용할 수 없다.
  - 각 코어는 한개 이상의 프로세스나 스레드를 할당될 수 있지만, 하나의 프로세스나 스레드가 여러 코어를 동시에 사용할 수는 없다.
- 프로그램에 (멀티)스레드를 사용하지 않는다면, 효율성이 떨어진다.
- 멀티 코어를 사용하기 위해 멀티 스레드를 직접 구현할 경우 문제가 발생하기 쉽지만, 병렬 스티림은 스래드 사용을 추상화하여 높느 수준의 개념을 제공하기 때문에 사용이 쉬워진다.

### 15.1.2 Executor와 스레드 풀

- 자바5 에서는 Executor 프레임워크와 스레드 풀을 이용하여 스레드를 높은 수준으로 끌어올린다.
- 태스크 제출과 실행이 분리된다.

#### 스레드의 문제

- 자바에서 스레드는 직접 운영체제 스레드에 접근한다.
- 운영체제 스레드는 만들고 종료하려면 비싼 비용을 치러야 한다.
- 운영체제 스레드의 숫자는 제한되어 있기 때문에 해당 숫자 보다 많이 생성하게 되면 예상치 못한 방식으로 문제가 발생할 수 있다.
- 다양한 기기에서 실행될 수 있는 프로그램이라면, 기기에 따라 사용할 수 있는 스레드 수가 달라질 수 있기 때문에 사용할 수 있는 스레드 수를 추측하지 않는 것이 좋다.
- 자바에서 최적의 스레드 개수는 하드웨어 코어 수에 따라 달라진다.

#### 스레드풀과 장점

- `newFixedThreadPool` 같은 팩토리 메서드 중 하나를 이용하여 `ExecutorService`를 만들 수 있다.
  - 이때 `ExecutorService`는 매개변수로 받은 `nThread` 개수 만큼의 스레드를 가진 스레드 풀을 가지고 있다.
- ExecutorService에 제출된 태스크는 먼저 제출된 순서대로 스레드풀에서 사용중이지 않는 스레드를 이용하여 실행한다.
- 태스크 실행이 종료되면 스레드는 스레드 풀로 반환된다.
- 이러한 방식을 통해 하드웨어에 맞는 수의 태스크를 유지함과 동시에 수 천개의 태스크를 스레드 풀에 오버헤드 없이 제출할 수 있다.

#### 스레드풀 단점

- 스레드를 직접 사용하는 것 보다 스레드 풀을 사용하는 것이 바람직하지만, `주의 사항`이 존재한다.
- `블록` 될 수 있는 태스크는 스레드 풀에 제출하지 말아야 한다.
  - 스레드 풀은 해당 스레드 개수 만큼만 동시에 실행되는데, 이때 I/O 작업이나 네트워크 연결을 기다리는 경우 해당 워커 스레드를 점유하고 있기 떄문에 해당 워커 스레드는 무한 대기해야 한다.
  - 5개의 워커 스레드가 있을 떄 2개의 워커 스레드가 대기중이라면, 3개의 워커 스레드만 태스크를 처리하기 때문에 비효율적이게 된다.
- 프로그램 종료 전에 모든 스레드 풀을 종료하는 습관을 가져야 한다.

### 15.1.3 스레드의 다른 추상화: 중첩되지 않은 메서드 호출

- `엄격한 포크/조인`은 스레드 생성과 대기(join)이 하나의 메서드 안에서 실행되기 때문에 안전하다.
- `여유로운 포크/조인`은 스레드 생성 후 메서드를 벗어나 게속 실행되는 동시성 형태에 초점을 둔다.
  - 이러한 메서드를 비동기 메서드라고 한다.
- 비동기 메서드는 데이터 경쟁 문제나, 스레드가 종료되지 않는 상태에서 main이 종료될 수 있는 등의 문제가 있다.
  - 자바에서는 스레드를 `데몬` 스레드와 `비데몬` 스레드로 구분할 수 있다.
  - 데몬 스레드는 JVM이 종료되는 시점(비데몬 스레드가 모두 종료되는 시점)에 강제로 종료된다.
  - 비데몬 스레드는 JVM이 강제로 종료하지 못하며(exit 실행 제외) 종료될 때 까지 JVM이 대기한다.

## 15.2 동기 API와 비동기 API

- 병렬 하드웨어를 이용하기 위해 두 단계가 존재한다.
  1. 외부 반복(for 루프)를 내부 반복(스트림 메서드)으로 바꿔야 한다.
  2. 스트림에 parallel 메서드를 이용하여 자바 런타임 라이브러리가 병렬적 요소가 처리되도록 한다.
- 루프를 이용한 외부 반복의 경우 프로그래머가 추측에 의존해야 하지만, 내부 반복의 경우 런타임 시스템이 사용할 수 있는 스레드를 더 정확하게 알 수 있는 것이 장점이다.
- 동기 API가 여러개 동작해야 하는 경우, 모든 동기 API가 순차적으로 실행되기 떄문에 시간이 오래걸릴 수 있다.
- 각 동기 API가 서로 연관성이 없을 때 비동기 API 형태로 전환한다면, 동기 API 중 가장 오래 걸리는 작업의 시간 만큼만 걸리게 된다.
  - Thread를 통해 구현할 수도 있고, Future API를 이용하여 ExecutorService의 스레드 풀을 통해 구현할 수도 있고, Flow를 통해 구현할 수도 있다.

### 15.2.1 Future 형식 API

- Future API로 전환하기 위해서는 기존의 메서드의 태스크를 포함하는 Future를 반환하는 형태로 만들면 된다.

```java
// 동기 API
int f(int x);
int g(int y);
System.out.println(f(x) + g(x));

// 비동기 API
Future<Integer> f(int x);
Future<Integer> g(int x);
System.out.println(f(x).get() + g(x).get())
```

### 15.2.2 리액티브 형식 API

- 동기 API를 콜백 형식으로 프로그래밍하여 비동기 API로 전환할 수 있다.

```java
void f(int x, IntConsumer dealWithResult);  // f의 결과를 받아 dealWithResult로 전달한 로직이 처리한다.
```

- 리액티브 API 형식으로 구현하게 되면, 콜백으로 전달한 로직을 여러 번 수행할 수도 있다.
  - 기존의 메서드나 Future의 경우 한 번만 수행된다.
- Future 방식과 리액티브 방식은 명시적으로 스레드를 사용하는 것 보다는 단순하게 만들어주며, 높은 수준의 구조를 유지할 수 있게 도와준다.
- 계산이 오래 걸리거나 네트워크 등의 입력을 기다려야 하는 경우 이러한 방식을 사용하면 효율성이 크게 향상된다.

### 15.2.3 잠그기는 해로운 것으로 간주

- 태스크를가 실행되면 자원을 점유하고 있기 때문에 태스크가 끝나서 자원을 해제하기 전까지 태스크를 계속 실행해야 한다.
- sleep으로 스레드를 잠들게 하더라도, 그 스레드는 시스템 자원을 점유하고 있다.
- 스레드 풀에서 잠을 자는 태스크는 다른 태스크가 시작되지 못하게 막기 떄문에 자원을 소비하게 된다.
  - 잠자는 동작일 비롯하여 블록 동작도 마찬가지다.
- 태스크를 블록하는 것 보다는 다음 작업으로 태스크를 제출하고, 현재 태스크는 종료하는 것이 바람직하다.

### 15.2.4 현실성 확인

- 시스템 설계 시 많은 작업을 작은 태스크로 설계하고 블록할 수 있는 태스크는 비동기로 호출하면 병렬 하드웨어를 최대한 활용할 수 있다.
- 하지만 현실적으로 모든 것을 비동기로 설계하는 것은 불가능하다.

### 15.2.5 비동기 API에서 예외는 어떻게 처리하는가?

- Future나 리액티브 형식의 비동기 API에서 실제 바디는 별도의 스레드에서 호출되기 때문에 이때 발생하는 에러는 호출자의 실행 범위와 관계가 없는 상황이 된다.
- 비동기 API에서는 예외가 발생했을 때 동작을 실행하기 위한 별도의 기능들을 제공한다.

## 15.3 박스와 채널 모델

- 동시성 모델을 설계하고 개념화하기 위해 `박스와 채널 모델(box-and-channel model)` 기법을 자주 사용한다.
- 박스와 채널 모델을 이용하여 대규모 시스템 구현의 추상화 수준을 높일 수 있다.
- 박스로 원하는 연산을 표현하면 계싼을 손으로 코딩한 결과보다 더 효율적이다.

## 15.4 CompletableFuture와 콤비네이터를 이용한 동시성

- 쟈바8 에서는 CompletableFuture를 이용하여 Future를 조합할 수 있는 기능을 추가했다.
- CompletableFuture는 실행할 코드 없이 Future를 만들 수 있으며, 다른 스레드가 complete, get 등을 호출하여 처리할 수 있도록 허용한다.

```java
ExecuturService executorService = Executors.newFixedThreadPool(10);

CompletableFuture<Integer> a = new CompletableFuture();
CompletableFuture<Integer> b = new CompletableFuture();
CompletableFuture<Integer> c = a.thenCombine(b, (y, z) -> y + z);   // a와 b를 정의하기 전에 c를 구현
executorService.submit(() -> a.complete(f(x)));
executorService.submit(() -> b.complete(g(x)));

System.out.println(c.get());
```

- CompletableFuture와 콤비네이터를 이용하여 get에서 블록하지 않을 수 있고, 그렇게 함으로 병려 실행의 효율성을 높일 수 있다.

## 15.5 발생-구독 그리고 리액티브 프로그래밍

- Future와 CompletableFuture는 독립적 실행과 병렬성 모델에 기반하며, 결과를 한 번만 실행하여 제공한다.
- 리액티브 프로그래밍은 시간이 흐르면서 여러 Future 같은 객체를 통해 여러 결과를 제공한다.
- 리액티브 프로그래밍은 여러 번의 결과를 반환하며 결과에 반응하는 부분이 존재한다.
- 리액티브 프로그래밍은 한 번의 동작으로 소비되는 것이 아니기 때문에 비싼 편이다.
- 스트림의 패러다임은 한 번의 단말 동작으로 소비되고 여러 개의 파이프라인으로 분리하거나 하나의 파이프라인으로 합치기 어렵기 때문에 선형적인 패러다임이다.
  - 이러한 선형적인 패러다임을 리액티브 방식으로 사용할 수도 있으나, 어렵다.
- 자바9 에서는 Flow 인터페이스를 통해 발행-구독(pub-sub) 모델을 적용하여 리액티브 프로그래밍을 제공한다.
- Flow API는 세 가지로 정리할 수 있다.
  - 구독자가 구독할 수 있는 발행자.
  - 연결을 구독이라 한다.
  - 연결을 이용하여 메시지(이벤트)를 전송한다.

### 15.5.1 두 플로를 합치는 예제

- Flow API는 데이터를 발생하는 Publisher, 구독하는 Subscriber 인터페이스를 제공한다.

```java
class SimpleCell impletments Publisher<Intger>, Subscriber<Integer> {
    private int value = 0;
    private String name;
    private List<Subscriber> subscribers = new ArrayList<>();

    public SimpleCell(String name) {
        this.name = name;
    }

    @Override
    public void subscribe(Subscriber<? super Integer> subscriber) {
        subscribers.add(subscriber);
    }

    @Override
    public void onNext(Integer newValue) {
        this.value = newValue;
        notifyAllSubscribers();
    }

    private void notifyAllSubscribers() {
        subscribers.forEach(subscriber -> subscriber.onNext(this.value));
    }
}

class ArithmeticCell extends SimpleCell {
    private int left;
    private int right;

    public ArithmeticCell(String name) {
        super(name);
    }
    
    public void setLeft(int left) {
        this.left = left;
        onNext(left + this.right);
    }

    public void setRight(int right) {
        this.right = right;
        onNext(right + this.left);
    }
}

ArithmeticCell c3 = new ArithmeticCell("C3");
SimpleCell c2 = new SimpleCell("C2");
SimpleCell c1 = new SimpleCell("C1");

c1.subscribe(c3::setLeft);
c2.subscribe(c3::setRight);

c1.onNext(10);
c2.onNext(20);
c1.onNext(15);  // c1의 값이 15로 갱신되면, c3이 반응하여 자신의 값 갱신
```

- 데이터가 발행자(생산자)에서 구독자(소비자)로 흐르는 흐름에 착안하여 개발자는 업스트림 또는 다운스트림이라 부른다.
- Flow API에서는 onNext 이벤트 외에 onError나 onComplete 같은 메서드를 제공한다.
- Flow API는 `압력`과 `역압력` 개념을 알아야 한다.
  - 압력은 데이터를 소비하지 못하는 상황(처리하지 못하는 상황)에서도 데이터가 계속 들어오는 상황을 말한다.
  - 역압력은 데이터 소비 가능한 경우에만 요청할 수 있는 것이다.
  - 즉, 데이터 주체가 달라지는 것이다.

### 15.5.2 역압력

- Flow API는 데이터의 흐름 속돌르 역압력으로 제어한다.
- 즉, 데이터 요청에 대해 Subscriber에서 Publisher로 정보를 요청해야 한다.
- Subscriber는 `onSubscribe` 라는 메서드를 가지고 있으며, Publisher와 Subscriber 사이에 채널이 연결될 때 호출된다.
  - `onSubscribe`는 `Subscription` 객체를 전달하며, Publisher와 Subscriber가 통신할 수 있는 메서드를 포함한다.
- Publisher가 Subscriber의 onSubscribe 메서드에 Subscription을 전달하고, Subscriber는 Subscription을 통해 데이터를 요청한다.

## 15.6 리액티브 시스템 vs 리액티브 프로그래밍

- 리액티브 시스템은 런타임 환경이 변화에 대응하도록 전체 아키텍처가 설계된 시스템이다.
- 리액티브 시스템은 `반응성`, `회복성`, `탄력성`으로 세 가지 속성을 가져야 한다.
  - 반응성은 실시간으로 입력에 반응하는 것을 의미한다.
  - 회복성은 한 컴포넌트의 실패로 전체 시스템이 실패하지 않음을 의미한다.
  - 탄력성은 시스템이 자신의 작업 부하에 맞게 적응하며 작업을 효율적으로 처리함을 의미한다.
- 리액티브 시스템을 구현하기 위해 리액티브 프로그래밍을 사용할 수도 있지만, 다른 방식으로도 구현할 수 있다.
- 자바의 Flow API에서 제공하는 리액티브 프로그래밍 형식은 메시지 주도 속성을 반영한다.

## 15.7 마치며

- 자바의 동시성 지원은 계속 진화해 왔으며 앞으로도 그럴 것이다.
  - 스레드 풀은 보통 유용하지만 블록되는 태스크가 많아지면 문제가 발생한다.
- 메서드를 비동기로 만들면 병렬성을 추가할 수 있으며 부수적으로 루프를 최적화한다.
- 박스와 채널 모델을 이용하여 비동기 시스템을 시각화할 수 있다.
- 자바8 CompletableFuture 클래스와 자바9 플로 API 모두 박스와 채널 다이어그램으로 표현할 수 있다.
- CompletableFuture 클래스는 한 번의 비동기 연산을 표현한다.
  - 콤비네이터로 비동기 연산을 조합하여 기존의 블록킹 문제를 해결할 수 있다.
- 플로 API는 발행-구독 프로토콜, 역압력을 이용하면 자바의 리액티브 프로그래밍의 기초를 제공한다.
- 리액티브 프로그래밍을 이용하여 리액티브 시스템을 구현할 수 있다.