# 2. Education

## 2.1 가능하면 적게 캡슐화하라.

- 객체지향에서 하나의 객체가 캡슐화하는 대상인 4개 이하로 만드는 것이다 좋다.
- 캡슐화 대상은 그 객체를 구분하기 위한 식별자 역을 한다. 이 숫자가 많아질 수록 객체의 구분이 어려워지기 때문에 4개 이하로 권장한다.
- 단순 4개 이하만 캡슐화 하는 것이 아닌, 그 캡슐화된 객체 안에도 4개 이하로 캡슐화 되어 있고 이게 이어져서 트리 형태로 만들어진다.
- 즉, 더 많은 객체가 필요하다면 클래스를 더 작은 클래스로 분리하면 된다.
- 중요한 점은 4개 이하라고 해서 아무것도 캡슐화하지 않은 객체가 포함되는 것은 아니다. 아무것도 캡슐화 하지 않은 객체는 바람직하지 않다.

## 2.2 최소한 무언가는 캡슐화 하라.

- 객체가 무언가를 캡슐화 하고 있다는 것은 그 객체를 식별할 수 있다는 것이다.
- 객체가 무언가를 캡슐화 하지 않다는 것은 그 객체를 실벽할 수 없다는 것이다.
- 특정 기능을 가진 엔티티만이 캡슐화 대상이 없고, 그 객체는 식별할 필요도, 좌표도 필요 없다.
  - 즉, 객체의 세계에서 단 하나만 존재하는 경우 캡슐화 대상이 없을 수 있다.
  - 그렇지 않다면 반드시 무언가 캡슐화 하여야 한다.

## 2.3 항상 인터페이스를 사용하라.

- 객체의 세성에서 객체들은 서로 도움을 주고 의사소통을 한다.
- 즉, 객체들은 서로 결합되는 것이다.
- 결합도는 유지보수할 때 큰 문제가 된다. 즉, 강한 결합은 유지보수를 어렵게 만들 수 있다.
- 어플리케이션의 유지보수성을 높이기 위해서는 결합을 최대한 줄여야 한다. 즉, 객체를 분리해야 한다.
- 이렇게 객체를 분리하는 도구 중 가장 훌륭한 도구가 `인터페이스`이다.
- `인터페이스`는 객체가 다른 객체와 의사소통을 하기 위한 계약(contract)라고 볼 수 있다.
- 즉, 모든 public 메소드는 인터페이스를 구현하도록 만드는 것이 좋다.
- 이렇게 인터페이스를 이용하게 되면, 인터페이스를 구현한 여러 클래스가 서로를 대체할 수 있게 되고 이것이 `느슨한 결합도(loose coupling)`을 의미하게 된다.

## 2.4 메서드 이름을 신중하게 선택하라.

- 메서드의 이름을 짓는 방법으로는 `빌더(builder)`의 이름은 `명사`로, `조정자(manipulator)`의 이름은 `동사`로 짓는 것이다.
- 빌더란 무언가를 만들고 새로운 객체를 반환하는 메서드를 의미한다.
  - 빌더는 항상 무언가를 반환하기 때문에 void일 수 없다.
  - 예를 들어
    - int pow(int base, int power);
    - float speed();
    - Employee employee(int id);
    - String parsedCell(int x, int y);
      - parsedCell에서 단순히 명사 뿐만 아니라 형용사 parsed가 포함되어 있다.
      - 형용사를 통해 더욱 풍부한 정보를 담아 Cell을 반환한다는 의미를 담고 있다.
- 조정자란 객체를 추상화한 엔티티를 수정하는 메서드를 의미한다.
  - 일반적으로 조정자의 반환 타입은 void이다.
  - 예를 들어
    - void save(String content);
    - void put(String key, Float value);
    - void remove(Employee emp);
- 빌더와 조정자 사이에는 어떠한 메서드도 존재하면 안된다. 즉, 조정 후 반환과 같은 것은 없는 것이 좋다.
  - int save(String content); // 저장 후 반환
    - int를 void로 변경하거나 byteSaved()와 같은 이름으로 변경해야 한다.
  - boolean put(String key, Float value); // map이 변경된 경우 true를 반환
    - PutOreration 인스턴스와 같은 것을 반환하도록 설계를 변경해야 한다.

### 2.4.1 빌더는 명사다.

- 빌더의 이름을 동사로 짓는 것은 잘못되었다.
- 기본적으로 무언가를 요청할 때 명령조나 구체적인 사항을 요구하지는 않는다.
  - 브라우니를 요리해 주세요. -> 브라우니 주세요
  - 커피 한 잔 끓여 주세요. -> 커피 한 잔 주세요.
- 빌더 메소드를 사용자 입장에서는 어떻게 끓이는지는 관심이 없다.
- 빌더의 이름을 동사로 짓는 것은 객체에게 할 일을 명령하는 것과 같다.
  - 이러한 방식은 객체지향이 아니라 절차지향의 접근 방식이다.
  - 이러한 것은 함수라기 보다는 프로시저(procedure)라고 볼 수 있다.
- 객체는 살아있는 유기체이고, 계약에 의해서 일을 하기 때문에 단순 명령의 일 보다는 계약에 기반하여 일을 진행한다.
- 요구자는 무엇을 만들지 요구만 할 뿐 어떻게 만들지는 객체에게 위임하는 것이다.
  - add는 더할 것을 요구하는 것이다.
  - sum은 더한 것을 요구하는 것이다.

```java
// 잘못 지어진 이름
InputStream load(Url url);
String read(File file);
int add(int x, int y);

// 수정된 이름
InputStream stream(Url url);
String content(File file);
int sum(int x, int y);
```

// 파일 삭제 메소드도 명사? 동사?

### 2.4.2 조정자는 동사다.

- 객체는 실세계의 엔티티를 의미하고, 조정자는 이러한 엔티티들을 조작하는 것이다.
- 빌더와 다르게 조정자는 무언가를 요구하고, 객체를 조정하며 반환값이 없다.

```java
class Pixel {
    void paint(Color color);
}

Pixel center = new Pixel(50, 50);

// center 객체에 red로 색칠하도록 요구
center.paint(new Color("red"));
```

### 2.4.3 빌더와 조정자 혼합하기

- 빌더와 조정자를 혼합한 메서드를 자주 사용하는 경우가 있다.
- 얼핏 보기에 문제가 없어 보이지만, 위 원칙을 위반하고 있다.

```java
class Document {
    // 빌더와 조정자가 혼합된 경우
    int write(InputStream content);
}

// 리펙토링
class Document {
    OutputPipe output();
}

class OutputPipe {
    void wirte(InputStream content);
    int bytes();
    long time();
}
```

### 2.4.4 Boolean 값을 결과로 반환하는 경우

- Boolean 값을 반환하는 경우 일반적으로 isEmpty(), equals(), existes() 형태로 짓는다.
- Boolean은 빌더이지만, 특별한 경우이기 때문에 가독성 측면에서 형용사로 짓는 것이 좋다.
  - `empty()`, `readable()`, `negative()`
  - 다만 이러한 이름의 경우 앞에 `is`를 붙여 읽는 연습을 하는 것이 좋다.
  - equal과 exists의 경우 is를 붙이면 올바른 문장이 되지 않기 때문에 equalTo, present로 쓰는 것이 좋다.

## 2.5 퍼블릭 상수(Public Constant)를 사용하지 마라.

- public static final과 같은 상수를 사용하는 이유는 객체간 데이터를 공유하기 위해서 이다.
- 하지만, 객체간에는 어떠한 데이터도 공유해서는 안된다.
  - 객체는 닫혀 있고, 독립적이어야 한다.
- 퍼블릭 상수를 사용하게 되면, 결합도가 높아지고, 응집도가 낮아지게 된다.

```java
class Records {
    void write(Wirter out) {
        for (Record rec : this.all) {
            out.write(rec.toString());
            out.write(Constants.EOL);
        }
    }
}

class Rows {
    void print(PrintStream pnt) {
        for (Row row : this.fetch()) {
            pnt.printf("{ %s }%s", row, Constants.EOL);
        }
    }
}

public class Constants {
    public static final String EOL = "\r\n";
}
```

### 2.5.1 결합도 증가

- Records와 Rows는 같은 객체인 Constants에 의존하고 있고, 이러한 의존성은 `하드코딩` 되어 있다.
- Constants.EOL을 수정하는 경우 다른 두 클래스의 행동은 예상하기 힘들다.
- 또한 Constants.EOL 입장에서는 본인이 사용되고 있는 부분을 모두 파악하기도 힘들다.

### 2.5.2 응집도 저하

- 퍼블릭 상수를 이용함에 따라 응집도가 낮아진다.
- 객체의 응집도가 낮아진 다는 것은 자신의 문제 해결에 덜 집중한다는 것이다.
- 퍼블릭 상수 자체를 사용하기 위해 특별한 자신만의 의미론을 붙여야 한다.
- 이렇게 의미론을 붙이기 위해서는 퍼블릭 상수를 사용하기 위한 클래스를 다시 정의하면 된다.
- 즉, 한 줄 종료를 의미하는 퍼블릭 상수를 쓰는 것이 아니라, 그 자체를 위임하는 객체를 만들면 되는 것이다.

```java
class EOLString {
    private final String origin;
    EOLString(String src) {
        this.origin = src;
    }
    @Override
    String toString() {
        return String.format("%s\r\n", origin);
    }
}

class Records {
    void write(Wirter out) {
        for (Record rec : this.all) {
            out.write(new EOLString(rec.toString()));
        }
    }
}

class Rows {
    void print(PrintStream pnt) {
        for (Row row : this.fetch()) {
            new EOLString(
                String.format("{ %s }", row);
            )
        }
    }
}
```

- 기존의 퍼블릭 상수 대신, 새로은 객체를 만들어 계약을 하는 것이다.
- 이러한 것은 단순 퍼블릭 상수를 사용한 것 보다 다양한 기능을 제공할 수 있게 된다.
  - ex) 윈도우의 경우 EOL을 사용할 수 없도록 만들 수 있다.

```java
String body = new HttpRequest()
    .method("POST")
    .fetch();

String body = new HttpRequest()
    .method(HttpMethods.POST)
    .fetch();

String body = new PostRequest(new HttpRequest())
    .fetch();
```

- 중복 문제를 해결하기 위해 퍼블릭 상수를 사용하는 것이 아니라, 클래스를 사용하는 것이 좋다.
- 퍼블릭 상수와 비슷하게, 열거형도 사용하면 안된다.
