# 3. Employment

## 3.1 5개 이하의 public 메소드만 노출하라.

- 작은 객체는 유지보수가 쉽고, 응집력이 높으며, 테스트가 용이하다.
- 작은 클래스를 정하는 기준으로 public 메소드의 개수를 사용하면 좋다.
  - public 메서드가 많아지면 클래스는 커진다.
  - 클래스가 커지면 유지보수성은 저하된다.
  - 가장 `이상적인 public 메서드`의 개수는 `5개` 이다.
- 클래스가 작아지면 클래스의 모든 메서드가 모든 프로퍼티와 상호작용할 가능성이 높다.

## 3.2 정적 메서드를 사용하지마 마라.

- 정적 메서드는 객체 패러다임의 남용이다.
- 정적 메서드는 유지보수를 어렵게 만든다.

### 3.2.1 객체 대 컴퓨터 사고(object vs computer thinking)

- 컴퓨터 사고 즉, 컴퓨터 입장에서 생각한다는 것은 `순차적`인 사고방식이다.
- 컴퓨터적 사고는 명령 실행의 흐름 제어에 대한 책임을 우리가 가지게 된다.
- 객체지향적으로 생각한다는 것은 객체들이 필요할 때 스스로 상호작용하도록 위임한다는 것이다.

### 3.2.2 선언형 스타일 대 명령형 스타일(declarative vs imperative style)

- 선언형 스타일은 제어 흐름을 서술하지 않고 `계산로직을 표현`한다.
  - 엔티티와 엔티티 사이의 `관계` 그 자체와 비슷하다.
- 명령형 스타일은 프로그램의 상태를 변경하는 문장을 사용하여 `계산 방식을 서술`한다.
  - 위 컴퓨터 연산과 같이 차례대로 명령을 수행한다.
- 명령형 스타일은 계산이 즉시 수행되는 반면, 선언형 스타일은 표현만 할 뿐 계산이 즉시 수행되지 않는다.

```java
// 명령형
int y = Math.between(5, 9, 13); // 즉시 9를 반환.

// 선언형
Number y = new Between(5, 9, 13); // 즉시 반환하지 않음.
```

- 선언형이 명령형 보다 좋은 이유 4가지가 존재한다.

1. `최적화`가 가능하다는 것이다.
   - 대표적인 명령형 스타일으로는 정적 메소드가 존재하고, 이러한 정적 메소드들은 즉시 값을 계산하기 때문에 최적화가 힘들다.
   - 선언형 스타일은 단순히 선언만 되어 있기 때문에 계산하는 시기를 최적화할 수 있다.
   - 단순하 하나의 계산만 한다면 선언형이 더 느릴 수 있지만, 여러 계산이 있다면 선언형은 최적화를 통해 더 빠르게 바꿀 수 있다.
2. `다형성`이 있다.
   - OOP에서 객체는 정적 메소드와 달리 일급 시민이기 때문에 객체를 어디서든 전달할 수 있다.
   - 객체는 다른 객체와 연결되어 데이터를 주고 받을 수 있다는 것이다.
3. `표현력`
   - 명령형은 수행 가능한 한 가지 방법을 이야기하기 때문에 결과를 알기 위해서는 방법을 머릿속에서 시뮬레이션 해야 한다.
   - 선언형은 결과를 이야기 하기 때문에 직관적으로 결과를 알 수 있다.
4. `응집도`
   - 선언형의 경우 클래스 안에 관련된 로직이 뭉쳐 있기 때문에 분리가 불가능하다.
   - 실수로 코드 순서를 바꿀 수도 없으며, 그에 따른 알고리즘 오류가 발생할 가능하도 줄어준다.
   - 명령형의 경우 로직이 분리되어 있기 때문에 코드 순서가 변경됨에 따른 오류가 발생할 가능성이 높아진다.

- 정적 메소드는 암적인 존재이기 때문에 사용하면 할수록 제거하기 어려워지기 때문에 사용하면 안된다.
  - 이미 정적 메소드가 존재한다면, 정적 메소드를 감싸는 객체를 통해 정적 메소드를 고립시켜야 한다.

### 3.2.3 유틸리티 클래스(Untility classes)

- java.lang.Math와 같은 유틸리티 클래스는 많이 사용된다.
- 이러한 유틸리티 클래스는 앞서 설명한 `객체의 팩토리`라는 클래스의 정의와 충돌된다.
- 유틸리티 클래스는 객체의 팩토리가 아니기 때문에 진짜 클래스라고 부를 수 없다.
- 유틸리티 클래스는 OOP에서 남아 있는 절차지향의 상징이라고 볼 수 있다.
- 유틸리티 클래스가 정적 메소드와 같은 나쁜 단점들을 모아 놓은 집합체이자 끔찍한 안티 패턴이다.

### 3.2.4 싱글톤(Singleton) 패턴

- 싱글톤 패턴은 오직 하나의 인스턴스만 존재하는 객체이다.
- 싱글톤 패턴은 매우 유명한 디자인 패턴이지만, 끔찍한 안티 패턴이다.
- 싱글톤 객체가 유틸리티 클래스와 다른점으로는 객체 간 의존성을 분리할 수 있다는 점이다.
  - 싱글톤 패턴은 내부에 캡슐화된 객체를 변경할 수 있다.
- 싱글톤은 유틸리티 클래스보다 낫다고 할 수 있지만, 끔찍한 안티 패턴인 것은 변함없다.

### 3.2.5 함수형 프로그래밍

- 객체의 크기가 작아지고, 상태가 변하지 않으면서 정적 메소드가 없다면 함수형 프로그래밍과 유사해진다.
- 함수형 프로그래밍이 아니라 OOP를 사용하는 이유는 표현력이 더 뛰어나고, 객체와 메서드를 조합할 수 있기 때문이다.
- 이상적인 OOP에는 클래스와 함수가 같이 존재하며, 작은 프로시저로 동작하는 것이 아닌 하나의 출구(exit point)만 포함한 순수 함수를 지향하는 함수를 포함하는 것이다.

### 3.2.6 조합 가능한 데코레이터

- 조합 가능한 데코레이터란 다른 객체를 감싸는 객체를 의미한다.

```java
names = new Sorted(
    new Unique(
        new Capitalized(
            new Replaced(
                new FileNames(
                    new Directory(
                        "/var/users/*.xml"
                    )
                ),
                "([^.]+)\\.xml",
                "$1"
            )
        )
    )
)
```

- 위 객체는 매우 깔끔하면서 객체지향적이다.
- 순수하게 선언형이며 객체의 이름만 봐도 어떠한 객체인지 알 수 있다.
- 데코레이터 객체들은 전체적인 행동을 내부에 캡슐화하고 있으며 조합가능하다.
- 프로그래머는 데코레이터를 조합하는 일 외에 다른 일은 하면 안된다.

## 3.3 인자의 값으로 NULL을 절대 허용하지 마라.

- NULL이라는 것은 C에서 주소로 사용하지 않겠다고 약속한 주소에서 부터 시작되었다.
- Java와 같은 OOP에서는 NULL은 존재하지 않아도 생각한다.
- 객체가 NULL인지 확인하는 것은 객체를 무시하는 행위이다.
- 아무것도 존재하지 않다 라는 뜻은 NULL이 아니라 그러한 객체로 표현하면된다.
- NULL이 아닌 객체를 사용하더라고, 사용자 입장에서 NULL을 전달할 수 있다.
  - 이럴때에는 NULL 체크 후 예외를 던지거나, NULL이 들어오지 않는다고 가정하여 무시하는 방법이 있다.
  - NULL이 들어온 경우 NullPointerException을 통해 메소드 호출자에게 알려주는 방법은 좋은 방법이다.
- 중요하지 않은 NULL 확인 로직을 통해 코드를 오염시키면 안된다.

```java
// mask가 존재하는 경우 해당 파일을 찾고, 그렇지 않으면 모든 파일을 찾는다.

// 잘못된 방법
public Iterable<File> find(Mask mask) {
    if (mask == null) {
        // 모든 파일을 찾는다.
    } else {
        // 마스크를 사용하여 파일을 찾는다.
    }
}

// 옳은 방법
public Iterable<File> find(Mask mask) {
    if (mask.empty()) {
        // 모든 파일을 찾는다.
    } else {
        // 마스크를 사용하여 파일을 찾는다.
    }
}
```

## 3.4 충성스러우면서 불면이거나, 아니면 상수이거나

- 불변객체에 대해 일반적으로 혼동하는 것은 불변 객체의 메소드는 호출할 때마다 동일한 데이터가 반환된다고 착각하는 것이다.
- 불변 객체란 메소드의 결과가 불변인 것이 아니라 객체가 불변인 객체를 의미한다.
- 모든 객체는 식별자, 상태, 행동을 가지고 있다.
- 불변 객체는 별도의 식별자가 존재하지 않으며 식별자와 상태가 완전히 동일하다.
  - 간단하게, 불변 객체는 상태가 같은 경우 equals의 값이 같다.
  - 즉, 가변 객체는 상태 변경이 가능하기 때문에 별도의 식별가 필요해진다.
- 불변 객체는 자신이 대표하는 실세계 엔티티에 충성하기 때문에 엔티티의 좌표를 절대로 변경하지 않는다.

## 3.5 절대 getter, setter를 사용하지 마라.

### 3.5.1 객체 대 자료구조

- 자료구조(struct)와 달리 객체는 멤버를 노출하지 않기 때문에 직접 접근도 불가능하며, 메소드가 어떠한 방식으로 동작을 하는지 알 수 없다.
- 즉, 객체는 자료구조와 달리 캡슐화되어 있다고 할 수 있다.
- 객체는 단순한 자료구조와 달리 살아 있다고 표현할 수 있다.
- 객체들은 서로 연결되고, 메시지를 전송하며 작업을 실행한다.
- 객체를 초기화 한다는 것은 소프트웨를 만드는 것과 같다고 볼 수 있다.

### 3.5.2 좋은 의도, 나쁜 결과

- getter와 setter는 캡슐화 원칙을 위반하기 위해 설계되었다고 볼 수 있다.
- getter와 setter는 메서드처럼 보이지만, 사실은 그냥 데이터에 직접 접근하는 것과 같다.
- 즉, getter와 setter는 자료구조에서 데이터를 접근하는 것과 같다.

### 3.5.3 접두사에 관한 모든 것.

- get과 set 같은 접두사들은 객체를 자료구조 형태로 만드는다고 할 수 있다.
- `getDollars`라는 이름은 데이터 중 dollars를 찾아 반환한다 라는 의미를 가지기 때문에 데이터를 노출하게 된다.
- `dollars`는 얼마나 많은 달러를 원하는가? 라는 의미를 가진다.
- 이렇게 get, set과 같은 접두사들은 OOP의 끔찍한 안티패턴이 된다.

## 3.6 부 생성자 밖에서는 new를 사용하지 마라.

- 부 생성자 외에 다른 메서드의 내부에서 new를 사용하여 객체를 생성하게 되면, 그 객체에 대한 의존성이 높아진다.
- 외부에서 객체를 생성한 후 매개변수로 받아 전달하는 방식으로 변경하게 되면, 의존성이 낮아진다.
- 이렇게 클래스와 클래스가 직접적으로 연결된 경우를 `하드코딩된 의존성`이라고 한다.
- `하드코딩된 의존성`을 줄이기 위해서 가장 간단하고 좋은 방법은 `부 생성자`에서만 new를 사용하는 것이다.

## 3.7 인트로스펙션(introspection)과 캐스팅(casting)을 피하라.

- 타입 인트로스펙션과 캐스팅은 피하는 것이 좋다.
  - 타입 인트로스펙션은 자바에서 리플렉션이라고 보면 된다.
- 리플렉션을 사용하면 메서드, 명령어, 구문, 클레스, 객체, 타입 등을 변경할 수 있지만, 런타임에서 진행되기 때문에 유지보수가 굉장히 어려워진다.
