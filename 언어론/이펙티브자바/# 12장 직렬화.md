# 12장 직렬화

## 아이템 85. 자바 직렬화의 대안을 찾으라

- 자바의 직렬화는잠재적인 문제가 있었다.
  - 공격 범위가 너무 넓어서 방어하기 어렵다.
  - ObjectInputStream의 readObject 메서드 호출 시 모든 것을 다 알 수 있다.
- 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.
- 새로운 시스템에서는 자바 직렬화를 써야 할 이유는 전혀 없다.
- 자바 직렬화 대신 크로스 플랫폼 구조화된 표현을 쓰자.
  - 이러한 표현은 속성-값 쌍의 집합으로 이루어져 있다.
  - 자바 직렬화보다 훨씬 간단하다.
- 크로스-플랫폼 구조화된 데이터 표현의 선두주자는 JSON과 프로토콜 버퍼(protobuf)다.
- 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이 중요하다.
- 그래도 자바 직렬화를 쓰고 싶다면 역직렬화 필터링(ObjectInputFilter)를 사용하자.
  - 블랙 리스트 방식 보다는 화이트 리스트 방식을 사용하자.

## 아이템 86. Serializable을 구현할지는 신중히 결정하라.

- 클래스 인스턴스 직렬화 시 클래스 선언에 implements Serializable만 붙이면 된다.
- Serializable을 구현하면 릴리즈한 뒤에는 수정하기 어렵다.
- 직렬화되면, 해당 클래스와 직렬화 형태가 영원히 지원되어야 한다.
- Serializable 구현은 버그와 보안 구멍이 생길 위험이 높아진다.
- 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 되며, 인터페이스도 대부분 Serializable을 확장해서도 안 된다.
- 내부 클래스는 직렬화를 구현하지 말아야 한다.

## 아이템 87. 커스텀 직렬화 형태를 고려해보라

- 먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라.
- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.
- 기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.
- 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 크게 네 가지 면에서 문제가 생긴다.
  - 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
  - 너무 많은 공간을 차지할 수 있다.
  - 시간이 너무 많이 걸릴 수 있다.
  - 스택 오버플로를 일으킬 수 있다.

## 아이템 88. readObject 메서드는 방어적으로 작성하라.

- readObject는 실질적으로 또 다른 public 생성자이기 때문에 주의를 기울여야 한다.
- readObject 역시 보통의 생성자 처럼 메서드 인수가 유효한지 검사해야 하고, 필요하다면 매개변수를 방어적으로 복사해야 한다.
- 간단하게 말해, readObject는 바이트 스트림을 받는 생성자라고 할 수 있다.
- 객체를 역직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 반드시 방어적으로 복사해야 한다.

```java
private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    s.defaultReadObject();

    // 가변 요소 방어적 복사
    start = new Date(start.getTime());
    end = new Date(end.getTime());

    // 불변식을 만족하는지 검사
    if(start.compareTo(end) > 0) {
        throw new InvalidObjectException(start + "가 " + end + "보다 늦다.")'
    }
}
```

- 기본 readObject 사용 여부 판단
  - transient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사 없이 필드에 대힙하는 public 생성자를 추가해도 되는가?
    - yes -> 기본 readObject 메서드 사용 가능
    - no -> 방어적 복사를 적용한 readObject 메서드 만들기
- 방어적 readObject 대신 직렬화 프록시 패턴을 사용해도 좋다.
- final이 아닌 직렬화 가능 클래스라면 readObject 메서드에서 재정의 가능 메서드를 호출해서는 안 된다.

### 안전한 readObject 메서드 작성 지침

- private이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라.
- 모든 불변식을 검사하여 어긋나는 게 발견되면 InvalidObjectException을 던져라.
  - 방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.
- 역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용하라.
- 직접적이든 간접적이든, 재정의할 수 있는 메서드는 호출하지 말자.

## 아이템 89. 인스턴스 수를 통제해야 한다면 readResolve 보다는 열거 타입을 사용하라.

- readResolve 기능을 이용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다.
- readResolve를 인스턴스 통제 목적으로 사용한다면, 객체 참조 타입 인스턴스 필드는 모두 transient로 선언해야 한다.

## 아이템 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라.

- 직렬화 프록시 패턴(serialization proxy pattern)을 사용하면 직렬화의 위험을 크게 줄여줄 수 있다.
- 직렬화 프록시 패턴은 구현
  - 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 설계하여 private static으로 선언한다.
  - 중첩 클래스는 바깥 클래스의 직렬화 프록시가 된다.
  - 중첩 클래스의 생성자는 반드시 단 하나여야 하며, 바깥 클래스를 매개변수로 받아야 한다.
  - 중첩 클래스의 생성자는 단순히 인스턴스의 데이터를 복사하는 역할만 한다.
  - 바깥 클래스와 중첩 클래스 모두 Serializable을 구현한다고 선언해야 한다.
- 프로세스 정리
  - Class A -> 직렬화 -> Proxy Class A를 직렬화 -> 바이트 스트림
  - 바이트 스트림 -> 역직렬화 -> Proxy Class A -> Class A
- Proxy Class가 외부에 노출되는 것이기 때문에 원래 클래스는 숨길 수 있다.
- 직렬화 프록시는 일반 인스턴스 만드는 것 처럼 생성자나 정적 펙터리를 통해 역직렬화된 인스턴스를 만들기 떄문에 불변식에 대한 검사를 따로 구현할 필요가 없다.
  - 프록시 객체는 단순 값을 역직렬화만 하고, 원래 객체는 기존 로직에서 사용하던 검사를 그대로 사용한다.

### 직렬화 프록시 패턴 한계

- 클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없다.
- 객체 그래프에 순환이 있는 클래스에는 적용할 수 없다.
- 성능이 느리다.(방어적 복사보다 약 14% 정도 느림)
