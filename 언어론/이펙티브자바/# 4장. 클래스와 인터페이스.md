# 4장. 클래스와 인터페이스

## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라.

- 잘 설계된 컴포넌트란 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐에 결정된다.
  - 즉, 정보 은닉 혹은 컵슐화라고 하는 개념이 얼마나 잘 구현되었는가 이다.
- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.
  - 오직 API를 통해서만 다른 컴포넌트와 소통하며, 서로의 내부 동작 방식에는 전혀 개의치 않는다.
- 정보 은닉의 장점
  - 시스템 개발 속도를 높인다.
    - 여러 컴포넌트를 병렬로 개발할 수 있다.
  - 시스템 관리 비용을 낮춘다.
    - 컴포넌트 파악을 빨리 할 수 있기 때문에 디버깅하기 쉽다.
    - 다른 컴포넌트로 교체하기가 쉽다.
  - 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에는 도움을 준다.
    - 최적화할 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있다.
  - 소프트웨어 재상용성을 높일 수 있다.
    - 외부에 의존하지 않기 때문에 낯선 환경에서도 유용하게 쓰을 가능성이 크다.
  - 큰 시스템을 제작하는 난이도를 낮춰준다.
    - 시스템 전체가 완성되지 않은 상태에서도 개별 동작을 검증할 수 있다.
- 접근 제한자를 활용하여 정보 은닉을 구현할 수 있다.
  - private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
  - package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.(default)
  - protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
  - public: 모든 곳에서 접근할 수 있다.
- 가장 근본적인 원칙은 `모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다`이다.
- 일반적으로 모든 멤버를 private로 만들고 필요에 따라서 권한 제한을 풀어주는 방식으로 접근하면 되지만, 권한을 자주 풀어주게 되면 컴포넌트를 더 분해해야 하는지 고민해야 한다.
- 접근 제한 설정 시 상속을 한다면, 접근 수준을 상위 클래스보다 좁게 설정할 수 없기 때문에 주의해야 한다.
  - 상위 public -> 하위 protected 불가능
  - 상위 protected -> 하위 public 가능
  - 인터페이스의 경우 좁게 설정할 수 없고, 무조건 public으로 선언해야 한다.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
  - 가변 객체를 참조하거나 final이 아닌 인스턴스 필드를 public으로 선언하면 값을 제한할 힘을 잃게 된다.
  - public 가변 필드를 갖는 클래스는 일반적으로 스레드에 안전하지 않다.
  - 해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소가 상수라면, `public static final`로 공개해도 된다.
    - 관례상 이런 상수의 이름은 대문자 알파벳과 문자 사이에 밑줄(_)을 넣는다.
    - 이런 타입은 반드시 기본 타입이거나 불변 객체를 참조해야 한다.
- public static final 배열 필드는 접근할 수 있거나 반환하는 접근자 메서드를 제공해서는 안된다.
  - 배열의 경우 예상과 다른 동작을 할 수 있다.(final은 배열의 주소일 뿐, 배열의 원소 값은 수정이 된다.)
  - 이 경우 배열을 private로 만들고 같은 내용의 불변 리스트를 public으로 제공하면 된다.
  - 또는, 배열을 private로 만들고 같은 내용의 복사본 배열을 public으로 제공하면 된다.

### 핵심 정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라.
- 꼭 필요한 것만 골라 최소한의 public API를 설계하자.
  - 그 외 클래스, 인터페이스, 멤버가 의도치 않고 API로 공개되는 일이 없도록 해야 한다.
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.
- public static final 필드가 참조하는 객체가 불변인지 확인하라.

## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.

- public 클래스에서 필드를 public으로 선언하게 되면, 캡슐화의 이점을 제공하지 못한다.
- API를 수정하지 않고는 내부 표현을 바꿀 수 없고, 불변식을 보장할 수 없으며, 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없다.
- 이러한 클래스는 필드를 모두 private로 바꾸고 public 접근자(getter)를 추가하는게 좋다.
- 패키지 밖에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.
- package-private 클래스나 private 중첩 클래스의 경우 데이터 필드를 노출해도 괜찮다.
  - 패키지 바깥 코드는 전혀 손대지 않고 데이터 표현 방식을 바꿀 수 있다.
- java.awt.package의 Point와 Dimension 클래스의 경우 외부에 멤벌르 노출하고 있어서 잘못 구현되어 있다.
- public 클래스의 필드가 불변이라면, 직접 노출할 때 단점이 조금 줄어들긴 하지만 여전히 좋은 방법은 아니다.

### 핵심 정리

- public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다.
- 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
- package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다.

## 아이템 17. 변경 가능성을 최소화하라.

### 불변 객체

- 불변 클래스란 인스턴스 내부 값을 수정할 수 없는 클래스다.
  - 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.
  - String, 기본 타입 박싱 클래스, BigInteger, BigDecimal 등이 불변 클래스다.
- 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.
- 불변 객체 장점
  - 불변 객체는 그 자체로 실패 원자성(failure atomicity)을 제공한다.
    - 실패 원자성이란 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태임을 의미한다.
  - 불변 객체는 근본적으로 스레드 안전하기 때문에 동기화를 걱정할 필요가 없다.
- 불변 클래스 단점
  - 값이 다르면 반드시 독립된 객체로 만들어야 한다.
    - 값의 가짓수가 많다면 이들을 모두 만드는데 큰 비용이 필요하다.
    - 이러한 단점을 해결하기 위해서는 다단계 연산(multistep operation)을 예측하여 기본 기능으로 제공하거나 가변 동반 클래스를 제공하면 된다.
- 불변 클래스 구현 규책
  - 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
  - 클래스를 확장할 수 없도록 한다.
    - 하위 클래스에서 부주의하게 객체 상태를 변하게 만드는 사태를 막는다.
    - 확장을 막기 위해 final 클래스로 선언할 수도 있지만, 생성자를 private로 만들고 정적 펙터리를 제공해도 된다.
    - BigInteger와 BigDecimal는 확장할 수 있는 객체이기 때문에 진짜 해당 객체인지 확인해야 하는 번거로움이 있다.
  - 모든 필드를 final로 선언한다.
  - 모든 필드를 private로 선언한다.
    - private로 선언하여 클라이언트가 가변 객체에 접근하여 변경하는 것을 막는다.
  - 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    - 클래스에 가변 객체 필드가 있다면 클라이언트에서 참조를 얻게 하면 안된다.
    - 가변 객체 필드는 클라이언트에서 제공하는 값을 가리키게 하면 안된다.
    - 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행해야 한다.
- 메서드를 함수형으로 만들면 변경 가능성을 최소화할 수 있다.
  - 함수형 프로그래밍이란 피연산자에 함수를 적용하여 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 말한다.
- 모든 생성자가 클래스 불변식(class invariant)을 보장한다면 그 클래스를 사용한는 프로그래머가 다른 노력을 들이지 않아도 불변으로 남는다.
- 불변 객체는 한번 만든 인스턴스를 최대한 재활용 하는 것이 좋다.
  - 재활용하기 위해 가장 쉬운 방법은 자주 사용하는 값들을 상수(public static final)로 제공하는 것이다.
  - 불변 클래스를 자주 사용되는 인스턴스를 캐싱하여 정적 팩터리를 제공할 수 있다.
    - 박싱된 기본 타입과 BigInteger가 이러한 방식을 사용한다.
- 불변 객체는 자유롭게 공유할 수 있기 때문에 방어적 복사도 필요 없다.
  - 원본과 복사본이 일치하여 복사 자체가 의미가 없기 때문에 clone 메서드나 복사 생성자를 제공하지 않는 것이 좋다.
- 불변 객체끼리는 내부 데이터를 공유해도 좋다.

### 정리

- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
  - 단순 값 객체는 항상 불변으로 만들어라.
- 불변 클래스는 장점이 많으며 단점이라곤 특정 상황에서의 잠재적 성능 저하뿐이다.
  - 무거운 값 객체도 불변으로 만들 수 있는지는 고심해야 한다.
- 성능 때문에 고민된다면, 불변 클래스와 쌍을 이루는 가변 동반 클래스를 제공하는 것이 좋다.
- 불변으로 만들 수 없다면, 변경할 수 있는 부분을 최소로 줄여라.
  - 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
  - 꼭 변경해야 할 필드를 뺀 나머지 모두를 `final`로 선언하라.
- 다른 합당한 이유가 없다면 모든 필드는 `private final`이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
- 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안 된다.
- 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안 된다.