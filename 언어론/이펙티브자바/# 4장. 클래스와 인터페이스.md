# 4장. 클래스와 인터페이스

## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라.

- 잘 설계된 컴포넌트란 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐에 결정된다.
  - 즉, 정보 은닉 혹은 컵슐화라고 하는 개념이 얼마나 잘 구현되었는가 이다.
- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.
  - 오직 API를 통해서만 다른 컴포넌트와 소통하며, 서로의 내부 동작 방식에는 전혀 개의치 않는다.
- 정보 은닉의 장점
  - 시스템 개발 속도를 높인다.
    - 여러 컴포넌트를 병렬로 개발할 수 있다.
  - 시스템 관리 비용을 낮춘다.
    - 컴포넌트 파악을 빨리 할 수 있기 때문에 디버깅하기 쉽다.
    - 다른 컴포넌트로 교체하기가 쉽다.
  - 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에는 도움을 준다.
    - 최적화할 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있다.
  - 소프트웨어 재상용성을 높일 수 있다.
    - 외부에 의존하지 않기 때문에 낯선 환경에서도 유용하게 쓰을 가능성이 크다.
  - 큰 시스템을 제작하는 난이도를 낮춰준다.
    - 시스템 전체가 완성되지 않은 상태에서도 개별 동작을 검증할 수 있다.
- 접근 제한자를 활용하여 정보 은닉을 구현할 수 있다.
  - private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
  - package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.(default)
  - protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
  - public: 모든 곳에서 접근할 수 있다.
- 가장 근본적인 원칙은 `모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다`이다.
- 일반적으로 모든 멤버를 private로 만들고 필요에 따라서 권한 제한을 풀어주는 방식으로 접근하면 되지만, 권한을 자주 풀어주게 되면 컴포넌트를 더 분해해야 하는지 고민해야 한다.
- 접근 제한 설정 시 상속을 한다면, 접근 수준을 상위 클래스보다 좁게 설정할 수 없기 때문에 주의해야 한다.
  - 상위 public -> 하위 protected 불가능
  - 상위 protected -> 하위 public 가능
  - 인터페이스의 경우 좁게 설정할 수 없고, 무조건 public으로 선언해야 한다.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
  - 가변 객체를 참조하거나 final이 아닌 인스턴스 필드를 public으로 선언하면 값을 제한할 힘을 잃게 된다.
  - public 가변 필드를 갖는 클래스는 일반적으로 스레드에 안전하지 않다.
  - 해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소가 상수라면, `public static final`로 공개해도 된다.
    - 관례상 이런 상수의 이름은 대문자 알파벳과 문자 사이에 밑줄(\_)을 넣는다.
    - 이런 타입은 반드시 기본 타입이거나 불변 객체를 참조해야 한다.
- public static final 배열 필드는 접근할 수 있거나 반환하는 접근자 메서드를 제공해서는 안된다.
  - 배열의 경우 예상과 다른 동작을 할 수 있다.(final은 배열의 주소일 뿐, 배열의 원소 값은 수정이 된다.)
  - 이 경우 배열을 private로 만들고 같은 내용의 불변 리스트를 public으로 제공하면 된다.
  - 또는, 배열을 private로 만들고 같은 내용의 복사본 배열을 public으로 제공하면 된다.

### 핵심 정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라.
- 꼭 필요한 것만 골라 최소한의 public API를 설계하자.
  - 그 외 클래스, 인터페이스, 멤버가 의도치 않고 API로 공개되는 일이 없도록 해야 한다.
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.
- public static final 필드가 참조하는 객체가 불변인지 확인하라.

## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.

- public 클래스에서 필드를 public으로 선언하게 되면, 캡슐화의 이점을 제공하지 못한다.
- API를 수정하지 않고는 내부 표현을 바꿀 수 없고, 불변식을 보장할 수 없으며, 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없다.
- 이러한 클래스는 필드를 모두 private로 바꾸고 public 접근자(getter)를 추가하는게 좋다.
- 패키지 밖에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.
- package-private 클래스나 private 중첩 클래스의 경우 데이터 필드를 노출해도 괜찮다.
  - 패키지 바깥 코드는 전혀 손대지 않고 데이터 표현 방식을 바꿀 수 있다.
- java.awt.package의 Point와 Dimension 클래스의 경우 외부에 멤벌르 노출하고 있어서 잘못 구현되어 있다.
- public 클래스의 필드가 불변이라면, 직접 노출할 때 단점이 조금 줄어들긴 하지만 여전히 좋은 방법은 아니다.

### 핵심 정리

- public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다.
- 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
- package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다.

## 아이템 17. 변경 가능성을 최소화하라.

### 불변 객체

- 불변 클래스란 인스턴스 내부 값을 수정할 수 없는 클래스다.
  - 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.
  - String, 기본 타입 박싱 클래스, BigInteger, BigDecimal 등이 불변 클래스다.
- 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.
- 불변 객체 장점
  - 불변 객체는 그 자체로 실패 원자성(failure atomicity)을 제공한다.
    - 실패 원자성이란 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태임을 의미한다.
  - 불변 객체는 근본적으로 스레드 안전하기 때문에 동기화를 걱정할 필요가 없다.
- 불변 클래스 단점
  - 값이 다르면 반드시 독립된 객체로 만들어야 한다.
    - 값의 가짓수가 많다면 이들을 모두 만드는데 큰 비용이 필요하다.
    - 이러한 단점을 해결하기 위해서는 다단계 연산(multistep operation)을 예측하여 기본 기능으로 제공하거나 가변 동반 클래스를 제공하면 된다.
- 불변 클래스 구현 규책
  - 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
  - 클래스를 확장할 수 없도록 한다.
    - 하위 클래스에서 부주의하게 객체 상태를 변하게 만드는 사태를 막는다.
    - 확장을 막기 위해 final 클래스로 선언할 수도 있지만, 생성자를 private로 만들고 정적 펙터리를 제공해도 된다.
    - BigInteger와 BigDecimal는 확장할 수 있는 객체이기 때문에 진짜 해당 객체인지 확인해야 하는 번거로움이 있다.
  - 모든 필드를 final로 선언한다.
  - 모든 필드를 private로 선언한다.
    - private로 선언하여 클라이언트가 가변 객체에 접근하여 변경하는 것을 막는다.
  - 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    - 클래스에 가변 객체 필드가 있다면 클라이언트에서 참조를 얻게 하면 안된다.
    - 가변 객체 필드는 클라이언트에서 제공하는 값을 가리키게 하면 안된다.
    - 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행해야 한다.
- 메서드를 함수형으로 만들면 변경 가능성을 최소화할 수 있다.
  - 함수형 프로그래밍이란 피연산자에 함수를 적용하여 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 말한다.
- 모든 생성자가 클래스 불변식(class invariant)을 보장한다면 그 클래스를 사용한는 프로그래머가 다른 노력을 들이지 않아도 불변으로 남는다.
- 불변 객체는 한번 만든 인스턴스를 최대한 재활용 하는 것이 좋다.
  - 재활용하기 위해 가장 쉬운 방법은 자주 사용하는 값들을 상수(public static final)로 제공하는 것이다.
  - 불변 클래스를 자주 사용되는 인스턴스를 캐싱하여 정적 팩터리를 제공할 수 있다.
    - 박싱된 기본 타입과 BigInteger가 이러한 방식을 사용한다.
- 불변 객체는 자유롭게 공유할 수 있기 때문에 방어적 복사도 필요 없다.
  - 원본과 복사본이 일치하여 복사 자체가 의미가 없기 때문에 clone 메서드나 복사 생성자를 제공하지 않는 것이 좋다.
- 불변 객체끼리는 내부 데이터를 공유해도 좋다.

### 정리

- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
  - 단순 값 객체는 항상 불변으로 만들어라.
- 불변 클래스는 장점이 많으며 단점이라곤 특정 상황에서의 잠재적 성능 저하뿐이다.
  - 무거운 값 객체도 불변으로 만들 수 있는지는 고심해야 한다.
- 성능 때문에 고민된다면, 불변 클래스와 쌍을 이루는 가변 동반 클래스를 제공하는 것이 좋다.
- 불변으로 만들 수 없다면, 변경할 수 있는 부분을 최소로 줄여라.
  - 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
  - 꼭 변경해야 할 필드를 뺀 나머지 모두를 `final`로 선언하라.
- 다른 합당한 이유가 없다면 모든 필드는 `private final`이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
- 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안 된다.
- 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안 된다.

## 아이템18. 상속보다는 컴포지션을 사용하라.

- 상속은 코드 재사용을하는 강력한 수단이지만, 항상 최선은 아니다.
  - 여기서 말하는 상속은 다른 클래스를 확장하는 것이다.(인터페이스 제외)
  - 잘못 사용하게 되는 경우 오류를 내기 쉬운 소프트웨어를 만들게 된다.
  - 같은 패키지 안에서 통제되거나 확장할 목적으로 설계되고 문서화가 잘 되어 있다면 안전할 수 있다.
- 메소드 호출과 달리 상속은 캡슐화를 깨뜨린다.
  - 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
  - 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있기 때문에 하위 클래스가 오동작할 수 있다.
- 단순 상속 후 메소드를 재정의 하지 않고 새로운 메소드를 만든다고 문제가 해결되지는 않는다.
  - 상위 클래스에서 똑같은 이름의 메소드가 추가되면, 컴파일이 되지 않거나 오동작할 수 있다.
- 이러한 상속 문제를 해결하기 위해서는 상속 보다는 컴포지션을 사용하면 된다.
  - 컴포지션이란 상속 대신 새로운 클래스를 만들고, private 필드로 기존 클래스의 인스턴스를 참조하게 하는 것이다.
  - 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션(composition)이라 한다.
- 컴포지션을 이용하면 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어날 수 있다.
- 상속은 반드시 하위 클래스가 상위 클래스의 `진짜` 하위 타입인 상황에서만 쓰여야 한다.
  - 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다.
- 컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴이다.
  - API가 내부 구현에 묶일 수 있고, 클래스 성능도 영원히 제한된다.
  - 클라이언트가 노출된 내부에 직접 접근할 수 있다.
- 컴포지션 대신 상속을 사용할 경우 자문해야 하는 질문들
  - 확장하려는 클래스의 API에 아무런 결홤이 없는가?
  - 결함이 있다면, 이 결함이 클래스의 API까지 전파되어도 괜찮은가?

### 핵심 정리

- 상속은 강력하지만 캡슐화를 해친다는 문제가 있다.
- 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다.
  - is-a 관계라 하더라도 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 문제가 될 수 있다.
- 상속의 취약점을 피하기 위해 컴포지션과 전달을 사용하자.
- 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
  - A 메서드가 자신의 또 다른 B 메서드를 호출하고, B 메서드가 재정의 가능하다면 문서로 남겨야 한다.
- 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다.
- 즉, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
- 호율적인 하위 클래스를 큰 어려움 없이 만들기 위해서는 클래스 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개할 수 있어야 한다.
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어 보는 것이 `유일`하다.
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
  - 상위 클래스의 생성자가 하위 클래스 생성자보다 먼저 실행되기 때문에 재정의한 메서드를 호출할 경우 문제가 생길 수 있다.
- 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.
  - 클래스를 final로 선언한다.
  - 생성자를 private, package-private로 선언하고 public 정적 팩터리를 제공한다.

### 핵심 정리

- 상속용 클래스를 설계하기란 결코 만만치 않다.
- 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 문서화된 것은 반드시 지켜야 한다.
- 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다.
- 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 수 있다.

## 아이템20. 추상 클래스보다는 인터페이스를 우선하라.

- 자바에서는 다형성을 구현하기 위해 추상 클래스와 인터페이스를 사용한다.
- 추상 클래스와 인터페이스의 가장 큰 차이는 하위 클래스가 되는가? 이다.
  - 추상 클래스를 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 된다.
    - 자바에서는 단일 상속만 지원하기 때문에 새로운 타입을 정의할 때 커다란 제약이 존재한다.
  - 인터페이스는 다른 클래스를 상속해도 같은 타입으로 취급한다.
- 즉, 기존 클래스에도 손쉽게 새로운 인터페이스를 구현할 수 있다는 것이다.
- 이러한 특징 때문에 인터페이스는 `믹스인(mixin)` 정의에 안성맞춤이다.
  - `믹스인`이란 클래스가 구현할 수 있는 타입으로, 클래스의 주된 타입 외에도 특정 선택적 행위를 제공한다고 선언하는 것이다.
  - Comparable을 구현한 클래스들은 인스턴스들끼리 순서를 정할 수 있다고 선언하는 것과 같다.
  - 추상 클래스의 경우 기존 클래스에 새로운 기능을 덧씌울 수 없기 때문에 믹스인을 정의할 수 없다.
- 또한, 인터페이스의 경우 `계층 구조가 없는 타입 프레임워크`를 만들 수 있다.
  - 일반적으로 계층을 정의하면 구조적으로 잘 만들 수 있지만, 계층을 구분하기가 어려운 개념도 존재한다.
  - 클래스는 상속을 통해서 계층을 정의해야 하고, 자바에서는 단일 상속만 지원하기 때문에 모든 경우에 대해 계층을 만들어야 한다.
    - 속성이 n개라면 지원해야 할 조합의 수는 2^n개가 되어 `조합 폭발`이 일어난다.
  - 인터페이스의 경우 여러 인터페이스를 받아 계층을 구현할 수 있기 때문에 간단하다.

```java
// class 이용 계층 구조
class Singer {
  AudioClip sing(Song s) {
    ;
  }
}

class Songwriter {
  Song compose(int chartPosition) {
    ;
  }
}

// 모든 경우에 대해 다시 구현해야 한다.
class SingerSongwriter {
  AudioClip sing(Song s) {
    ;
  }

  Song compose(int chartPosition) {
    ;
  }

  AudioClip strum() {
    ;
  }
}

// interface 이용 계층 구조

interface Singer {
  AudioClip sing(Song s);
}

interface Songwriter {
   Song compose(int chartPosition);
}

interface SingerSongwriter extends Singer, Songwriter {
  AudioClip strum();
}
```

- `래퍼 클래스 관용구`와 함께 `인터페이스`를 사용하면 기능 향상시키는 안전하고 강력한 수단이 된다.
  - 추상 클래스로 구현하는 경우, 기능 추가 시 상속이 반드시 필요하고 상속은 래퍼 클래스보다 활용도가 떨어지고 깨지기 쉽다.
- 인터페이스 중 구현 방법이 명백한 것이 있다면 `디폴트 메서드`로 구현해도 좋다.
  - 디폴트 메서드 제공 시 `@implSpec` 자바독 테그를 붙여 문서화해야 한다.
  - 디폴트 메서드에도 여러 제약이 존재한다.
    - equals, hashCode와 같은 `Object`의 메서드의 경우 디폴트 메서드로 제공해서는 안된다.
    - 인터페이스는 인스턴스 필드를 가질 수 없고, public이 아닌 멤버도 가질 수 없다.
    - 직접 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없다.
- 추상 클래스도 장점이 존재하고, 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 존재한다.
  - `인터페이스`와 `추상 골격 구현 클래스`를 함께 제공하면 된다.
  - 인터페이스로 타입과 필요하다면 디폴트 메서드를 구현한다.
  - 추상 골격 구현 클래스는 인터페이스의 메서드를 구현한다.
  - 추상 골격 구현 클래스를 통해 인터페이스를 구현하는 데 필요한 대부분 일을 완료할 수 있다.
  - 이러한 디자인 패턴을 `템플릿 메서드 패턴`이라고 한다.
- 인터페이스 이름이 `Name`라면 골격 구현 클래스의 이름은 Abstract 접두어 붙여서 `AbstractName`과 같이 짓는 것이 좋다.
  - AbstractCollection, AbstractSet, AbstractList 등
- 골격 구현 클래스를 통해 추상 클래스처럼 구현을 도와주는 동시에, 타입 정의에 대한 제약에서 자유로울 수 있다.
- 골격 구현 클래스 작성 방법
  1. 인터페이스를 살펴보고 다른 메서드들의 구현에 사용되는 기반 메서드들을 선정한다.
  2. 기반 메서드들을 골격 구현에서는 추상 메서드가 된다.
  3. 기반 메서드들을 사용해 직접 구현할 수 있는 메서드들을 모두 디폴트 메서드로 제공한다.(Object 메서드 제외)
  4. 기반 메서드나 디폴트 메서드가 아닌 메서드들은 골격 구현 클래스가 구현한다.
- `단순 구현(Simple implementation)`은 골격 구현의 작은 변종으로, 추상 클래스가 아닌 것만 다르다.

### 핵심 정리

- 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다.
- 복잡한 인터페이스라면 골격 구현을 함께 제공하여 구현 수고를 덜 수 있다.
- 골격 구현은 디폴트 메소드로 제공하는 것이 가장 좋다.
  - 디폴트 메소드로 불가능한 경우 골격 구현 추상 클래스로 제공하면 된다.

## 아이템21. 인터페이스는 구현하는 쪽을 생각해 설계하라.

- 자바8의 디폴트 메소드를 통해 기존 인터페이스의 구조를 유지한 상태로 메소드를 추가할 수 있게 되었다.
- 디폴트 메소드의 추가는 인터페이스를 구현한 입장에서 모든 동작의 보장을 할 수 없다.
  - SynchronizedCollection의 경우 모든 메서드에서 동기화를 한 후 동작하는데, 디폴트 메서드 추가 시 기능이 보장되지 않는다.
- 그렇기 때문에 기존 인터페이스에 디폴트 메서드를 추가하는 일은 꼭 필요한 경우가 아니라면 피해야 한다.
- 디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아님을 명심해야 한다.

## 아이템22. 인터페이스는 타입을 정의하는 용도로만 사용하라.

- 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.
- 인터페이스를 구현한다는 것은 클라이언트에게 인스턴스가 무엇을 할 수 있는지 알려주는 것이다.
  - 인터페이스는 오직 이러한 용도로만 사용해야 한다.
- 인터페이스를 타입 정의용으로 사용하는 경우가 있는데 이것은 안티패턴이며, 완전한 악이다.
  - 상수 인터페이스(PhysicalConstants)의 경우가 완전 잘못된 예시다.
    - 외부가 아닌 내부 구현을 위한 인터페이스로, 완전한 안티패턴이다.
  - 그냥 값을 정의하거나 enum, 유틸 클래스 등을 이용하는 것이 좋다.

## 아이템23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라.

- 두 가지 이상의 의미를 표현할 수 있으며, 현재를 표현하는 `태그 클래스`는 단점이 가득하다.
  - 열거 타입, 태그 필드, switch 문 등 쓸데없는 코드가 가득해진다.
- 태그 클래스는 정황하고, 오류를 내기 쉽고, 비효율적이다.
- 태그 클래스는 클래스 계층구조를 어설프게 흉내낸 아류다.
- 태그 클래스를 클래스 계층구조로 바꾸는 방법
  - 계층구조의 루트가 될 추상 클래스를 정의한다.
  - 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언한다.
  - 태그와 상관 없이 동작이 일정한 경우 루트 클래스에 일반 메서드로 추가한다.
  - 하위 클래스에서 공통으로 사용하는 데이터 필드들도 모두 루트 클래스로 올린다.
  - 루트 클래스를 확장한 구체 클래스를 태그별로 하나식 정의한다.
  - 각 하위 클래스에서는 각자의 의미에 해당하는 데이터 필드들을 넣는다.

```java
// 태그 클래스
class Figure {
  enum Shape { RECTANGLE, CIRCLE };

  final Shape shape;

  double length;
  double width;

  double radius;

  double area() {
    switch(shape) {
      case RECTANGE:
        return length * width;
      case CIRCLE:
        return Math.PI * (radius * radius);
      default:
        ...
    }
  }

// 각 태그 별 생성자
...

}

// 클래스 계층 구조

abstract class Figure {
  abstract double area();
}

class Circle extends Figure {
  ...
}

class Rectange extends Figure {
  ...
}

```

### 핵심 정리

- 태그 달린 클래스를 써야 하는 상황은 거의 없다.
- 새로운 클래스를 작성하는 데 태그 필드가 등장한다면, 태그를 없애고 계층구조로 대체하는 방법을 생각하라.
- 기존 클래스가 태그 필드를 사용하고 있다면 계층 구조로 리펙터링하는 걸 고민하라.

## 아이템24. 멤버 클래스는 되도록 static으로 만들라.

- `중첩 클래스(nested class)`란 다른 클래스 안에 정의된 클래스를 말한다.
- 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외의 쓰임새가 있다면 톱레벨로 만들어야 한다.
- 중첩 클래스의 종류는 `정적 멤버 클래스`, `비정적 멤버 클래스`, `익명 클래스`, `지역 클래스`가 있다.
  - 정적 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)에 속한다.
- `정적 멤버 클래스`란 다른 클래스 안에 선언되어 있고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하면 다른 클래스와 똑같다.
  - private로 선언하면, 외부에서 접근이 불가능하다.
  - 정적 멤버 클래스는 바깥 클래스와 함꼐 쓰일 때만 유용한 public 도우미 클래스로 쓰인다.
- `비정적 멤버 클래스`는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.
  - 비정적 멤버 클래스의 인스턴스 메서드에서 정규화된 this(클래스명.this)를 통해 바끝 인스턴스이 참조를 가져올 수 있다.
  - 즉, 비정적 멤버 클래스는 바깥 인스턴스와 독립적으로 존재할 수 없다.
  - 바깥 인스턴스와의 관계는 멤버 클래스가 인스턴스화될 때 확립되며, 변경할 수 없다.
  - 생성자는 `바깥_인스턴스_클래스.new 멤버_클래스(args)` 형태로 호출한다.
  - 비정적 멤버 클래스는 어댑터를 정의할 때 자주 쓰인다.
- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.
- `익명 클래스`는 바깥 클래스의 멤버도 아니며, 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다.
  - 비정적 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다.
  - 정적 문맥에서라도 상수 변수 이외의 정적 멤버는 가질 수 없다.
  - 익명 클래스는 가독성이 떨어지고, instanceof 검사나, 여러 인터페이스를 구현할 수 없는 등 여러 제약이 많다.
  - 익명 클래스 보다는 람다를 쓰는 것이 좋다.
  - 정적 펙터리 메서드 구현 시 외에는 잘 안쓰인다.
- `지역 클래스`는 네 가지 중첩 클래스 중 가장 드물게 사용된다.
  - 지역 클래스는 지역변수를 선언할 수 있는 곳이면 실질적으로 어디서든 선언할 수 있다.
  - 유효 범위도 지역변수와 같다.

### 핵심 정리

- 중첩 클래스는 네 가지가 있다.
- 멤버 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스로 만든다.
- 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적 멤버 클래스로, 그렇지 않다면 정적 멤버 클래스로 만든다.
- 중첩 크래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스로, 그렇지 않다면 지역 클래스로 만든다.

## 아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라

- 하나의 파일에 여러 톱레벨 클래스를 담을 수 있지만, 컴파일 시 순서에 의해 결과가 달라질 수 있다.
- 그렇기 때문에 톱레벨 클래스들은 다른 소스 파일로 분리하는 것이 좋다.
- 톱레벨 클래스를 한 파일에 답고 싶다면 정적 멤버 클래스를 사용하는 방법이 있다.
