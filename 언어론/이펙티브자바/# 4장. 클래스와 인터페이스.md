# 4장. 클래스와 인터페이스

## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라.

- 잘 설계된 컴포넌트란 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐에 결정된다.
  - 즉, 정보 은닉 혹은 컵슐화라고 하는 개념이 얼마나 잘 구현되었는가 이다.
- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.
  - 오직 API를 통해서만 다른 컴포넌트와 소통하며, 서로의 내부 동작 방식에는 전혀 개의치 않는다.
- 정보 은닉의 장점
  - 시스템 개발 속도를 높인다.
    - 여러 컴포넌트를 병렬로 개발할 수 있다.
  - 시스템 관리 비용을 낮춘다.
    - 컴포넌트 파악을 빨리 할 수 있기 때문에 디버깅하기 쉽다.
    - 다른 컴포넌트로 교체하기가 쉽다.
  - 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에는 도움을 준다.
    - 최적화할 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있다.
  - 소프트웨어 재상용성을 높일 수 있다.
    - 외부에 의존하지 않기 때문에 낯선 환경에서도 유용하게 쓰을 가능성이 크다.
  - 큰 시스템을 제작하는 난이도를 낮춰준다.
    - 시스템 전체가 완성되지 않은 상태에서도 개별 동작을 검증할 수 있다.
- 접근 제한자를 활용하여 정보 은닉을 구현할 수 있다.
  - private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
  - package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.(default)
  - protected: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
  - public: 모든 곳에서 접근할 수 있다.
- 가장 근본적인 원칙은 `모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다`이다.
- 일반적으로 모든 멤버를 private로 만들고 필요에 따라서 권한 제한을 풀어주는 방식으로 접근하면 되지만, 권한을 자주 풀어주게 되면 컴포넌트를 더 분해해야 하는지 고민해야 한다.
- 접근 제한 설정 시 상속을 한다면, 접근 수준을 상위 클래스보다 좁게 설정할 수 없기 때문에 주의해야 한다.
  - 상위 public -> 하위 protected 불가능
  - 상위 protected -> 하위 public 가능
  - 인터페이스의 경우 좁게 설정할 수 없고, 무조건 public으로 선언해야 한다.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
  - 가변 객체를 참조하거나 final이 아닌 인스턴스 필드를 public으로 선언하면 값을 제한할 힘을 잃게 된다.
  - public 가변 필드를 갖는 클래스는 일반적으로 스레드에 안전하지 않다.
  - 해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소가 상수라면, `public static final`로 공개해도 된다.
    - 관례상 이런 상수의 이름은 대문자 알파벳과 문자 사이에 밑줄(\_)을 넣는다.
    - 이런 타입은 반드시 기본 타입이거나 불변 객체를 참조해야 한다.
- public static final 배열 필드는 접근할 수 있거나 반환하는 접근자 메서드를 제공해서는 안된다.
  - 배열의 경우 예상과 다른 동작을 할 수 있다.(final은 배열의 주소일 뿐, 배열의 원소 값은 수정이 된다.)
  - 이 경우 배열을 private로 만들고 같은 내용의 불변 리스트를 public으로 제공하면 된다.
  - 또는, 배열을 private로 만들고 같은 내용의 복사본 배열을 public으로 제공하면 된다.

### 핵심 정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라.
- 꼭 필요한 것만 골라 최소한의 public API를 설계하자.
  - 그 외 클래스, 인터페이스, 멤버가 의도치 않고 API로 공개되는 일이 없도록 해야 한다.
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.
- public static final 필드가 참조하는 객체가 불변인지 확인하라.

## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.

- public 클래스에서 필드를 public으로 선언하게 되면, 캡슐화의 이점을 제공하지 못한다.
- API를 수정하지 않고는 내부 표현을 바꿀 수 없고, 불변식을 보장할 수 없으며, 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없다.
- 이러한 클래스는 필드를 모두 private로 바꾸고 public 접근자(getter)를 추가하는게 좋다.
- 패키지 밖에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.
- package-private 클래스나 private 중첩 클래스의 경우 데이터 필드를 노출해도 괜찮다.
  - 패키지 바깥 코드는 전혀 손대지 않고 데이터 표현 방식을 바꿀 수 있다.
- java.awt.package의 Point와 Dimension 클래스의 경우 외부에 멤벌르 노출하고 있어서 잘못 구현되어 있다.
- public 클래스의 필드가 불변이라면, 직접 노출할 때 단점이 조금 줄어들긴 하지만 여전히 좋은 방법은 아니다.

### 핵심 정리

- public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다.
- 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
- package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다.

## 아이템 17. 변경 가능성을 최소화하라.

### 불변 객체

- 불변 클래스란 인스턴스 내부 값을 수정할 수 없는 클래스다.
  - 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.
  - String, 기본 타입 박싱 클래스, BigInteger, BigDecimal 등이 불변 클래스다.
- 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.
- 불변 객체 장점
  - 불변 객체는 그 자체로 실패 원자성(failure atomicity)을 제공한다.
    - 실패 원자성이란 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태임을 의미한다.
  - 불변 객체는 근본적으로 스레드 안전하기 때문에 동기화를 걱정할 필요가 없다.
- 불변 클래스 단점
  - 값이 다르면 반드시 독립된 객체로 만들어야 한다.
    - 값의 가짓수가 많다면 이들을 모두 만드는데 큰 비용이 필요하다.
    - 이러한 단점을 해결하기 위해서는 다단계 연산(multistep operation)을 예측하여 기본 기능으로 제공하거나 가변 동반 클래스를 제공하면 된다.
- 불변 클래스 구현 규책
  - 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
  - 클래스를 확장할 수 없도록 한다.
    - 하위 클래스에서 부주의하게 객체 상태를 변하게 만드는 사태를 막는다.
    - 확장을 막기 위해 final 클래스로 선언할 수도 있지만, 생성자를 private로 만들고 정적 펙터리를 제공해도 된다.
    - BigInteger와 BigDecimal는 확장할 수 있는 객체이기 때문에 진짜 해당 객체인지 확인해야 하는 번거로움이 있다.
  - 모든 필드를 final로 선언한다.
  - 모든 필드를 private로 선언한다.
    - private로 선언하여 클라이언트가 가변 객체에 접근하여 변경하는 것을 막는다.
  - 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    - 클래스에 가변 객체 필드가 있다면 클라이언트에서 참조를 얻게 하면 안된다.
    - 가변 객체 필드는 클라이언트에서 제공하는 값을 가리키게 하면 안된다.
    - 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행해야 한다.
- 메서드를 함수형으로 만들면 변경 가능성을 최소화할 수 있다.
  - 함수형 프로그래밍이란 피연산자에 함수를 적용하여 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 말한다.
- 모든 생성자가 클래스 불변식(class invariant)을 보장한다면 그 클래스를 사용한는 프로그래머가 다른 노력을 들이지 않아도 불변으로 남는다.
- 불변 객체는 한번 만든 인스턴스를 최대한 재활용 하는 것이 좋다.
  - 재활용하기 위해 가장 쉬운 방법은 자주 사용하는 값들을 상수(public static final)로 제공하는 것이다.
  - 불변 클래스를 자주 사용되는 인스턴스를 캐싱하여 정적 팩터리를 제공할 수 있다.
    - 박싱된 기본 타입과 BigInteger가 이러한 방식을 사용한다.
- 불변 객체는 자유롭게 공유할 수 있기 때문에 방어적 복사도 필요 없다.
  - 원본과 복사본이 일치하여 복사 자체가 의미가 없기 때문에 clone 메서드나 복사 생성자를 제공하지 않는 것이 좋다.
- 불변 객체끼리는 내부 데이터를 공유해도 좋다.

### 정리

- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
  - 단순 값 객체는 항상 불변으로 만들어라.
- 불변 클래스는 장점이 많으며 단점이라곤 특정 상황에서의 잠재적 성능 저하뿐이다.
  - 무거운 값 객체도 불변으로 만들 수 있는지는 고심해야 한다.
- 성능 때문에 고민된다면, 불변 클래스와 쌍을 이루는 가변 동반 클래스를 제공하는 것이 좋다.
- 불변으로 만들 수 없다면, 변경할 수 있는 부분을 최소로 줄여라.
  - 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
  - 꼭 변경해야 할 필드를 뺀 나머지 모두를 `final`로 선언하라.
- 다른 합당한 이유가 없다면 모든 필드는 `private final`이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
- 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안 된다.
- 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안 된다.

## 아이템18. 상속보다는 컴포지션을 사용하라.

- 상속은 코드 재사용을하는 강력한 수단이지만, 항상 최선은 아니다.
  - 여기서 말하는 상속은 다른 클래스를 확장하는 것이다.(인터페이스 제외)
  - 잘못 사용하게 되는 경우 오류를 내기 쉬운 소프트웨어를 만들게 된다.
  - 같은 패키지 안에서 통제되거나 확장할 목적으로 설계되고 문서화가 잘 되어 있다면 안전할 수 있다.
- 메소드 호출과 달리 상속은 캡슐화를 깨뜨린다.
  - 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
  - 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있기 때문에 하위 클래스가 오동작할 수 있다.
- 단순 상속 후 메소드를 재정의 하지 않고 새로운 메소드를 만든다고 문제가 해결되지는 않는다.
  - 상위 클래스에서 똑같은 이름의 메소드가 추가되면, 컴파일이 되지 않거나 오동작할 수 있다.
- 이러한 상속 문제를 해결하기 위해서는 상속 보다는 컴포지션을 사용하면 된다.
  - 컴포지션이란 상속 대신 새로운 클래스를 만들고, private 필드로 기존 클래스의 인스턴스를 참조하게 하는 것이다.
  - 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션(composition)이라 한다.
- 컴포지션을 이용하면 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어날 수 있다.
- 상속은 반드시 하위 클래스가 상위 클래스의 `진짜` 하위 타입인 상황에서만 쓰여야 한다.
  - 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다.
- 컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴이다.
  - API가 내부 구현에 묶일 수 있고, 클래스 성능도 영원히 제한된다.
  - 클라이언트가 노출된 내부에 직접 접근할 수 있다.
- 컴포지션 대신 상속을 사용할 경우 자문해야 하는 질문들
  - 확장하려는 클래스의 API에 아무런 결홤이 없는가?
  - 결함이 있다면, 이 결함이 클래스의 API까지 전파되어도 괜찮은가?

### 핵심 정리

- 상속은 강력하지만 캡슐화를 해친다는 문제가 있다.
- 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다.
  - is-a 관계라 하더라도 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 문제가 될 수 있다.
- 상속의 취약점을 피하기 위해 컴포지션과 전달을 사용하자.
- 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
  - A 메서드가 자신의 또 다른 B 메서드를 호출하고, B 메서드가 재정의 가능하다면 문서로 남겨야 한다.
- 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다.
- 즉, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
- 호율적인 하위 클래스를 큰 어려움 없이 만들기 위해서는 클래스 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개할 수 있어야 한다.
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어 보는 것이 `유일`하다.
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
  - 상위 클래스의 생성자가 하위 클래스 생성자보다 먼저 실행되기 때문에 재정의한 메서드를 호출할 경우 문제가 생길 수 있다.
- 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.
  - 클래스를 final로 선언한다.
  - 생성자를 private, package-private로 선언하고 public 정적 팩터리를 제공한다.

### 핵심 정리

- 상속용 클래스를 설계하기란 결코 만만치 않다.
- 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 문서화된 것은 반드시 지켜야 한다.
- 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다.
- 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 수 있다.
