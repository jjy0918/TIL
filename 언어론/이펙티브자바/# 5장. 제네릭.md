# 5장. 제네릭

## 아이템 26. raw 타입은 사용하지 마라.

- 클래스와 인터페이스 선언에 `타입 매개변수(type parameter)`가 쓰이면 `제네릭 클래스` 혹은 `제네릭 인터페이스`라고 한다.
- 제네릭 클래스와 제네릭 인터페이스를 통틀어 `제네릭 타입(generic type)`이라고 한다.
- 각 제네릭 타입은 일련의 `매개변수화 타입(parameterized type)`을 정의한다.
  - List<String>은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
- 제네릭 타입을 하나 정의하면 그에 딸린 raw 타입도 함께 정의된다.
  - raw 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
  - List<E>의 raw 타입은 List이다.
  - raw 타입은 제네릭 전 코드와 호환되기 위해 만들어졌다.
- raw 타입 자체를 언어 차원에서 막지는 않았지만, 절대 사용해서는 안된다.
  - raw 타입은 제네릭이 안겨주는 안전성과 표현력을 모두 읽게 만든다.
- raw 타입 대신 뭐든 담은 제네릭을 선언하고 싶다면 `비한정적 와일드 카드 타입(unbounded wildcard type)`을 사용하는 것이 좋다.
  - Set<E>의 비한정적 와일드 카드 타입은 Set<?>이다.
- 비한정적 와일드 카드 타입은 raw 타입과 달리 안정적이다.
- raw 타입을 쓰지 말라에도 예외는 존재한다.
  - class 리터럴에는 raw 타입을 써야 한다.
    - List.class, String[].class, int.class 등은 허용된다.
    - List<String>.class, List<?>.class 등은 허용되지 않는다.
  - instanceof에서 raw 타입과 비한정적 와일드 카드 타입은 똑같이 동작하기 때문에 raw 타입을 쓰는 것이 간편한다.
    - o instanceof Set

### 핵심 정리

- raw 타입을 사용하면 런타입에 예외가 일어날 수 있으니 사용하면 안 된다.
- raw 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.

## 아이템 27. 비검사 경고를 제거하라.

- 할 수 있는 한 모든 비검사 경고는 제거하는 것이 좋다.
- 비검사 경고를 제거할 수 없지만 타입이 안전하다고 확신한다면 `@SuppressWarnings("unchecked")` 어노테이션을 달아 경고를 숨길 수 있다.
  - `@SuppressWarnings` 어노테이션은 항상 가능한 한 좁은 범위에 적용하는 것이 좋다.
  - `@SuppressWarnings` 어노테이션과 함께 경고를 무시해도 안전한 이유를 주석으로 남겨야 한다.

### 핵심 정리

- 비검사 경고는 중요하니 무시하지 말자.
- 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성을 뜩하니 최대한 제거해야 한다.
- 경고를 없앨 방법을 찾지 못하겠다면, 그 코드가 타입 안전함을 증명하고 가능한 한 범위를 좁혀 `@SuppressWarnings` 어노테이션으로 숨겨라

## 아이템 28. 배열보다는 리스트를 사용하라.

- 배열과 제네릭에는 중요한 차이 두 가지가 있다.
  - 배열은 `공변(covariant)`이고 제네릭은 `불공변(invariant)`이다.
  - 배열은 실체화(reify)가 된다.
    - 배열은 런타입 시 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
    - 제네릭은 런타임 시 원소 타입이 제거되지만, 컴파일 시 검사한다.
- 공변이란 함께 변한다는 뜻이다.
  - 즉, 상위 -> 하위 관계가 배열에서도 함께 상위 -> 하위 관계로 변한다는 것이다.
  - Sub가 Super의 하위 타입이라면, Sub[]도 Super[]의 하위 타입이다.
- 불공변이란 함께 변하지 않는다는 것이다.
  - 즉, 상위 -> 하위 관계가 제네릭에선는 동일하지 않다는 것이다.
  - Sub가 Super의 하위 타입이라 하더라도 List<Sub>가 List<Super>의 하위 타입은 아니라는 것이다.(아무런 관계가 아니다)
- 위 두 가지 차이점에 의하여 제네릭 배열은 선언이 불가능하다.
  - new List<String>[], new E[] 등
- 제네릭은 실체화 불가 타입이기 때문에 런타임에는 컴파일타임보다 타입 적게 정보를 가지게 된다.
  - 제네릭에서는 원소 타입 정보가 소거되어 런타임에는 무슨 타입인지 알 수 없다.
- 그렇기 때문에 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는데, 대부분은 배열보다 컬렉션을 사용하면 된다.

```java
// 배열은 공변이다.
Obejct[] objectArray = new Long[1]; // 가능

// 제네릭은 불공변이다.
ArrayList<Object> ol = new ArrayList<Long>(); // 불가능
```

### 핵심 정리

- 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
- 배열은 공변이고 실체화 된다.
- 제네릭은 불공변이고 타입 정보가 소거된다.
- 배열은 런타임에는 타입 안전하지만, 컴파일타임에는 그렇지 않다.
- 배열과 제네릭을 섞어 쓰기 보다는 배열을 리스트로 대체하는 방법이 좋다.