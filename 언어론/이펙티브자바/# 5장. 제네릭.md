# 5장. 제네릭

## 아이템 26. raw 타입은 사용하지 마라.

- 클래스와 인터페이스 선언에 `타입 매개변수(type parameter)`가 쓰이면 `제네릭 클래스` 혹은 `제네릭 인터페이스`라고 한다.
- 제네릭 클래스와 제네릭 인터페이스를 통틀어 `제네릭 타입(generic type)`이라고 한다.
- 각 제네릭 타입은 일련의 `매개변수화 타입(parameterized type)`을 정의한다.
  - List<String>은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
- 제네릭 타입을 하나 정의하면 그에 딸린 raw 타입도 함께 정의된다.
  - raw 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
  - List<E>의 raw 타입은 List이다.
  - raw 타입은 제네릭 전 코드와 호환되기 위해 만들어졌다.
- raw 타입 자체를 언어 차원에서 막지는 않았지만, 절대 사용해서는 안된다.
  - raw 타입은 제네릭이 안겨주는 안전성과 표현력을 모두 읽게 만든다.
- raw 타입 대신 뭐든 담은 제네릭을 선언하고 싶다면 `비한정적 와일드 카드 타입(unbounded wildcard type)`을 사용하는 것이 좋다.
  - Set<E>의 비한정적 와일드 카드 타입은 Set<?>이다.
- 비한정적 와일드 카드 타입은 raw 타입과 달리 안정적이다.
- raw 타입을 쓰지 말라에도 예외는 존재한다.
  - class 리터럴에는 raw 타입을 써야 한다.
    - List.class, String[].class, int.class 등은 허용된다.
    - List<String>.class, List<?>.class 등은 허용되지 않는다.
  - instanceof에서 raw 타입과 비한정적 와일드 카드 타입은 똑같이 동작하기 때문에 raw 타입을 쓰는 것이 간편한다.
    - o instanceof Set

### 핵심 정리

- raw 타입을 사용하면 런타입에 예외가 일어날 수 있으니 사용하면 안 된다.
- raw 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.

## 아이템 27. 비검사 경고를 제거하라.

- 할 수 있는 한 모든 비검사 경고는 제거하는 것이 좋다.
- 비검사 경고를 제거할 수 없지만 타입이 안전하다고 확신한다면 `@SuppressWarnings("unchecked")` 어노테이션을 달아 경고를 숨길 수 있다.
  - `@SuppressWarnings` 어노테이션은 항상 가능한 한 좁은 범위에 적용하는 것이 좋다.
  - `@SuppressWarnings` 어노테이션과 함께 경고를 무시해도 안전한 이유를 주석으로 남겨야 한다.

### 핵심 정리

- 비검사 경고는 중요하니 무시하지 말자.
- 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성을 뜩하니 최대한 제거해야 한다.
- 경고를 없앨 방법을 찾지 못하겠다면, 그 코드가 타입 안전함을 증명하고 가능한 한 범위를 좁혀 `@SuppressWarnings` 어노테이션으로 숨겨라

## 아이템 28. 배열보다는 리스트를 사용하라.

- 배열과 제네릭에는 중요한 차이 두 가지가 있다.
  - 배열은 `공변(covariant)`이고 제네릭은 `불공변(invariant)`이다.
  - 배열은 실체화(reify)가 된다.
    - 배열은 런타입 시 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
    - 제네릭은 런타임 시 원소 타입이 제거되지만, 컴파일 시 검사한다.
- 공변이란 함께 변한다는 뜻이다.
  - 즉, 상위 -> 하위 관계가 배열에서도 함께 상위 -> 하위 관계로 변한다는 것이다.
  - Sub가 Super의 하위 타입이라면, Sub[]도 Super[]의 하위 타입이다.
- 불공변이란 함께 변하지 않는다는 것이다.
  - 즉, 상위 -> 하위 관계가 제네릭에선는 동일하지 않다는 것이다.
  - Sub가 Super의 하위 타입이라 하더라도 List<Sub>가 List<Super>의 하위 타입은 아니라는 것이다.(아무런 관계가 아니다)
- 위 두 가지 차이점에 의하여 제네릭 배열은 선언이 불가능하다.
  - new List<String>[], new E[] 등
- 제네릭은 실체화 불가 타입이기 때문에 런타임에는 컴파일타임보다 타입 적게 정보를 가지게 된다.
  - 제네릭에서는 원소 타입 정보가 소거되어 런타임에는 무슨 타입인지 알 수 없다.
- 그렇기 때문에 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는데, 대부분은 배열보다 컬렉션을 사용하면 된다.

```java
// 배열은 공변이다.
Obejct[] objectArray = new Long[1]; // 가능

// 제네릭은 불공변이다.
ArrayList<Object> ol = new ArrayList<Long>(); // 불가능
```

### 핵심 정리

- 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
- 배열은 공변이고 실체화 된다.
- 제네릭은 불공변이고 타입 정보가 소거된다.
- 배열은 런타임에는 타입 안전하지만, 컴파일타임에는 그렇지 않다.
- 배열과 제네릭을 섞어 쓰기 보다는 배열을 리스트로 대체하는 방법이 좋다.

## 아이템29. 이왕이면 제네릭 타입으로 만들라.

- 제네릭 클래스는 일반적인 클래스의 형변환보다 안전하고 간단하게 사용될 수 있다.
- 새롭계 설계하는 클래스를 제네릭 클래스로 만들 수도 있지만, 기존 클래스를도 제네릭 클래스로 만들 수 있다.
- 일반 클래스에 타입 매개변수를 추가하여 제네릭 클래스로 만들면 된다.
  - 일반적으로 타입 매개변수의 이름은 `E`를 사용한다.
- 일반적으로는 이름을 추가하고 타입 매개변수를 사용하여 쉽게 완성되지만, 타입 매개변수를 이용하여 제네릭 배열을 만드는 부분은 문제가 된다.

### 제네릭 배열 생성 방법

1. 제네릭 배열 생성 금지 제약을 대놓고 우회하기
   - Object 배열 생성 후 제네릭 배열로 형변환하기
   - 컴파일러는 안전하지 않다고 메시지를 보내지만, 개발자 입장에서는 안전한지 알 수 있다.
2. 원소의 타입을 E[]에서 Object[]로 바꾸는 것.

- 위 2가지 방법 모두 결국은 경고 메시지를 발생시키기 때문에 `@SuppressWarnings("unchecked")`를 명시해주어야 한다.
- 1번 방식은 형 변환이 생성할 때만 일어나지만, 2번은 배열에서 원소 읽을 때마다 일어나기 때문에 1번 방식이 더 선호된다.

```java
// 방법 1.
@SuppressWarnings("unchecked")
public Stack() {
    elements = (E[]) new Object[DEFAULT_INTITAL_CAPACITY];
}

// 방법 2.
class Stack<E> {
    Object[] elements;

    ...

    public E pop() {
        if (size == 0 ){
            throw new EmptyStackException();
        }

        @SuppressWarnings("unchecked") E result = (E) elements[--size];
    }
}
```

### 핵심 정리

- 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다.
- 새로운 타입 설계할 때 형변환 없이도 사용할 수 있도록 하라.
- 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경하자.

## 아이템 30. 이왕이면 제네릭 메서드로 만들라

- 클래스를 제네릭 클래스로 만들 수 있는 것 처럼 메소드도 제네릭 메소드로 만들 수 있다.
- 제네릭 메서드 작성법은 제네릭 타입 작성법과 비슷하다.
  - 타입 매개변수 목록은 메서드의 제한자와 반환 타입 사이에 온다.
  - 타입 매개 변수의 명명 규칙은 제네릭 메서드와 제네릭 타입이 같다.

```java
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
  Set<E> result = new HashSet<>(s1);
  result.addAll(s2);
  return result;
}
```

- 한정적 와일드카드 타입을 사용하면, 유연하게 제네릭을 사용할 수 있다.
- 제네릭은 런타임 시 타입 정보가 소거되기 때문에 하나의 객체를 어떤 타입으로든 매개변수화할 수 있다.
  - 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 `제네릭 싱글턴 팩터리`를 사용하면 간단하게 구현할 수 있다.

```java
private static UnarayOperator<Object> IDENTITY_FN = (t) -> t;

@SuppressWarnings("unchecked")
public static <T> UnarayOperator<T> identityFunction() {
  return (UnarayOperator<T>) IDENTITY_FN;
}
```

- 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정하는 `재귀적 타입 한정`이라는 개념도 존재한다.
- 재귀적 타입 한정은 Comparable 인터페이스와 자주 사용된다.

```java
// E는 Comparable<E>를 구현했기 때문에 모든 E 타입은 자기 자신과 비교할 수 있다.
public static <E extends Comparable<E>> E max(Collection<E> c);
```

### 핵심 정리

- 입력 매개변수와 반환값을 명시적으로 형변환하는 것 보다는 제네릭 메서드가 더 안전하다.
- 형변환을 해야 하는 경우 기존 메소드를 제네릭으로 만들자!

## 아이템 31. 한정적 와일드카드를 사용해 API 유연성을 높이라

- 기본적으로 매개변수화 타입은 불공변(invariant)이다.
- 자바에서는 불공변을 유연하게 사용하기 위해 `한정적 와일드카드 타입`이라는 특별한 매개변수화 타입을 지원한다.
- 한정적 와일드카드 타입을 이용하여 유연성을 극대화 할 수 있다.
- 한정적 와일드카드를 어떠한 상황에 쓰는가는 PECS(producer-extends, consumer-super)로 외우면 된다.
  - 매개변수화 타입 T가 생산자라면 <? extends T>를 사용하면 된다.
  - 매개변수화 타입 T가 소비자라면 <? super T>를 사용하면 된다.
- 반환타입에서는 한정적 와일드카드 타입을 쓰면 안된다.
- 이렇게 한정적 와일드카드 타입을 반공변이라고 한다.
  - <? extends T> 처럼 상한 범위를 지정하여 허용하는 것을 `Uppder Bounded Wildcards` 라고 한다.
    - 상한을 지정함으로써 해당 제네릭에서 무조건 T를 상속 받은 값만 지정할 수 있다.
    - 즉, T를 무조건 상속 받아 구현했기 때문에 T로 해당 제네릭을 소비하는 경우에는 문제가 없다는 것이다(해당 와일드카드 타입을 만들어내는 경우)
    - 그렇기 때문에 <? extends T> 는 생산(produce)하는 경우, 즉 해당 데이터를 사용하는 경우에 적용해야 한다.
  - <? super T> 처럼 하한 범위를 지정하여 허용하는 것을 `Under Bounded Wildcards` 라고 한다.
    - 하한을 지점함으로써 해당 제네릭은 무조건 T가 상소 받은 값만 지정할 수 있다.
    - 즉, T가 상속 받은 클래스들이기 때문에 제네릭에 어떠한 객체를 넣을 때 그 값을 추축할 수 있다.
    - 그렇게 때문에 <? super T> 는 소비(consume)하는 경우, 즉 해당 객체를 사용하는 경우에 적용해야 한다.
- 데이터를 만드는(조회) 경우는 해당 데이터가 어떠한 값인지의 상한이 정해져 있기 때문에 안전하다.
- 데이터를 소비(사용)하는 경우 해당 데이터의 하한이 정해져 있기 때문에 그 값을 상속 받은 값은 무조건 안전해진다.
  - <? super T> 에서는 소비 시 T만 가능하다.(하한이 B인 값, 즉 B를 포함하여 B를 상속 받은 값은 다 가능하다.)

```java
class MyGeneric<T> {
  private T t;

  public void setT(T t) {
    this.t = t;
  }

  public T getT() {
    return t;
  }
}

class A {}
class B extends A {}
class C extends B {}

// g는 함수 밖에서 사용 시 B 또는 B의 부모 값이 제네릭형 변수로 들어간다.
// 즉, 하한이 B이기 때문에 B이거나 B의 부모인 것이다. 다시말해 B를 비롯하여 부모 클래스가 모두 호환되어 사용할 수 있다는 것이다.
// 그렇기 때문에 넣을 때 B이거나 B의 자식 값을 넣어야 한다.
// 조회가 안되는 것은 B의 부모들이기 때문에 어떠한 값이 올지 모르기 때문이다.
// MyGeneric<A>인데 superFunction에서 조회 시 AB등 어떠한 부모가 나올지 모름.
public void superFunction(MyGeneric<? super B> g) {
  g.setT(new A());  // 불가능
  g.setT(new B());  // 가능
  g.setT(new C());  // 가능

  A a = g.getT();   // 불가능
  B b = g.getT();   // 불가능
  C c = g.getT();   // 불가능
}

// g는 함수 밖에서 사용 시 B 또는 B의 자식 값이 제네릭형 변수에 들어간다.
// 즉, 상한이 B이기 때문에 B이거 B의 자식인 것이다. 다시말해 B를 비롯하여 자식 클래스가 모두 호환되어 사용할 수 있다는 것이다.
// 그렇기 때문에 조회할 때 B이거나 B의 부모들 이어야 한다.
// 삽입이 안되는 것은 B의 자식들이기 때문에 어떠한 값을 넣어야 하는지 모르기 때문이다. 
// => MyGeneric<C>인데 extendsFunction에서 B의 자식인 BB를 넣으면 문제가 생길 수 있기 떄문에 금지!
public void extendsFunction(MyGeneric<? extends B> g) {
  A a = g.getT();   // 가능
  B b = g.getT();   // 가능
  C c = g.getT();   // 불가능

  g.setT(new A());  // 불가능
  g.setT(new B());  // 불가능
  g.setT(new C());  // 불가능
}
```

- 일반적으로 Comparable과 Comparator는 모두 소비자(consumer)이다.
- `<E extends Comparable<? super E>>` 라는 것은 E는 Comparable<E> 또는 Comparable<E의 부모> 가 성립해야 한다는 것이다.

## 아이템32. 제네릭과 가변인수를 할께 쓸 때는 신중하라.

- 가변인수 메소드를 호출하면 가변인수를 담기 위한 배열이 자동으로 만들어진다.
  - 이러한 배열은 클라이언트에게 노출되는 문제가 있다.
  - 그렇기 때문에 varargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려움 컴파일 경고가 발생한다.
- 타입의 안전성 때문에 제네릭 varags 배열 매개변수에 값을 저장하는 것은 안전하지 않다.
- 하지만, 제네릭 가변인수는 편리하기 때문에 자주 사용된다.
- 자바7 에서는 `@SaveVarags` 어노테이션을 이용하여 제네릭 가변인수 메서드를 작성자가 클라이언트 측에서 발생하는 경고를 숨겨줄 수 있다.
  - 타입 안전함을 보장한다는 것이다.
  - 안전하지 않다면, 해당 어노테이션을 달면 안된다.
  - 또한, 재정의 불가능한 메소드에서만 해당 어노테이션을 사용하는 것이 좋다.
- 타입 안전하는 것은, 제네릭 가변인수 배열에 값을 저장하지 않고, 그 배열의 참조가 밖으로 노출되지 않는다는 것이다.

### 핵심 정리

- 가변인수와 제네릭은 궁합이 좋지 않다.
- 가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고, 배열과 제네릭의 타입 규칙이 서로 다르기 때문이다.
- 사용하고 싶다면, 메소드가 타입 안전한지 확인 후 @SafeVarargs 어노테이션을 달자.
