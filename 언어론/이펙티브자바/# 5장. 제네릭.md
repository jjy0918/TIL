# 5장. 제네릭

## 아이템 26. raw 타입은 사용하지 마라.

- 클래스와 인터페이스 선언에 `타입 매개변수(type parameter)`가 쓰이면 `제네릭 클래스` 혹은 `제네릭 인터페이스`라고 한다.
- 제네릭 클래스와 제네릭 인터페이스를 통틀어 `제네릭 타입(generic type)`이라고 한다.
- 각 제네릭 타입은 일련의 `매개변수화 타입(parameterized type)`을 정의한다.
  - List<String>은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
- 제네릭 타입을 하나 정의하면 그에 딸린 raw 타입도 함께 정의된다.
  - raw 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
  - List<E>의 raw 타입은 List이다.
  - raw 타입은 제네릭 전 코드와 호환되기 위해 만들어졌다.
- raw 타입 자체를 언어 차원에서 막지는 않았지만, 절대 사용해서는 안된다.
  - raw 타입은 제네릭이 안겨주는 안전성과 표현력을 모두 읽게 만든다.
- raw 타입 대신 뭐든 담은 제네릭을 선언하고 싶다면 `비한정적 와일드 카드 타입(unbounded wildcard type)`을 사용하는 것이 좋다.
  - Set<E>의 비한정적 와일드 카드 타입은 Set<?>이다.
- 비한정적 와일드 카드 타입은 raw 타입과 달리 안정적이다.
- raw 타입을 쓰지 말라에도 예외는 존재한다.
  - class 리터럴에는 raw 타입을 써야 한다.
    - List.class, String[].class, int.class 등은 허용된다.
    - List<String>.class, List<?>.class 등은 허용되지 않는다.
  - instanceof에서 raw 타입과 비한정적 와일드 카드 타입은 똑같이 동작하기 때문에 raw 타입을 쓰는 것이 간편한다.
    - o instanceof Set

### 핵심 정리

- raw 타입을 사용하면 런타입에 예외가 일어날 수 있으니 사용하면 안 된다.
- raw 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.

## 아이템 27. 비검사 경고를 제거하라.

- 할 수 있는 한 모든 비검사 경고는 제거하는 것이 좋다.
- 비검사 경고를 제거할 수 없지만 타입이 안전하다고 확신한다면 `@SuppressWarnings("unchecked")` 어노테이션을 달아 경고를 숨길 수 있다.
  - `@SuppressWarnings` 어노테이션은 항상 가능한 한 좁은 범위에 적용하는 것이 좋다.
  - `@SuppressWarnings` 어노테이션과 함께 경고를 무시해도 안전한 이유를 주석으로 남겨야 한다.

### 핵심 정리

- 비검사 경고는 중요하니 무시하지 말자.
- 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성을 뜩하니 최대한 제거해야 한다.
- 경고를 없앨 방법을 찾지 못하겠다면, 그 코드가 타입 안전함을 증명하고 가능한 한 범위를 좁혀 `@SuppressWarnings` 어노테이션으로 숨겨라

## 아이템 28. 배열보다는 리스트를 사용하라.

- 배열과 제네릭에는 중요한 차이 두 가지가 있다.
  - 배열은 `공변(covariant)`이고 제네릭은 `불공변(invariant)`이다.
  - 배열은 실체화(reify)가 된다.
    - 배열은 런타입 시 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
    - 제네릭은 런타임 시 원소 타입이 제거되지만, 컴파일 시 검사한다.
- 공변이란 함께 변한다는 뜻이다.
  - 즉, 상위 -> 하위 관계가 배열에서도 함께 상위 -> 하위 관계로 변한다는 것이다.
  - Sub가 Super의 하위 타입이라면, Sub[]도 Super[]의 하위 타입이다.
- 불공변이란 함께 변하지 않는다는 것이다.
  - 즉, 상위 -> 하위 관계가 제네릭에선는 동일하지 않다는 것이다.
  - Sub가 Super의 하위 타입이라 하더라도 List<Sub>가 List<Super>의 하위 타입은 아니라는 것이다.(아무런 관계가 아니다)
- 위 두 가지 차이점에 의하여 제네릭 배열은 선언이 불가능하다.
  - new List<String>[], new E[] 등
- 제네릭은 실체화 불가 타입이기 때문에 런타임에는 컴파일타임보다 타입 적게 정보를 가지게 된다.
  - 제네릭에서는 원소 타입 정보가 소거되어 런타임에는 무슨 타입인지 알 수 없다.
- 그렇기 때문에 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는데, 대부분은 배열보다 컬렉션을 사용하면 된다.

```java
// 배열은 공변이다.
Obejct[] objectArray = new Long[1]; // 가능

// 제네릭은 불공변이다.
ArrayList<Object> ol = new ArrayList<Long>(); // 불가능
```

### 핵심 정리

- 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
- 배열은 공변이고 실체화 된다.
- 제네릭은 불공변이고 타입 정보가 소거된다.
- 배열은 런타임에는 타입 안전하지만, 컴파일타임에는 그렇지 않다.
- 배열과 제네릭을 섞어 쓰기 보다는 배열을 리스트로 대체하는 방법이 좋다.

## 아이템29. 이왕이면 제네릭 타입으로 만들라.

- 제네릭 클래스는 일반적인 클래스의 형변환보다 안전하고 간단하게 사용될 수 있다.
- 새롭계 설계하는 클래스를 제네릭 클래스로 만들 수도 있지만, 기존 클래스를도 제네릭 클래스로 만들 수 있다.
- 일반 클래스에 타입 매개변수를 추가하여 제네릭 클래스로 만들면 된다.
  - 일반적으로 타입 매개변수의 이름은 `E`를 사용한다.
- 일반적으로는 이름을 추가하고 타입 매개변수를 사용하여 쉽게 완성되지만, 타입 매개변수를 이용하여 제네릭 배열을 만드는 부분은 문제가 된다.

### 제네릭 배열 생성 방법

1. 제네릭 배열 생성 금지 제약을 대놓고 우회하기
   - Object 배열 생성 후 제네릭 배열로 형변환하기
   - 컴파일러는 안전하지 않다고 메시지를 보내지만, 개발자 입장에서는 안전한지 알 수 있다.
2. 원소의 타입을 E[]에서 Object[]로 바꾸는 것.

- 위 2가지 방법 모두 결국은 경고 메시지를 발생시키기 때문에 `@SuppressWarnings("unchecked")`를 명시해주어야 한다.
- 1번 방식은 형 변환이 생성할 때만 일어나지만, 2번은 배열에서 원소 읽을 때마다 일어나기 때문에 1번 방식이 더 선호된다.

```java
// 방법 1.
@SuppressWarnings("unchecked")
public Stack() {
    elements = (E[]) new Object[DEFAULT_INTITAL_CAPACITY];
}

// 방법 2.
class Stack<E> {
    Object[] elements;

    ...

    public E pop() {
        if (size == 0 ){
            throw new EmptyStackException();
        }

        @SuppressWarnings("unchecked") E result = (E) elements[--size];
    }
}
```

### 핵심 정리

- 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다.
- 새로운 타입 설계할 때 형변환 없이도 사용할 수 있도록 하라.
- 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경하자.