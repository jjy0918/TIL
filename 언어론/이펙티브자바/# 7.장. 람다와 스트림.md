# 7. 람다와 스트림

## 아이템42. 익명 클래스보다는 람다를 사용하라.

- 과거에는 함수 타입을 표현하기 위해서 추상 메서드 하나만을 가지고 있는 익명 클래스를 만들어서 사용했다.
- 자바8에서는 추상 메서드 하나짜리 인터페이스를 `함수형 인터페이스`라는 특별한 인터페이스로 정의하여 사용한다.
- 함수형 인터페이스는 `람다식(lambda expression)`을 사용해 만들 수 있다.
  - 람다는 함수나 익명 클래스와 개념은 비슷하지만, 코드는 훨씬 간결하다.
  - 람다에서는 타입을 명시하지 않아도, 컴파일러가 자동으로 추론해준다.

```java
// 과거 - 익명 클래스
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
})

// 자바8의 람다
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
Collections.sort(words, comparagInt(String::legth));
```

- 람다는 메서드나 클래스와 달리 이름이 없고 문서화를 못하기 떄문에 코드 자체로 동작이 명확히 설명되어야 한다.
- 람다는 한 줄일 때 가장 좋고, 길어야 세 줄 안에 끝내야 한다.
  - 세 줄이 넘어가면 가독성이 나빠진다.
  - 람다가 길어진다는 것은 리팩터링이 필요하다는 이야기다.
- 람다는 자기 자신을 참조할 수 없기 때문에 `this` 키워드는 바깥 인스턴스를 가리킨다는 것을 알아야 한다.
- 람다의 경우 직렬화 형태가 구현별로 다를 수 있기 때문에 직렬화하는 일은 극히 삼가야 한다.

## 아이템 43. 람다보다는 메서드 참조를 사용하라

- 자바에서 람다보다 간결하게 표현할 수 있는 것이 메서드 참조(method reference)다.
- 매개변수의 이름이 가이드가 되는 람다라면, 메서드 참조 보다는 람다가 더 보기 좋을 수 있다.
- 메서드 참조에는 5가지 유형이 있다.
  - 정적
  - 한정적(인스턴스) - 람다 외부에서 수신 객체를 받아서 사용함.
  - 비한정적(인스턴스) - 람다 매개변수로 수신 객체를 받아서 사용함.
  - 클래스 생성자
  - 배열 생성자

```java
// 정적 - 메서드 참조
Integer::parseInt
// 정적 - 람다
str -> Integer.parseInt(str)

// 한정적(인스턴스) - 메서드 참조
Instant.now()::isAfter
// 한정적(인스턴스) - 람다
Instant then = Instant.now();   // 람다 외부에서 생성
t -> then.isAfter(t);

// 비한정적(인스턴스) - 메서드 참조
String::toLowerCase
// 비한정적(인스턴스) - 람다
str -> str.towLowerCase()   // 람다 매개변수로 받음.

// 클래스 생성자 - 메서드 참조
TreeMap<K,V>::new
// 클래스 생성자 - 람다
() -> new TreeMap<K,V>()

// 배열 생성자 - 메서드 참조
int[]::new
// 배열 생성자 - 람다
len -> new int[len]
```

## 아이템44. 표준 함수형 인터페이스를 사용하라.

- 자바가 람다를 지원하게 되면서 `템플릿 메서드 패턴`은 거의 쓸모가 없게 되었다.
  - 객체를 상속 받아 재정의하기 보다는 재정의가 필요한 부분을 함수 객체로 받아 사용하는게 더 편하다.
- 자바에서는 자주 사용되는 함수형 인터페이스를 미리 여러개 만들어 두었다.
  - java.util.function 패키지에 구현되어 있다.
  - 필요한 용도에 맞는 게 있다면, 직접 구현하기 보다는 `표준 함수형 인터페이스`를 사용하는 것이 좋다.
- 대표적인 표준 함수형 인터페이스
  - Operator: 반환값과 인수 타입이 같은 함수
    - `T apply(T t)`
  - Predicate: 인수를 받아 boolean 반환
    - `boolean test(T t)`
  - Supplier: 인수를 받지 않고 값을 반환
    - `T get()`
  - Consumer: 인수를 받고 반환값은 없음
    - `void accept(T t)`
  - Function: 인수를 받아 반환(타입이 다름)
    - `R apply (T t)`
  - Unary~~: 매개변수가 1개
  - Binary~~: 매개변수가 2개
- 기본적으로 표준 함수형 인터페이스들은 기본 타입을 사용할 수 있도록 지원한다.
  - 기본 함수형 인터페이스의 값에 박싱된 기본 타입을 넣으면 성능상 안좋으니 하지 마라
- 기본 함수형 인터페이스와 동일한 형태의 인터페이스를 구현해야 하는 경우도 존재한다.(Comparator)
  - 자주 쓰이며, 이름 자체가 용도를 명확히 설명해주는 경우.
  - 반드시 따라야 하는 규약이 있는 경우.
  - 유용한 디폴트 메서드를 제공할 수 있는 경우.
- 직접 함수형 인터페이스를 작성한다면, 반드시 `@FunctionalInterface`를 붙여주는 것이 좋다.
  - 해당 클래스의 코드나 설명 문서를 읽을 사람에게 람다용으로 설계됨을 알려줄 수 있다.
  - 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 한다고 컴파일러에게 알려준다.
  - 누군가 인터페이스에 메서드 추가를 해도 컴파일러가 막아준다.
- 함수형 인터페이스를 작성할 때 가장 주의할 점
  - 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드 오버로딩 금지

## 아이템 45. 스트림은 주의해서 사용하라.

- 자바8에서는 다량의 데이터 처리를 돕기 위해 `스트림 API`이 추가되었다.
- 스트림 API는 기본 타입 중 int, long, double을 지원한다.
  - char는 int로 변환되어 동작하기 때문에 char 값들을 처리할 때는 스트림을 삼가는 편이 낫다.
- 스트림 API가 제공하는 추상 개념 중 핵심은 두 가지이다.
  - 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다.
  - 스트림 파이프라인은 원소들로 수행하는 연산 단계를 표현하는 개념이다.
- 스트림 파이프라인은 `소스 스트림` -> `중간 연산` -> `종단 연산` 순으로 진행된다.
  - 중간 연산은 한 스트림을 다른 스트림으로 변환한다.
  - 종단 연산은 마지막 중간 연산이 내놓은 스트림에 최수 연산을 가한다.
- 스트림 파이프라인 `지연 평가(lazy evaluation)`된다.
  - 평가는 종단 연산이 호출될 때 이루어진다.
  - 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.
  - 종단 연산이 없는 파이프 라인은 아무런 일도 하지 않는 것과 같다.
- 스트림 API는 메서드 연쇄를 지원하는 `플루언트 API(Fluent API)`다.
  - 파이프라인 여러 개를 연결하여 표현식 하나로 만들 수 있다.
- 기본적으로 스트림 파이프라인은 순차적으로 수횅되지만, `parallel` 메서드를 호출하면 병렬로 진행할 수 있다.
- 스트림을 잘못 사용하면 오히려 읽기 어렵고 유지보수도 힘들어질 수 있기 때문에 잘 사용해야 한다.
  - 무조건 스트림을 사용하기 보다는, 적절히 섞는 것이 좋다.
  - 기존 메서드를 스트림으로 리펙토링할 때 스트림이 더 나은 경우에만 변경하자.
- 스트림의 매개변수의 이름은 주의해서 정해야 한다.
- 스트림 파이프라인은 계산을 함수 객체로 표현하기 때문에 일반 코드 블록과 차이점이 존재한다.
  - 함수 객체(람다)에서는 final이 아닌 지역 변수를 접근 및 수정할 수 없지만, 코드 블록은 final이 아니라도 가능하다.
  - 함수 객체(람다)에서는 return, break, continue 등의 제어 작업이 불가능하다.
- 스트림에서 처리하면 좋은 작업들은 예시
  - 원소들의 시퀀스를 일관되게 변환한다.
  - 원소들의 시퀀스를 필터링한다.
  - 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.(더하기, 연결하기, 최솟값 구하기 등)
  - 원소들의 시퀀스를 컬렉션에 모은다
  - 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.
- 스트림에서 처리하면 안좋은 작업들 예시
  - 여러 단계에서 각 단계의 값들을 동시에 접근할 해야 하는 경우.
    - 스트림은 단계가 지나면 값이 사라지기 때문에 기본적으로는 불가능하다.

## 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라.

- 스트림 패러다임의 핵심은 계산을 일련의 변환(tranformation)으로 재구성하는 부분이다.
- 각 변환 단계는 이전 단계의 결과를 받아 처리하는 `순수 함수`여야 한다.
  - 순수 함수란 입력만이 결과에 영향을 미치는 함수를 말한다.
  - 순수 함수로 구현되기 때문에 스트림 연산에서는 side effect가 없어야 한다.

```java
// 스트림에서 부작용이 생기는 경우
Map<String, Long> freq = new HashMap<>();

try(Stream<String> words = new Scanner(file).tokens()) {
    words.forEach(word -> {
        freq.merge(word.toLowerCase(), 1L, Long::sum);
    })
}
```

- forEach를 이용하여 특정 계산을 수행하는 경우 부작용이 가능성이 높다.
  - forEach는 스트림 결과 보고할 때만 사용하고, 계산하는데는 쓰지 말아야 한다.
  - Stream의 결과를 모으기 위해서 forEach가 아닌 `collect`를 사용하자.

## 아이템 47. 반환 타입으로는 스트림보다는 컬렉션이 낫다.

## 아이템 48. 스트림 병렬화는 주의해서 적용하라.

- 스트림 병렬 처리 시 limit을 사용하더라도, 그 뒤 데이터를 처리할 수 있기 때문에 오히려 느려질 수 있다.
- 스트림 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap 인스턴스이거나 int 범위, long 범위, 배열일 때 병렬화 효과가 좋다.
  - 데이터를 원하는 크기로 나누기 쉽다.
  - 데이터들이 연속적으로 저장되어 있기 때문에 참조 지역성이 좋아서 효율적이다.
- 스트림 병렬화는 성능 최적화의 수단으로 만 쓰여야 하기 때문에 성능을 테스트하여 효율적인지
