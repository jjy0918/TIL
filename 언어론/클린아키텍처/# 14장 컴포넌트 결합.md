# 14장 컴포넌트 결합

## ADP: 의존성 비순환 원칙

- 컴포넌트 의존성 그래프에 순환(Cycle)이 있어서는 안 된다.
- 많은 개발자들이 동일 소스 파일을 수정하다 보면, 나도 모르는 사이에 내가 사용하던 코드가 변경되어 동작하지 않는 숙취 증후군이 발견된다.
- 이러한 숙취 증후군을 해결하기 위해서는 두 가지 해결책이 있다.
  - 주 단위 빌드
  - 의존성 부순환 원칙

### 주 단위 빌드(Weekly Build)

- 주 단위 빌드는 중간 규모의 프로젝트에서 흔하게 사용된다.
- 주 단위 빌드란, 4일 동안은 각자 개발을 하고 나머지 하루 동안 개발된 내용을 통합하여 빌드하는 것이다.
- 프로젝트 단위가 커지게 되면, 결국 개발된 내용이 많아지고 금요일 하루 동안 통합 및 빌드가 불가능해진다.
- 효율성을 위해서는 결국 빌드 시간이 늘어나고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 커진다.

### 순환 의존성 제거하기

- 이 방법은 개발 환경을 릴리스 가능한 컴포넌튿 분리하는 것이다.
- 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.
- 각 컴포넌트 개발자들은 컴포넌트 릴리스하고, 그 컴포넌트를 사용하는 다른 컴포넌트는 릴리스 내용을 보고 사용할 지 판단하기만 하면 된다.
- 특정 컴포넌트가 변경되더라도, 다른 팀에 즉각적으로 영향을 주지 않는다.
- 각 팀은 스스로 다른 컴포넌트의 릴리스를 언제 적용할 지 결정할 수 있기 때문에 통합은 작고 점진적으로 이뤄질 수 있게 된다.
- 이러한 방식을 사용하기 위해서는 컴포넌트 사이의 의존성 순환이 없어야 한다.

### 순환이 컴포넌트 의존성 그래프에 미치는 영향

- 컴포넌트의 의존성이 순환하게 된다면, 순환되는 컴포넌트들은 모두 같은 릴리스 버전을 가져야 하기 떄문에 결국 하나의 컴포넌트와 다름없게 된다.
  - ex) A -> B -> C -> A 형태가 될 때, A 컴포넌트를 사용하는 D가 있다면 D는 A, B, C 모두를 신경써야 한다.
- 의존성 순환이 발생하면, 간단한 단위 테스트할 때에도 결국 관련된 모든 컴포넌트들을 빌드하고 통합해야 한다.
- 또한, 의존성 순환이 있는 경우 컴포넌트 사이의 빌드 순서도 파악하기 힘들어진다.

### 순환 끊기

- DIP 적용하기
- 순환하는 컴포넌트가 모두 의존하는 새로운 컴포넌트 만들기

### 흐트러짐(Jitters)

- 순환 끊기의 두 번째 방식이 시사하는 것은, 결국 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 것이다.
- 애플리케이션이 성장함에 따라 의존성 구조는 서서히 흐트러지며 성장한다.
- 의존성 구조에 순환이 발생하는지를 항상 관찰해야 하며, 순환이 발생하면 어떤 식으로든 끊어야 한다.

## 하향식(top-down) 설계

- 컴포넌트는 시스템에서 가장 먼저 설계 될 수 없으며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.
- 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 것이 아니라, 빌드 가능성과 유지보수성을 보여준다.
- 의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 것이다.
  - 자주 변경되는 컴포넌트에 의해 안정적인 컴포넌트가 영향 받기를 원하지 않는다.
- 컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다.
- 애플리케이션이 성장함에 따라 재사용 가능한 요소에 관심을 기울이게 되고, 이때 CRP가 영향을 미치기 시작하며 순환이 발생하면 ADP가 적용되면서 성장한다.
- 즉, 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하고자 한다면, 상당히 큰 실패를 맛볼 수 있다.
- 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다.

## SDP: 안정된 의존성 원칙

- 안정성의 방향으로 더 안정된 쪽에 의존하라.
- 설계는 정적일 수 없다. 설계를 유지하다 보면 변경은 불가피해진다.
- 공통 폐쇄 원칙을 준수함으로써, 컴포넌트가 다른 유형의 변경에 영향받지 않으면서도 특정 유형의 변경에만 민감하게 만들 수 있다.
- 즉, 컴포넌트 중 일부는 변동성을 지니도록 설계된다.
- 변동성을 지니도록 설계한 컴포넌트는 언젠가 변경되리라 예상한다.
- 변경이 쉽지 않은 컴포넌트가 변경이 예상되는 컴포넌트에 의존하게 만들어서는 절대 안 된다.
  - 변경이 쉽지 않은 컴포넌트 떄문에 변동성을 지니도록 설계한 컴포넌트도 변경이 어려워진다.

### 안정성

- 소프트웨어서 안정적인 상태이란 쉽게 움직이지 않는 상태 즉, 변경하는데 많은 노력이 필요한, 변경이 어려운 상태를 말한다.
- 특정 컴포넌트를 다른 여러 컴포넌트가 의존한다면, 해당 컴포넌트는 안정적이라 할 수 있다.
  - 사소한 변경이더라도 의존하는 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들게 된다.
- 반대로, 특정 컴포넌트가 다른 여러 컴포넌트에 의존한다면 이 컴포넌트는 안정적이지 않다고 할 수 있다.
  - 의존하고 있는 컴포넌트의 개수 만큼 변경될 가능성이 커지는 것이다.

### 안정성 지표

- 컴포넌트로 들어오고 나가는 의존성 개수를 통해 안정성을 측정할 수 있다.
- Fan-in: 안으로 들어오는 의존성 개수
- Fan-out: 바깥으로 나가는 의존성 개수
- I(불안정성) = Fan-out / (Fan-in + Fan-out)
  - 0에 가까울수록 안정적, 1에 가까울수록 불안정적이라는 뜻이다.
- I가 1이면 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만, 해당 컴포넌트는 다른 컴포넌트에 의존하는 것이다.
  - 즉, 컴포넌트는 최고로 불안정한 상태이다.
  - 자신에게 의존하는 컴포넌트가 없기 때문에 컴포넌트는 변경하지 말아야 할 이유가 없고, 언젠가 다른 컴포넌트에 의해 변경될 가능성이 있다는 것이다.
- I가 0이면, 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만, 해당 컴포넌트 자체는 다른 컴포넌트에 의존하지 않는다는 것이다.
  - 이러한 컴포넌트는 다른 컴포넌트를 책임지며, 독립적이고 최고로 안정적인 상태다.
  - 자신에게 의존하는 컴포넌트가 있으므로 해당 컴포넌트는 변경하기 어렵지만, 해당 컴포넌트를 변경하도록 강제하는 의존성을 갖지 않는다.
- SDP에서 컴포넌트 I 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야 한다고 말한다.
  - 즉, 의존성 방향으로 갈수록 I 지표 값이 감소해야 한다.

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다.

- 모든 컴포넌트가 안정적이라면, 변경이 불가능해진다.
- 가장 좋은 구조는 불안정한 컴포넌트와 안정적인 컴포넌트가 모두 존재하는 상황이다.

### 추상 컴포넌트

- 오로지 인터페이스만을 포함하는 컴포넌트를 생성하는 방식은 이상해 보일 수 있지만, 꼭 필요한 전략이다.
- 이러한 추상 컴포넌트는 상당히 안정적이며, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.
  - 자바나 C# 과 같은 정적 언어에서 자주 보인다.
  - 파이썬 등 동적 타입 언어에서는 인터페이스가 필요 없기 때문에 의존성이 더욱 간단해진다.

## SAP: 안정된 추상화 원칙

- 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

### 고수준 정책을 어디에 위치시켜야 하는가?

- 시스템에서 자주 변경해서는 절대 안 되는 소프트웨어의 경우 변동성이 없기를 바란다.
- 이러한 고수준의 정책은 반드시 안정된 컴포넌트에 위치해야 한다.
- 하지만, 안정된 컴포넌트에 위치하는 경우 수정하기가 어려워져 시스템 전체가 유연성을 잃을 수 있다.
- 컴포넌트가 안정적이면서 동시에 변경에 충분히 대응할 수 있도록 하기 위해 OCP를 적용할 수 있다.

### 안정된 추상화 원칙

- 안정된 추상화 원칙(SAP)은 안정성과 추상화 정도 사이의 관계를 정의한다.
- SAP는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다.
- 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.
  - 안정된 컴포넌트가 확장 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다.
- SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마친가지가 된다.
- DIP는 클래스에 대한 원칙이며, 클래스는 추상적이거나 그렇지 않은 상태만 있지만, 컴포넌트는 어떤 부분은 추상적이면서 어떤 부분은 안정적일 수 있다.

### 추상화 정도 측정하기

- Nc: 컴포넌트의 클래수 개수
- Na: 컴포넌트의 추상 클래스와 인터페이스 개수
- A(추상화 정도) = Na / Nc
  - A가 0이면 컴포넌트에는 추상 클래스가 하나도 없다는 것이다.
  - A가 1이면 컴포넌트는 오직 추상 클래스만 포함한다는 뜻이다.

### 주계열

- 추상화 정도(A)와 안정성(I) 사이의 관계를 정의할 수 있다.
  - y축을 A, x축을 I로 가정한다.
- (0,1) 은 추상화는 잘 안되어 있지만, 안정성이 높은 상태다.
- (1,0) 은 추상화는 잘 되어 있지만, 안정성은 낮은 상태다.
- 모든 클래스는 두 위치뿐 아니라 다양하게 존재한다.

#### 고통의 구역

- (0,0) 주변 구역의 컴포넌트는 매우 안정적이며 구체적인 상태다.
- 이러한 컴포넌트는 바람직한 상태는 아니다.
- 이 구역을 배제해야 할 구역으로, 고통의 구역이라 부른다.
- 일부 소프트웨어 엔티티는 고통의 구역에 위치하곤 한다.
  - 데이터베이스 스키마
- 구체적인 유틸리티 라이브러리도 이 구역에 위치한다.
  - String 클래스는 구체 클래스이며 변동성이 없다.
- 변동성이 없는 컴포넌트의 경우 이 구역에 속하더라도 해롭지 않다.
- 이 구역에 있는 클래스 중 변동성이 있는 컴포넌트는 변동성이 크면 클수록 수반되는 고통은 더욱 고통스러워진다.

#### 쓸모없는 구역

- (1,1) 주변 컴포넌트는 최고로 추상적이지만, 누구도 그 컴포넌트에 의존하지 않은 상태다.
- 이 주변의 컴포넌트는 쓸모가 없으며, 이 영역을 쓸모없는 구역이라 부른다.
- 이 영역의 엔티티는 누구도 구현하지 않은 채 남겨진 추상 클래스인 경우가 많으며 폐기물과 같다.

### 배제 구역 벗어나기

- 변동성이 큰 컴포넌트는 대부분 두 배제 구역으로부터 가능한 한 멀리 떨어뜨려야 한다.
- 각 배제 구역으로부터 멀리 떨어진 점의 궤적은 (1,0)과 (0,1) 을 잇는 선분이다.
  - 이 선분을 주계열이라 부른다.
- 주계열에 위치한 컴포넌트는 자신의 안정성에 비해 너무 추상적이지도 않고, 추상화 정도에 비해 너무 불안정하지도 않다.
- 컴포넌트가 위차할수 있는 가장 바람직한 지점은 주계열의 두 종점이다.
- 뛰어난 아키텍트라면 대다수의 컴포넌트가 두 종점에 위치하도록 만들기 위해 매진해야 한다.
- 대규모의 시스템에서 소수의 일부 컴포넌트는 완벽히 추상적이나 안정적일 수 없기 떄문에 주계열 바로 위 또는 가깝게 위치할 떄 가장 이상적이다.

### 주계열과의 거리

- D = |A+I-1| 지표를 통해 주계열 과의 거리를 측정할 수 있다.
  - 0이면 주계열 바로 위, 1이면 주계열로부터 가장 멀리 위치한다는 것이다.
- 모든 컴포넌트의 D 지표의 평균과 분산을 구하여 설계를 통계적으로 확인할 수 있다.
- 또한 D 지표를 시간에 따라 그려볼 수 있으며, 이를 통해 컴포넌트의 의존성이 어떻게 변화중인지 확인할 수 있다.

## 결론

- 의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 휼륭한 패턴이라고 생각하는 수준에 얼마나 잘 부합한지 측정한다.
- 좋은 의존성도 있고, 좋지 않은 의존성도 있다.
- 지표는 임의로 결정된 표준을 기초로 한 측정값에 지나지 않기 때문에 불안정하다는 사실을 알고 있어야 한다.
- 하지만 이러한 지표를 통해 유용한 무언가를 찾을 수 있을 것이다.