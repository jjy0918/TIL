# 18장 경계 해부학

## 경계 횡단하기

- 런타임에 경계를 횡단한다는 것은, 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 것이다.
- 절절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.
- 소스 코드가 변경됨에 따라 의존된 다른 코드도 변경하거나 다시 컴파일하게 되는데, 경계는 이러한 전파를 막아준다.

## 두려운 단일체

- 아키텍처 경계 중 가장 단순하면서 가장 흔한 형태는 물리적으로 엄격하게 구분되지 않는 형태다.
  - 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 나름의 규칙으로만 구분되어 있다.
- 배포의 관점에서 볼 때 단일체는 경계가 드러나지 않는다.
  - 단일체란 하나의 jar, exe 파일 등 단일 실행 파일을 말한다.
- 경계가 드러나지 않더라도, 경계가 실제로 존재하지 않거나 경계 자체가 무의미하다는 뜻은 아니다.
- 이러한 단일체의 거의 모든 경우 특정한 동적 다형성에 의존하여 내부 의존성을 관리한다.
- 정적 링크된 모노리틱 구조라 하더라도 저수준 -> 고수준 호출이 아니라, 고수준 -> 저수준 호출을 하지만 동적 다형성을 사용한 의존성 역전 원칙을 사용하여 경계를 분리하뎜 큰 도움이 된다.
  - 각 팀은 서로의 영역을 침범하지 않은 채 자신만의 컴포넌트를 독립적으로 작업할 수 있다.
  - 고수준의 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지된다.

## 배포형 컴포넌트

- 동적 링크 라이브러리(.NET DLL, jar 등)는 아키텍처 경계가 물리적으로 드러나는 형태다.
- 이러한 컴포넌트 형태로 배포하게 되면, 따로 컴파일 하지 않고 바로 사용 가능하지만 컴포넌트는 배포 가능한 형태(바이너리 등)로 전달되어야 한다.
- 배포는 단순히 배포 가능한 단위를 좀 더 편리한 형태로 묶는 일에 지나지 않게 된다.
- 하지만, 배포 과정만 차이가 날 뿐 이들은 단일체와 동일하다는 사실일 알아야 한다.

## 스레드

- 단일체와 배포형 모드 스레드를 활용할 수 있다.
- 스레드는 아키텍처 경계도 아니며 배포 단위도 아니다.

## 로컬 프로세스

- 로컬 프로세스는 정적으로 링크된 단일체이거나, 동적으로 링크된 여러개의 컴포넌트로 구성될 수 있다.
- 정적으로 링크된 단일체인 경우 여러 모노리틱 프로세스가 같은 컴포넌트들을 가지고 있을 수 있다.
- 동적으로 링크된 여러 컴포넌트인 경우 동적으로 링크된 배포형 컴포넌트들을 서로 공유할 수 있다.
- 로컬 프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성된다 할 수 있다.
- 로컬 프로세스 간 분리 전략은 단일체나 바이너리 컴포넌트의 경우와 동일하다.
  - 고수준 프로세스의 소스 코드가 저수준 프로스세의 이름, 물리 주소, 레지스트리 조회 키를 절대 포함해서는 안 된다.
  - 저수준 프로세스가 고수준 프로세스의 플러그인 되도록 만들어야 한다.

## 서비스

- 물리적인 형태를 띠는 가장 강력한 경계가 서비스다.
- 서비스는 프로세스로, 일반적으로 명령행 또는 그와 동등한 시스템 호추을 통해 구동된다.
- 서비스는 물리적 위치에 구애받지 않는다.
  - 물리적으로 동일한 프로세서나 코어에서 동작할 수도 있고, 아닐 수도 있다.
- 서비스 경계는 함수 호출에 비해 매우 느리기 때문에 주의를 기울여야 하며, 빈번하게 통신하는 일은 피해야 한다.
  - 통신의 지연에 따른 문제를 고수준에서 처리할 수 있어야 한다.
- 통신 문제를 제외하고 로컬 프로세스에 적용한 규칙이 서비스에도 그대로 적용된다.

## 결론

- 단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.
- 서비스 경계를 활용하는 시스템이라면 로컬 프로세스 경계도 일부 포함하고 있을 수 있다.
- 개별 서비스 또는 로컬 프로세스는 거의 언제나 소스 코드 컴포넌트로 구성된 단일체이거나, 혹은 동적으로 링크된 배포형 컴포넌트의 집합이다.
- 대체로 한 시스템안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있다.
