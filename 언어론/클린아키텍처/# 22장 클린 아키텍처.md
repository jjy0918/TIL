# 22장 클린 아키텍처

- Hexagonal, DCI, BCE 등 다양한 아키텍처들이 있지만, 결국 내용은 상당히 비슷하다.
  - 이들은 결국 관심사 분리라는 목표를 가지고 있다.
  - 각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 계층 하나를 반드시 포함한다.
  - 아키텍처는 프레임워크나 라이브러리에 의존하지 않는다.
  - 아키텍처는 테스트를 용이하게 만든다.
  - 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다.
  - 데이터베이스에 독립된다.
  - 모든 외부 에이전시에 대한 독립성을 가지고 있다.

## 의존성 규칙

- 클린 아키텍처 다이어그램에서 동심원은 서로 다른 영역을 표현하며, 안으로 들어갈수록 고수준의 소프트웨어가 된다.
- 아키텍처가 동작하도록 하는 가장 중요한 규칙은 의존성 규칙이다.
  - 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.
- 내부의 원은 외부의 원에 속한 어떤 것도 알지 못한다.
  - 내부 원에 속한 코드는 외부의 함수, 클래스, 변수 등 어떤 것도 언급해서는 안 된다.
- 외부 원에 위치한 어떤 것도 내부의 원에 영향을 주지 않기를 바란다.

### 엔티티

- 엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다.
- 엔티티는 메서드를 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일 수도 있다.
  - 다양한 애플리케이션에서 재사용할 수 있다면 그 형태는 그다지 중요하지 않다.
- 단일 애플리케이션을 작성한다면, 엔티티는 애플리케이션의 업무 객체가 된다.
  - 이 경우 엔티티는 가장 일반적이며, 고수준의 규칙을 캡슐화한다.
  - 외부의 무언가가 변경되더라도 엔티티가 변경될 가능성은 지극히 낮다.

### 유스케이스

- 유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함한다.
- 유스케이스 계층의 소프트웨어는 시스템의 모든 유스케이스를 캡슐화하고 구현한다.
- 유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용하여 유스케이스의 목적을 달성하도록 이끈다.
- 이 계층에서 발생한 변경이 엔티티에 영향을 줘서는 안 된다.
- 또한, 외부에서 발생한 변경이 이 계층에 영향을 줘서도 안 된다.
- 운영 관점에서 애플리케이션이 변경된다면, 유스케이스가 영향을 받을 수 있다.

### 인터페이스 어댑터

- 인터페이스 어댑터 계층은 일련의 어댑터들로 구성된다.
- 어댑터는 데이터나 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 방식으로 변환한다.
- 이 계층은 GUI의 MVC 아키텍처를 모두 포괄한다.
  - 프레젠터, 뷰, 컨트롤러 모두 인터페이스 어댑터 계층에 속한다.
- 이 계층은 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용 프레임워크(데이터베이스)가 이용하기 편리한 형식으로 변환한다.
- 이 원 안에 속한 어떤 코드도 데이터베이스에 대해 조금도 알아서는 안 된다.
- 이 계층에는 데이터를 외부 형식에서 유스케이나 엔티티에서 사용되는 내부적은 형식으로 변환하는 또 다른 어댑터가 필요하다.

### 프레임워크와 드라이버

- 가장 바깥쪽 계층은 일반적으로 데이터베이스나 웹 프레임워크 같은 도구들로 구성된다.
- 이 계층은 안쪽원과 통신하기 위한 접합 코드 외에 특별한 코드가 그다지 많지 않다.
- 프레임워크와 드라이버 계층은 모든 세부사항이 위치한 곳이다.
  - 웹, 데이터베이스는 세부사항이다.
- 세부사항들을 모두 외부에 위치시켜 피해를 최소화한다.

### 원은 네 개여야만 하나?

- 원은 항상 네 개만 사용할 필요 없으며, 네 개보다 더 많을 수 있다.
- 어떤 경우에도 의존성 규칙은 적용된다.
- 안쪽으로 이동할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다.
- 가장 안쪽 원은 가장 범용적이며 높은 수준을 가진다.

### 경계 횡단하기

- 제어 흐름은 컨트롤러에서 시작하여 유스케이스를 지나 프레젠터에서 실행되는 형태다.
- 소스 코드의 의존성은 유스케이스를 향해 안쪽으로 가리킨다.
- 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 대체로 의존성 역전 원칙을 사용하여 해결한다.
- 예를 들어 유스케이스에서 프레젠터를 호출해야 하는 경우 프레젠터를 직접 호출하게 되면 의존성 규칙을 위반하게 된다.(내부 원이 외부 원 호출) 
- 이때 유스케이스가 내부 원 인터페이스를 호출하는 형태로 만들고, 프레젠터는 내부 원 인터페이스를 구현하도록 만들면 된다.
- 동적 다형성을 이용하여 소스 코드 의존성을 제어흐름과는 반대로 만들 수 있다.

### 경계를 횡단하는 데이터는 어떤 모습인가

- 경계를 가로지르는 데이터는 간단한 데이터 구조로 이루어져 있다.
  - 기본적인 구조체, 간단한 데이터 전송 객체 등
- 중요한 점은 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달된다는 점이다.
- 경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기 가장 편리한 형태를 가져야 한다.

## 결론

- 소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들 수 있다.
- 데이터베이스나 웹 프레임워크와 같은 시스템의 외부 요소가 구식이 되더라도, 이들 요소를 야단스럽지 않게 교체할 수 있다.