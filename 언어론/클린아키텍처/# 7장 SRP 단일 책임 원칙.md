# 7장 SRP: 단일 책임 원칙

## SRP 란

- SRP는 부적절한 이름 때문인지 잘못 받아들이는 경우가 많다.
- SRP는 단순히 모듈이 단 하나의 일만 해야 하는다는 것이 아니라, `단일 모듈은 변경의 이유가 하나, 오직 하나의 액터에 대해서만 책임져댜 한다.`는 것이다.
  - 하나의 일만 하는 것은 함수다.
  - 모듈이란 소스 파일 즉, 함수와 데이터로 구성된 응집된 집합을 말한다.
  - 액터란 변경을 요청하는 한 명 이상의 사람을 말한다.
- SRP에서 단일 액터르 책임지는 코드를 함께 묶어주는 힘은 응집성이다.

## SRP 원칙을 위반하는 징후

### 징후 1: 우발적 중복

- 급여 애플리케이션 Employee 클래스가 있다.
- Employee 클래스는 calculatePay(), reportHours(), save() 메서드를 가지고 있다.
- Employee 클래스는 서로 다른 세 명의 액터를 책임지기 때문에 SRP를 위반한다.
  - calculatePay() 는 회계팀에서 기능을 정의하고, CFO 보고를 위해 사용한다.
  - reportHours() 는 인사팀에서 기능의 정의하고, COO 보고를 위해 사용한다.
  - save() 는 DBA가 기능을 정의하고 CTO 보고를 위해 사용한다.
- Employee가 서로 다른 액터의 책임을 가지고 있기 때문에 변화에 따라 서로 다른 액터가 영향을 받게 된다.

```
// 서로 다른 액터가 영향을 받는 예시

calculatePay와 reportHours가 regularHours() 라는 초과 근무 알고리즘 메서드를 공유한다.
이때, CFO팀에서 초과 근무 알고리즘 계산 방식을 수정하고 싶다.
하지만, COO 팀에서는 초과 근무 알고리즘 계산 방식의 수정을 원하지 않는다.
개발자가 CFO 팀의 요청을 처리하면서, COO팀에서 호출중인 reportHours에 regularHours가 사용된다는 사실을 눈치채지 못하면 COO팀에서는 문제가 발생하게 된다.
```

- SRP는 위 예시 처럼 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.

### 징후 2: 병합

- 소스 파일에 다양한 메서드가 포함되어 있으면 병합이 자주 발생할 수 있다.
  - 특히, 서로 다른 액터를 책임진다면, 병합이 발생할 가능성은 더 높아진다.
- 서로 다른 개발자가, Employee 클래스를 체크아웃 받아 서로 다른 기능을 변경하게 되면, 서로 충돌이 발생하고 결과적으로 병합이 발생한다.
- 어떤 도구도 병합이 발생하는 모든 경우를 해결할 수 없기 떄문에 결국은 항상 위험이 뒤따르게 된다.

### 해결책

- 이러한 징후들에 의해 발생한 문제점의 해결책은 여러가지가 있지만, 대부분은 메서드를 각기 다른 클래스로 이동시키는 방식이다.
- 이 예시에서 가장 좋은 방식은 데이터와 메서드를 분리하는 것이다.
  - 데이터만 다루는 EmployeeData 클래스를 만들어 세 개의 클래스가 공유하게 만든다.
  - 이러한 방식은  세 가지 클래스를 인스턴스화 하고 추적해야 하는 단점이 있지만, 이는 퍼사드 패턴을 통해 해결할 수 있다.

## 결론

- 단일 책임 원칙은 메서드와 클래스 수준의 원칙이다.
- 하지만 컴포넌트 수준에서는 공통 폐쇄 원칙이 되며, 아키텍처 수준에서는 경꼐 생성을 책임지는 변경의 축이 된다.