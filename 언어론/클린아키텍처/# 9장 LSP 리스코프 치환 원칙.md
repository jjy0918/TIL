# 9장 LSP 리스코프 치환 원칙

- 리스코프는 하위 타입에 대해 아래와 같이 정의한다.

```
S 타입의 객체 o1, T 타입 객체 o2가 있다.
T 타입을 이용해서 정의한 모든 프로그램 P에서 o2 자리를 o1 으로 치환하더라도 P의 행위가 변하지 않는다면,
S는 T의 하위 타입이다.
```

## 상속을 사용하도록 가이드하기

- License 라는 인터페이스가 있고, 이를 PersonalLicense, BusinessLicense 두 하위 타입이 존재한다.
- Billing 애필르케이션은 License 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않기 떄문에 이들 하위 타입은 License 타입을 치환할 수 있다.

## 정사각형/직사각형 문제

- LSP를 위반하는 전형적인 문제로 유명한 정사각형/직사각형(square/rectangle) 문제가 있다.
- Square는 Rectangle 인터페이스를 구현한 구현체이지만, 하위 타입으로는 적절하지 않다.
  - Rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있지만,  Square는 높이와 너비가 반드시 함께 변경되기 때문에다.
  - 사용자가 Rectangle 만 보고 생각하기 때문에 혼동이 생길 수 있다.
- 이러한 형태에서 LSP를 막기 위한 방법은 Rectangle이 Square인지 사용하는 측면에서 추가해야 하지만, 이러한 방식은 타입에 의존하게 되기 때문에 결국 치환할 수 없게 된다.

## LSP와 아키텍처

- 객체지향 초기에는 LSP를 상속으로 사용하도록 했지만, 이후에는 인터페이스와 구현체에도 적용되는 더 광범위한 설계 원칙이 되었다.
- 인터페이스란 자바에서는 인터페이스 구현체로, 루비라면 메서드 시그니처를 구현하는 형태로 구성된다.
- 아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것이다.

## LSP 위배 사례

- 택시 파견 서비스를 개발하고 있다고 해보자.
- 택시 파견은 사용자의 상황에 따라 DB에 있는 기사를 선택하고 해당 기사를 고객 위치로 파견한다.
- 택시 파견 시 URI는 purplecab.com/driver/{기사}/picupAddress/{위치}/pickupTime/{시간}/destination/{위치} 형태로 사용중이다.
  - 이러한 형태의 URI를 이용하여 다양한 택시업체가 있더라도 준수하도록 만든다.
- 이때, 택시업체 애크미에서는 destination을 dest로 축약하여 전달하게 되면, 결국 파견 명령어를 구성하는 모듈에서 if문을 통해 별도로 로직이 추가되어야 한다.
- 이러한 과정은 끔찍할 뿐 아니라 이해할 수도 없는 온갖 종류의 에러가 발생할 여지를 만든다.

## 결론

- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.
- 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당향의 별도 메커니즘을 추가해야 할 수 있다.