# 11장 시스템

## 시스템 제작과 시스템 사용을 분리하라.

- 제작(construction)은 사용(use)와 아주 다르다.
- 소프트웨어 시스템은 준비 과정과 런타임 로직을 분리해야 한다.
- 시작 단계에서 모든 애플리케이션은 `관심사 분리`를 해야 한다.
  - 관심사 분리가 제대로 이루어지지 않으면 코드를 주먹구구식으로 구현할 뿐 아니라 런타임 로직과 마구 뒤섞인다.

```java
public Service getService() {
    if(service == null)
        service = new MyServiceImpl(...);   // 실제 런타임에서 값이 설정된다. --> 런타임 로직에 객체 생성 로직이 섞여있다. --> SRP가 깨진 것
    return service;
}
```

- 체계적이고 탄탄한 시스템을 만들기 위해서는 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대 안 된다.
  - 위 예시처럼 레이지 로딩 등의 기법은 모듈성을 깨기 쉽다.
- 객체를 생성하거나 의존성을 연결할 떄에도 분리해서 생각해야 모듈성이 높아진다.
  - 설정 논리와일반 실행 논리를 분리하라.
- 주요 의존성을 해소하기 위한 방식, 즉 전반적이며 일관적인 방식도 필요하다.

### Main 분리

- 생성과 사용을 분리하기 위한 한 가지 방법으로는 생성과 관련된 코드는 모두 main으로 옮기고 나머지는 객체가 생성되었고 모든 의존성이 연결되도록 하는 것이다.
- `main 함수`에서 시스템에 필요한 객체를 `생성`한 후 애플리케이션에 이를 넘기는 것이다.
- `애플리케이션`에서는 모든 객체가 생성되었기 때문에 단순히 `사용`만 하면 된다.
  - 애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모르게 되는 것이다.

### 팩토리

- 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요가 생긴다.
- 이럴때에는 Abstract Factory 패턴을 사용하면 된다.
- 이러한 방식도 결국은 생성과 사용이 분리된다.
- 생성은 팩토리에서만 진행되며, 애플리케이션은 어떤 객체가 생성되었는지에 관계 없이 사용에만 집중한다.

### 의존성 주입

- 사용과 제작을 분리하는 가장 강력한 메커니즘 중 하나가 `의존성 주입`이다.
- 의존성 주입은 `제어 역전 기법`을 의존성 관리에 적용한 메커니즘이다.
- 제어의 역전을 통해 객체는 의존성 자체를 인스턴스로 만드는 책임을 지지 않게 된다.
  - 이러한 책임을 다른 전담 메커니즘에게 넘긴다.
  - 책임질 메커니즘으로 main 루틴이나 특수 컨테이너를 사용한다.
  - 스프링 프레임워크는 가장 널리 알려준 자바 DI컨테이너다.
- DI 컨테이너는 필요한 객체 인스턴스를 만든 후 생성자나 설정자(setter) 메서드를 사용하여 의존성을 설정한다.
  - 실제 생성되는 객체 유형은 설정 파일에서 지정하거나 특수 생성 모듈에서 코드로 명시한다.

## 확장

- 일반적으로 확장은 차근차근 발생한다.
- 나중에 확장할 것이라는 미래가 있다고 하여 처음부터 과도하게 설계하지는 않는다.
- 현재의 상황에 맞게 시스템을 설계해야 하며, 미래의 상황에는 그때의 상황에 맞게 조정하고 확장하면 된다.
- 소프트웨어는 관심사가 적절히 분리되어 있다면 점진적인 확장이 가능하다.
  - ex) EJB는 프레임워크과 강력하게 결합되어 있어서 테스트나 확장이 힘들다.

### 횡단(cross-cutting) 관심사

- EJB2 아키텍처에서 일부 영역은 관심사를 거의 완벽하게 분리했다.
- 트랜잭션, 보안, 일부 영속적인 동작은 소스 코드가 아니라 배치 기술자에서 정의한다.
- 특정 영역에서만이 아니라 모든 객체가 전반적으로 동일한 방식을 이용하도록 만드는 것이고, 이를 `횡단 관심사`라고 한다.
- 이러한 아키텍처는 `관점 지향 프로그래밍(AOP)`의 시작이라 볼 수 있다.
- AOP에서 관점(aspect)이라는 모듈 구성 개념은 "특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다" 라고 명시한다.
- 자바에서는 AOP 관련 메커니즘 3개가 존재한다.

#### 1. 자바 프록시

- 자바 프록시는 단순한 상황에 적합하다.
  - 개별 객체나 클래스에서 메서드 호출을 감싸는 것이다.
- JDK에서 제공하는 동적 프록시는 인터페이스만 지원하기 떄문에 클래스 프록시를 사용하기 위해서는 GCLIB, ASM, Javassist 등과 같은 바이트 코드 처리 라이브러리가 필요하다.
- 별도의 라이브러리가 필요하기 때문에 코드 양이 상당히 증가하게 되며 복잡해진다.
- 즉, 프록시를 사용하면 깨끗한 코드를 작성하기 어렵다는 단점이 존재한다.
- 또한 프록시는 시스템 단위로 실행 지점을 명시하는 메커니즘을 제공하지 않는다.
  - 단순히 프록시 형태로 감싸는 행위한 할 뿐, 해당 지점을 명시하여 모듈화된 방식은 제공하지 않는다.
  
#### 2. 순수 자바 AOP 프레임워크

- 자바의 프록시 코드는 복잡하기는 하지만, 대부분 판박이라 도구로 자동화가 가능하다.
- 스프링 AOP, JBoss AOP 등과 같은 자바 프레임워크는 내부적으로 프록시를 사용한다.
- 스프링에서는 비즈니스 로직을 POJO로 구현하고, 프레임워크 단위에서 관점을 제시하여 AOP를 구현한다.
  - 즉, 프레임워크는 사용자 모르게 프록시나 바이트코드 라이브러리를 사용하여 이를 구현하고, 연결한다.

#### 3. AspectJ 관점

- 관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ 언어다.
- AspectJ는 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다.

## 테스트 주도 시스템 아키텍처 구축

- 관심사를 분리하는 방식은 그 위력이 막강하며, 도메인 로직을 POJO로 작성할 수 있다면 진정한 테스트 주도 아키텍처 구축이 가능해진다.
- 소프트웨어는 건축과 다르게 모든 형체를 고려하여 구현하는 것이 아니라 관점을 효과적으로 분리하여 결과물을 만든 뒤 기반 구조를 조금씩 추가하는 방향으로 확장해야 한다.

## 의사 결정을 최적화하라.

- 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다.
- 아주 큰 시스템에서 한 사람이 모든 결정을 내리기는 어렵기 때문에 가장 적합한 사람에게 책임을 맡기는 것이 가장 좋다.

## 결론

- 시스템은 깨끗해야 한다.
- 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다.
- 도메인 논리가 흐려지면 제품 품질이 떨어진다.
- 모든 추상화 단계에서 의도는 명확하게 표현해야 한다.
  - 이를 위해 POJO를 작성하고 관점 혹은 유사한 메커니즘을 사용하여 관심사를 분리해야 한다.
- 시스템을 설계하든 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명시하자.