# 3장 함수

## 작게 만들어라

- 함수를 만드는 첫째 규칙은 `작게`이고, 둘째 규칙은 `더 작게`이다.
- if 문/else 문/ while 문에 들어가는 블록은 한 줄이어야 하고, 이떄 함수가 들어간다.
- 즉, 중첩 구조가 생길만큼 함수가 커져서는 안 된다.
- 함수의 들여쓰기 수준은 1단이나 2단을 넘어서는 안 된다.

## 한 가지만 해라!

- 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한가지만을 해야 한다.
- 단순히 단계가 한 단계가 아니라고 해서 한 가지 일을 하지 않는 것은 아니다.
- 간단하게 생각하자면 함수 이름 아래에서 `추상화 수준이 하나`인 단계만 수행한다면 그 함수는 한 가지 일만 하는 것이다.
  - 더 간단하게 생각하자면, 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면, 그 함수는 여러 일을 하는 것이다.
- 한 함수에서 여러 섹션으로 나눌 수 없다면, 하나의 역할을 하고 있다는 것이다.


## 함수 당 추상화 수준은 하나로!

- 함수가 확실히 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
- 한 함수 내에 추상화 수준이 섞이면, 코드를 읽는 사람이 헷갈린다.
  - getHtml() --> 추상화 수준이 높음
  - String pagePathName = PathParser.render(pagePath) --> 추상화 수준이 중간
  - .append("\n") --> 추상화 수준이 낮음

### 위에서 아래로 코드 읽기: 내려가기 규칙

- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
- 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
  - 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.
  - 이를 `내려가기` 규칙 이라 부른다.

## Switch 문

- Switch문(if/else가 여럿 이어지는 구문)은 작게 만들기 어렵다.
- 본질적으로 Switch문은 N가지를 처리한다.

## 서술적인 이름을 사용하라.

- 함수의 이름은 수행하는 동작을 예상할 수 있어야 한다.
- 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
- 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
- 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다.
  - 그 후 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.
- 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.
- 이름을 붙일 때에는 일관성이 있어야 한다.

## 함수 인수

- 함수에서 이상적인 인수는 0개다.
  - 그 다음은 1개, 그 다음은 2개
  - 3개는 가능한 피하는 편이 좋고, 4개 이상은 특별한 이유가 없다.
- 함수와 인수 사이에는 추상화 수준이 같아야 한다.
- 함수의 인수가 많아질 수록 함수를 사용하는 입장에서 고려해야할 부분이 많아지며, 테스트도 힘들어진다.
- 출력 인수는 입력 인수보다 이해하기 어렵다.
- 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다.

### 많이 쓰는 단항 형식

1. 인수에 질문을 던지는 경우
    - boolean fileExists("MyFile")
2. 인수를 뭔가로 변환해 결과를 반환하는 경우
    - InputStream fileOpen("MyFile")
3. (드물게) 입력 함수를 이용하여 시스템 상태를 변경하는 이벤트
    - passwordAttemptFailedNtimes(int attempts)
    - 이벤트 함수는 이벤트라는 사실이 코드에 명확히 드러나야 한다.
    - 이름과 문맥을 주의해서 선택해야 한다.

- 위 3가지 경우가 아니라면 단항 함수는 가급적 피하라.

### 플래그 인수

- 플래그 인수는 추하다.
- 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하고 있는 것이다.

### 이항 함수

- 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
- 인수가 2개인 함수는 그 2개의 인수가 자연적으로 어우러질 경우에만 사용해야 한다.
  - ex) Point p = new Point(0, 0);  // 좌표는 자연스럽게 2개다.

### 삼항 함수

- 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
  - 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다.

### 인수 객체

- 인수가 2-3개 필요하다면, 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.
- 객체를 생성해 인수를 줄이는 방법이 눈속임이라 여겨질지 모르지만, 그렇지 않다.
  - 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국 개념을 표현하게 된다.

### 인수 목록

- 때로는 가변 인수를 가지는 함수도 필요하다.
- 가변 인수는 여러 인수를 받는 것 처럼 보이지만, 결국 List 형태로 받는 것과 다르지 않기 때문에 하나의 인수로 볼 수 있다.
- 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있고 이를 넘어서는 인수를 사용할 경우에는 문제가 있다.

### 동시와 키워드

- 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다.
- `단항 함수`는 `함수`와 `인수`가 `동사/명사 쌍`을 이뤄야 한다.
  - write(name) / writeField(name)
- 함수 이름에 `키워드`를 추가할 수 있다.
  - assertEquals 보다 assertExpectedEqualsActual 이 더 좋다.

## 부수 효과를 일으키지 마라!

- 부수 효과는 거짓말이다.
  - 함수에서 한 가지를 하곘다고 약속하고선 남몰래 다른 짓을 하는 것이다.
- 부수 효과는 많은 경우 시간적인 결합이나 순서 종속성을 초래한다.
- 함수 이름만으로 예측할 수 있는 행동 외에 행동이 있다면, 이름에 반드시 넣어야 한다.

### 출력 인수

- 일반적으로 우리는 인수를 `입력`으로 해석한다.
- 출력 인수는 그 정체를 함수의 선언부를 찾아보고 나서야 알 수 있다.
  - 함수 선언부를 찾아보는 행위는 코드를 보다가 주춤하는 행위와 동급이다.
- 일반적으로 출력 인수는 피해야 한다.
- 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택하라.

## 명령과 조회를 분리하라!

- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.
  - 둘 다 하면 안 된다.
  - 둘 다 하면 혼란을 초래한다.

## 오류 코드보다 예외를 사용하라.

- 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.
- 오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제에 부딪힌다.
- 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.

### try/catch 블록 뽑아내기

- try/catch 블록은 원래 추하다.
- 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다.
- 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.
- 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다.

### 오류 처리도 한 가지 작업이다.

- 함수는 한 가지 작업만 해야 하며, 오류 처리도 한 가지 작업에 속한다.
- 오류를 처리하는 함수는 오류만 처리해야 마땅하다.

### Error.java 의존성 자석

- 오류 코드를 반환한다는 이야기는, 클래스든 열거형 변수든, 어디선가 오류 코드를 정의한다는 것이다.
- Error enum을 사용한다면, 해당 enum을 import 해야 하고 Error enum이 변경되면 다시 컴파일 및 배치해야 한다.
  - 이러한 클래스를 의존성 자석이라 한다.
- 이러한 의존성 자석 Error enum은 변경이 어려워지고, 번거롭다.
- 오류 코드 대신 예외를 사용하면 새 예외는 Exception 클래스에서 파생되어 재컴파일/재배치 없이도 새 예외 클래스를 추가할 수 있다.

## 반복하지 마라!

- 중복은 소프웨어에서 모든 악의 근원이다.

## 구조적 프로그래밍

- 어떤 프로그래머는 다익스트라의 구조적 프로그래밍 원칙을 따른다.
- 다익스트라는 모든 함수와 함수 내 모든 블록에 `입구`와 `출구`는 하나만 존재해야 한다고 말한다.
- 즉, 함수는 return 문이 하나여야 한다.
- 루프 안에서 break나 continue를 사용해선 안 되며 goto는 절대로 안 된다.
- 함수가 작다면 구조적 프로그래밍은 별 효과가 없다.
- 함수를 작게 만든다면 간혹 return, break, continue를 여러 차례 사용해도 괜찮다.
  - 그래도 goto는 피하라.

## 함수를 어떻게 짜죠?

- 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다.
  - 먼저 생각을 기록한 후 읽기 좋게 다듬는다.
  - 초안은 대게 서투르고 어수선하기 때문에 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다.
- 함수를 짤 때에도 비슷하다.
  - 처음에는 길고 복잡하고 중복 루프도 많고 인수도 많다.
  - 이에 대한 단위 테스트 케이스를 빠짐 없이 만든다.
  - 그 다음 코드를 다듬고 함수를 만들고, 이름을 바꾸고 중복을 제거한다.
  - 변경하는 중에도 단위 테스트는 항상 통과해야 한다.